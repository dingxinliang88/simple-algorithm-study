<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [算法学习之路--动态规划篇之专项练习](#%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF--%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AF%87%E4%B9%8B%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0)
  - [一、LeetCode经典题目解析](#%E4%B8%80leetcode%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90)
    - [198、打家劫舍](#198%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D)
      - [题目](#%E9%A2%98%E7%9B%AE)
      - [思路](#%E6%80%9D%E8%B7%AF)
      - [实现](#%E5%AE%9E%E7%8E%B0)
    - [213、打家劫舍II](#213%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8Dii)
      - [题目](#%E9%A2%98%E7%9B%AE-1)
      - [思路](#%E6%80%9D%E8%B7%AF-1)
      - [实现](#%E5%AE%9E%E7%8E%B0-1)
    - [337、打家劫舍III](#337%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8Diii)
      - [题目](#%E9%A2%98%E7%9B%AE-2)
      - [思路](#%E6%80%9D%E8%B7%AF-2)
      - [实现](#%E5%AE%9E%E7%8E%B0-2)
    - [121、买卖股票的最佳时机](#121%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA)
      - [题目](#%E9%A2%98%E7%9B%AE-3)
      - [思路](#%E6%80%9D%E8%B7%AF-3)
      - [实现](#%E5%AE%9E%E7%8E%B0-3)
    - [122 买卖股票的最佳时机II](#122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAii)
      - [题目](#%E9%A2%98%E7%9B%AE-4)
      - [思路](#%E6%80%9D%E8%B7%AF-4)
      - [实现](#%E5%AE%9E%E7%8E%B0-4)
    - [123、买卖股票的最佳时机III](#123%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAiii)
      - [题目](#%E9%A2%98%E7%9B%AE-5)
      - [思路](#%E6%80%9D%E8%B7%AF-5)
      - [实现](#%E5%AE%9E%E7%8E%B0-5)
    - [188、买卖股票的最佳时机IV](#188%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAiv)
      - [题目](#%E9%A2%98%E7%9B%AE-6)
      - [思路](#%E6%80%9D%E8%B7%AF-6)
      - [实现](#%E5%AE%9E%E7%8E%B0-6)
    - [309、最佳买卖股票时机含冷冻期](#309%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F)
      - [题目](#%E9%A2%98%E7%9B%AE-7)
      - [思路](#%E6%80%9D%E8%B7%AF-7)
      - [实现](#%E5%AE%9E%E7%8E%B0-7)
    - [714、最佳买卖股票时机含手续费](#714%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9)
      - [题目](#%E9%A2%98%E7%9B%AE-8)
      - [思路](#%E6%80%9D%E8%B7%AF-8)
      - [实现](#%E5%AE%9E%E7%8E%B0-8)
    - [300、最长递增子序列](#300%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97)
      - [题目](#%E9%A2%98%E7%9B%AE-9)
      - [思路](#%E6%80%9D%E8%B7%AF-9)
      - [实现](#%E5%AE%9E%E7%8E%B0-9)
    - [674、最长连续递增序列](#674%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97)
      - [题目](#%E9%A2%98%E7%9B%AE-10)
      - [思路](#%E6%80%9D%E8%B7%AF-10)
        - [动态规划](#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92)
        - [贪心](#%E8%B4%AA%E5%BF%83)
      - [实现](#%E5%AE%9E%E7%8E%B0-10)
        - [动态规划](#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-1)
        - [贪心](#%E8%B4%AA%E5%BF%83-1)
    - [718、最长重复子数组](#718%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84)
      - [题目](#%E9%A2%98%E7%9B%AE-11)
      - [思路](#%E6%80%9D%E8%B7%AF-11)
      - [实现](#%E5%AE%9E%E7%8E%B0-11)
    - [1143、最长公共子序列](#1143%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97)
      - [题目](#%E9%A2%98%E7%9B%AE-12)
      - [思路](#%E6%80%9D%E8%B7%AF-12)
      - [实现](#%E5%AE%9E%E7%8E%B0-12)
    - [1035、不相交的线](#1035%E4%B8%8D%E7%9B%B8%E4%BA%A4%E7%9A%84%E7%BA%BF)
      - [题目](#%E9%A2%98%E7%9B%AE-13)
      - [思路](#%E6%80%9D%E8%B7%AF-13)
      - [实现](#%E5%AE%9E%E7%8E%B0-13)
    - [53、最大子序和](#53%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C)
      - [题目](#%E9%A2%98%E7%9B%AE-14)
      - [思路](#%E6%80%9D%E8%B7%AF-14)
      - [实现](#%E5%AE%9E%E7%8E%B0-14)
    - [392、判断子序列](#392%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97)
      - [题目](#%E9%A2%98%E7%9B%AE-15)
      - [思路](#%E6%80%9D%E8%B7%AF-15)
      - [实现](#%E5%AE%9E%E7%8E%B0-15)
    - [115、不同的子序列](#115%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97)
      - [题目](#%E9%A2%98%E7%9B%AE-16)
      - [思路](#%E6%80%9D%E8%B7%AF-16)
      - [实现](#%E5%AE%9E%E7%8E%B0-16)
    - [583、两个字符串的删除操作](#583%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C)
      - [题目](#%E9%A2%98%E7%9B%AE-17)
      - [思路](#%E6%80%9D%E8%B7%AF-17)
      - [实现](#%E5%AE%9E%E7%8E%B0-17)
    - [72、编辑距离](#72%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB)
      - [题目](#%E9%A2%98%E7%9B%AE-18)
      - [思路](#%E6%80%9D%E8%B7%AF-18)
      - [实现](#%E5%AE%9E%E7%8E%B0-18)
    - [647、回文子串](#647%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2)
      - [题目](#%E9%A2%98%E7%9B%AE-19)
      - [思路](#%E6%80%9D%E8%B7%AF-19)
        - [动态规划](#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-2)
        - [双指针](#%E5%8F%8C%E6%8C%87%E9%92%88)
      - [实现](#%E5%AE%9E%E7%8E%B0-19)
        - [动态规划](#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-3)
        - [双指针](#%E5%8F%8C%E6%8C%87%E9%92%88-1)
    - [516、最长回文子序列](#516%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97)
        - [题目](#%E9%A2%98%E7%9B%AE-20)
      - [思路](#%E6%80%9D%E8%B7%AF-20)
      - [实现](#%E5%AE%9E%E7%8E%B0-20)
  - [二、动态规划总结篇](#%E4%BA%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93%E7%AF%87)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

<!--more-->

# 算法学习之路--动态规划篇之专项练习

## 一、LeetCode经典题目解析

### 198、打家劫舍

#### 题目

题目链接：**[198. 打家劫舍 - 力扣（LeetCode）](https://leetcode.cn/problems/house-robber/)**

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。

给定一个代表每个房屋存放金额的非负整数数组，计算你 **不触动警报装置的情况下** ，一夜之内能够偷窃到的最高金额。

**示例 1：**

```
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

**示例 2：**

```
输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```

**提示：**

- `1 <= nums.length <= 100`
- `0 <= nums[i] <= 400`

#### 思路

打家劫舍是dp解决的经典问题。动归五部曲：

1. 确定dp数组以及下标的含义
   `dp[i]`：表示下标`i`（包含 i ）以内的房屋，最多可以偷窃的金额为`dp[i]`

2. 确定递推公式
   决定`dp[i]`的因素是第 i 间房间偷还是不偷。如果偷第 i 间房间，那么`dp[i] = dp[i - 2] + nums[i]`，即第 i-1 间房一定是不考虑的，找出下标 i-2 （包含 i-2）以内的房屋，最多可以偷窃的金额为`dp[i - 2]`加上第 i 间房间偷到的钱；如果不偷第 i 间房间，那么`dp[i] = dp[i - 1]`，即考虑第 i - 1 间房（注意这里是考虑，并不是一定要偷第 i-1 间房）。然后`dp[i]`取最大值
   =>  递推公式：`dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i])` 

3. dp数组初始化
   从递推公式：`dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i])` 可以看出递推基础是`dp[0]`和`dp[1]`
   从`dp[i]`的定义上来讲，`dp[0] = nums[0]`，`dp[1] = Math.max(nums[0], nums[1])`

   ```java
   int[] dp = new int[nums.length];
   dp[0] = nums[0];
   dp[1] = Math.max(nums[0],nums[1]);
   ```

4. 确定遍历顺序
   `dp[i]` 是根据`dp[i - 2] `和 `dp[i - 1]` 推导出来的，那么⼀定是从前到后遍历！

   ```java
   for (int i = 2; i < nums.length; i++) {
    dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1]);
   }
   ```

5. 举例推导dp数组
   以示例二输入为例
   ![image-20221218155329209](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20221218155329209.png)

#### 实现

Java代码

```java
class Solution {
    public int rob(int[] nums) {
        int len = nums.length;
        if(len == 1) return nums[0];
        int[] dp = new int[len];
        dp[0] = nums[0];
        dp[1] = Math.max(nums[0], nums[1]);
        for(int i = 2; i < len; i++) {
            dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);
        }
        return dp[len - 1];
    }
}
```



### 213、打家劫舍II

#### 题目

题目链接：**[213. 打家劫舍 II - 力扣（LeetCode）](https://leetcode.cn/problems/house-robber-ii/)**

你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 **围成一圈** ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警** 。

给定一个代表每个房屋存放金额的非负整数数组，计算你 **在不触动警报装置的情况下** ，今晚能够偷窃到的最高金额。

 **示例 1：**

```
输入：nums = [2,3,2]
输出：3
解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的
```

**示例 2：**

```
输入：nums = [1,2,3,1]
输出：4
解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

**示例 3：**

```
输入：nums = [1,2,3]
输出：3
```

**提示：**

- `1 <= nums.length <= 100`
- `0 <= nums[i] <= 1000`

#### 思路

这道题目和**[198. 打家劫舍 - 力扣（LeetCode）](https://leetcode.cn/problems/house-robber/)**是大差不差的，唯一的区别就是成环了

对于一个数组，成环主要是如下三种情况

- 情况一：考虑不包含首尾元素
  ![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221218160126.png)
- 情况二：考虑包含首元素，不包含尾元素
  ![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221218160213.png)
- 情况三：考虑包含尾元素，不包含首元素
  ![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221218160259.png)

> 注意这里是**考虑**，例如情况三：虽然是考虑包含尾元素，但不一定要选尾元素！对于情况三，取nums[1] 和 nums[3]就是最⼤的
>
> **而情况二和情况三 都包含了情况一了，所以只需要考虑情况二和情况三就可以了**

#### 实现

Java代码

```java
class Solution {
    public int rob(int[] nums) {
        if(nums.length == 1) return nums[0];

        // 考虑首元素，不考虑尾元素
        int[] nums1 = Arrays.copyOfRange(nums,0,nums.length - 1);
        // 考虑尾元素，不考虑首元素
        int[] nums2 = Arrays.copyOfRange(nums,1,nums.length);

        return Math.max(robRange(nums1),robRange(nums2));
    }
    // 198.打家劫舍的逻辑
    public int robRange(int[] nums) {
        if(nums.length == 1) return nums[0];
        int[] dp = new int[nums.length];
        dp[0] = nums[0];
        dp[1] = Math.max(nums[0],nums[1]);
        for(int i = 2; i < nums.length; i++) {
            dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);
        }
        return dp[nums.length - 1];
    }
}
```

```java
class Solution {
    public int rob(int[] nums) {
        if(nums.length == 1) return nums[0];
        // 考虑首元素，不考虑尾元素
        int res1 = robRange(nums, 0, nums.length - 1);
        // 考虑尾元素，不考虑首元素
        int res2 = robRange(nums, 1, nums.length);
        return Math.max(res1, res2);
    }
    public int robRange(int[] nums, int startIndex, int endIndex) {
        if(endIndex - startIndex == 1) return nums[startIndex];
        int[] dp = new int[nums.length];
        dp[startIndex] = nums[startIndex];
        dp[startIndex + 1] = Math.max(nums[startIndex],nums[startIndex + 1]);
        for(int i = startIndex + 2; i < endIndex; i++) {
            dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);
        }
        return dp[endIndex - 1];
    }
}
```



### 337、打家劫舍III

#### 题目

题目链接：**[337. 打家劫舍 III - 力扣（LeetCode）](https://leetcode.cn/problems/house-robber-iii/)**

小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 `root` 。

除了 `root` 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 **两个直接相连的房子在同一天晚上被打劫** ，房屋将自动报警。

给定二叉树的 `root` 。返回 ***在不触动警报的情况下** ，小偷能够盗取的最高金额* 。

**示例 1:**

![img](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/rob1-tree.jpg)

```
输入: root = [3,2,3,null,3,null,1]
输出: 7 
解释: 小偷一晚能够盗取的最高金额 3 + 3 + 1 = 7
```

**示例 2:**

![img](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/rob2-tree.jpg)

```
输入: root = [3,4,5,1,3,null,1]
输出: 9
解释: 小偷一晚能够盗取的最高金额 4 + 5 = 9
```

**提示：**



- 树的节点数在 [1, 10<sup>4</sup>]范围内
- 0 <= Node.val <= 10<sup>4</sup>

 

#### 思路

本题和**[213. 打家劫舍 II - 力扣（LeetCode）](https://leetcode.cn/problems/house-robber-ii/)**、**[198. 打家劫舍 - 力扣（LeetCode）](https://leetcode.cn/problems/house-robber/)**如出一辙，只不过本题换成了树（树形dp的入门题目）

对于树的话，首先就要想到遍历方式，前中后序（深度优先搜索）还是层序遍历（广度优先搜索）

**本题一定是要后序遍历，因为通过递归函数的返回值来做下一步的计算**

和之前两题一样，关键是要讨论当前节点偷还是不偷

如果偷了当前节点，两个子节点就不偷，如果没偷当前节点，就可以**考虑**左右节点

递归三部曲 + 动归五部曲：

1. 确定递归函数的参数和返回值
   此处我们要求一个节点偷与不偷的两个状态所得到的金钱，那么返回值就是一个长度为2的数组，参数为当前节点

   ```java
   int[] robTree(TreeNode curNode) {
       // action
   }
   ```

   其实这里的返回数组就是dp数组
   所以dp数组以及下标的含义：`dp[0]`记录不偷该节点所得到的的最大金钱，`dp[1]`记录偷该节点所得到的最大金钱 => 本题dp数组是一个长度为2的数组

   > 长度为2的数组怎么标记树中每个节点的状态？
   >
   > **递归的过程中，系统栈会保存每一层递归的参数**

2. 确定终止条件
   在遍历的过程中，如果遇到空节点，此时偷与不偷都是0，直接返回

   ```java
   if(curNode == null) return new int[]{0, 0};
   ```

   这也相当于dp数组的初始化

3. 确定遍历顺序
   首先明确的是使用后序遍历，因为要通过递归函数的返回值来做下一步计算

   - 通过递归左节点，得到左节点偷与不偷的金钱
   - 通过递归右节点，得到右节点偷与不偷的金钱

   ```java
   // 下标0 => 不偷，下标1 => 偷
   int[] left = robTree(curNode.left); // 左节点
   int[] right = robTree(curNode.right); // 右节点
   // 父结点
   ```

4. 确定单层递归的逻辑

   - 如果是偷当前节点，那么左右节点就不能偷，`val1 = vurNode.val + left[0] + right[0]`
   - 如果不偷当前节点，那么左右节点就可以偸，至于到底偷不偷一定是选一个最大的，`val2 = Math.max(left[0], left[1]) + Math.max(right[0], right[1])`

   最后当前节点的状态就是`{val2,val1}`，即{不偷当前节点得到的最大金钱， 偷当前节点得到的最大金钱}

   ```java
   // 下标0 => 不偷，下标1 => 偷
   int[] left = robTree(curNode.left); // 左节点
   int[] right = robTree(curNode.right); // 右节点
   // 偷当前节点
   int val1 = curNode.val + left[0] + right[0];
   // 不偷当前节点
   int val2 = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);
   return new int[] {val2, val1};
   ```

5. 举例推导dp数组
   以示例1为例
   ![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221218164144.png)
   最后头节点就是取下标0 和 下标1的最大值就是偷得的最大金钱

#### 实现

Java代码

```java
// 时间复杂度：O(n) 每个节点只遍历了⼀次
// 空间复杂度：O(logn) 算上递推系统栈的空间
class Solution {
    public int rob(TreeNode root) {
        // res[0]: 不偷当前节点得到的最大金钱
        // res[1]: 偷当前节点得到的最大金钱
        int[] res = robTree(root);
        return Math.max(res[0], res[1]);
    }

    private int[] robTree(TreeNode curNode) {
        if(curNode == null) return new int[]{0, 0};

        // 递归左节点
        int[] left = robTree(curNode.left); 
        // 递归右节点
        int[] right = robTree(curNode.right);

// 空间复杂度：O(logn) 算上递推系统栈的空间
        // 偷当前节点
        int val1 = curNode.val + left[0] + right[0];
        // 不偷当前节点
        int val2 = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);
        return new int[]{val2, val1};
    }
}

```

---



### 121、买卖股票的最佳时机

#### 题目

题目链接：**[121. 买卖股票的最佳时机 - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)**

给定一个数组 `prices` ，它的第 `i` 个元素 `prices[i]` 表示一支给定股票第 `i` 天的价格。

你只能选择 **某一天** 买入这只股票，并选择在 **未来的某一个不同的日子** 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 `0` 。



**示例 1：**

```
输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 =5。
	注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
```

**示例 2：**

```
输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 没有交易完成, 所以最大利润为 0。
```

**提示：**

- 1 <= prices.length <= 10<sup>5</sup>
- 0 <= prices[i] <= 10<sup>4</sup>



#### 思路

动归五部曲

1. 确定dp数组以及下标的含义
   `dp[i][0]`：表示第 i 天持有股票所得的最多现金

   > 一开始现金是0，加入第 i 天买入股票现金就是 -price[i]

   `dp[i][1]`：表示第 i 天不持有股票所得最多现金

   > **持有**不代表当天“买入”，也有可能是昨天就买入了，保持持有的状态

2. 确定递推公式
   如果第 i 天持有股票，即`dp[i][0]`，那么可以由两个状态推出：

   - 第 i - 1 天就持有股票，保持现状，所得现金就是昨天持有股票的所得现金，即`dp[i - 1][0]`
   - 第 i 天买入股票，所得现金就是买入今天的股票后所得现金，即`-prices[i]`

   => `dp[i][0] = Math.max(dp[i - 1][0], -prices[i])`

   如果第 i 天不持有股票，即`dp[i][1]`，那么可以由两个状态推出：

   - 第 i - 1 天就不持有股票，保持现状，所得现金就是昨天不持有股票的所得现金，即`dp[i - 1][1]`
   - 第 i 天卖出股票，所得现金就是按照今天股票的价格卖出后所得现金，即`prices[i] + dp[i - 1][0]`

   => `dp[i][1] = Math.max(dp[i - 1][1], prices[i] + dp[i - 1][0])`

3. dp数组初始化
   由递推公式` dp[i][0] = max(dp[i - 1][0], -prices[i]);` 和` dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]);`可以看出其基础都是要从`dp[0][0]`和`dp[0][1]`推导出来
   那么`dp[0][0]`表⽰第0天持有股票，此时的持有股票就⼀定是买⼊股票了，因为不可能有前⼀ 天推出来，所以`dp[0][0] -= prices[0];` `dp[0][1]`表⽰第0天不持有股票，不持有股票那么现⾦就是0，所以`dp[0][1] = 0`

   ```java
   int[][] dp = new int[prices.length][2];
   dp[0][0] = - prices[0];
   dp[0][1] = 0;
   ```

4. 确定遍历顺序
   从递推公式可以看出`dp[i]`都是有`dp[i - 1]`推导出来的，那么⼀定是从前向后遍历

5. 举例推导dp数组
   以示例1输入[7,1,5,3,6,4]为例
   ![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221219095905.png)
   **本题不持有股票状态所得金钱一定比持有股票状态得到的多**

#### 实现

Java代码

```java
// 时间复杂度：O(n)
// 空间复杂度：O(n)
class Solution {
    public int maxProfit(int[] prices) {
        int[][] dp = new int[prices.length][2];
        // dp[i][0]：表示持有股票
        // dp[i][1]：表示不持有股票
        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        for(int i = 1; i < prices.length; i++) {
            dp[i][0] = Math.max(dp[i - 1][0], -prices[i]);
            dp[i][1] = Math.max(dp[i - 1][1], prices[i] + dp[i - 1][0]);
        }
        return dp[prices.length - 1][1];
    }
}
```

从递推公式可以看出，`dp[i`]只是依赖于`dp[i - 1]`的状态 => 那么我们只需要记录 当前这天的dp状态和前一天的dp状态就可以了，可以使用滚动数组节省空间

```java
// 时间复杂度：O(n)
// 空间复杂度：O(1)
class Solution {
    public int maxProfit(int[] prices) {
        int[][] dp = new int[2][2];
        // dp[i][0]：表示持有股票
        // dp[i][1]：表示不持有股票
        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        for(int i = 1; i < prices.length; i++) {
            dp[i % 2][0] = Math.max(dp[(i - 1) % 2][0], -prices[i]);
            dp[i % 2][1] = Math.max(dp[(i - 1) % 2][1], prices[i] + dp[(i - 1) % 2][0]);
        }
        return dp[(prices.length - 1) % 2][1];
    }
}
```



### 122 买卖股票的最佳时机II

#### 题目

题目链接：**[122. 买卖股票的最佳时机 II - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)**

给你一个整数数组 `prices` ，其中 `prices[i]` 表示某支股票第 `i` 天的价格。

在每一天，你可以决定是否购买和/或出售股票。你在任何时候 **最多** 只能持有 **一股** 股票。你也可以先购买，然后在 **同一天** 出售。

返回 *你能获得的 **最大** 利润* 。

**示例 1：**

```
输入：prices = [7,1,5,3,6,4]
输出：7
解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。
     总利润为 4 + 3 = 7 
```

**示例 2：**

```
输入：prices = [1,2,3,4,5]
输出：4
解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
     总利润为 4 。
```

**示例 3：**

```
输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。
```

**提示：**

- 1 <= prices.length <= 3 * 10<sup>4</sup>
- 0 <= prices[i] <= 10<sup>4</sup>

#### 思路

本题的动规五部曲分析和**[121. 买卖股票的最佳时机 - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)**的唯一区别体现在递推公式上

**递推公式**

回顾下dp数组的含义

- `dp[i][1]`：表示第 i 天不持有股票所得最多现金
- `dp[i][0]`：表示第 i 天持有股票所得的最多现金

如果第 i 天持有股票即`dp[i][0]`，那么可以由两个状态推出：

- 第 i - 1 天就持有股票，保持现状，所得现金就是昨天持有股票的所得现金，即`dp[i - 1][0]`
- 第 i 天买入股票，所得现金就是昨天不持有股票所得的现金减去今天的股票价格，即`dp[i - 1][1]-prices[i]`

=> `dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] - prices[i]);`

> 注意这里和**[121. 买卖股票的最佳时机 - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)**唯一不同的地方，就是推导`dp[i][0]`的时候，第天买入股票的情况。
> 在**[121. 买卖股票的最佳时机 - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)**中，因为股票全程只能买卖一次，所以如果买入股票，那么第 i 天持有股票即`dp[i][O]`一定就是`-prices[i]`。
> 而本题，因为一只股票可以买卖多次，所以当第 i 天买入股票的时候，所持有的现金可能有之前买卖过的利润。
>
> =>  第 i 天持有股票即`dp[i][0]`，如果是第i天买⼊股票，所得现⾦就是昨天不持有股票的所得现⾦减去今天的股票价格 即：`dp[i - 1][1] - prices[i]`

如果第 i 天不持有股票即`dp[i][1]`的情况，可以由两个状态推出：

- 第 i - 1 天就不持有股票，保持现状，所得现金就是昨天不持有股票的所得现金，即`dp[i - 1][1]`
- 第 i 天卖出股票，所得现金就是按照今天股票的价格卖出后所得现金，即`prices[i] + dp[i - 1][0]`

=> `dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i]);`

#### 实现

Java代码

```java
// 时间复杂度：O(n)
// 空间复杂度：O(n)
class Solution {
    public int maxProfit(int[] prices) {
        int[][] dp = new int[prices.length][2];
        // dp[i][0]：表示持有股票
        // dp[i][1]：表示不持有股票
        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        for(int i = 1; i < prices.length; i++) {
            // 这里是唯一与121、买卖股票的最佳时机不同的地方
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] - prices[i]);
            dp[i][1] = Math.max(dp[i - 1][1], prices[i] + dp[i - 1][0]);
        }
        return dp[prices.length - 1][1];
    }
}
```

滚动数组实现

```java
// 时间复杂度：O(n)
// 空间复杂度：O(1)
class Solution {
    public int maxProfit(int[] prices) {
        int[][] dp = new int[2][2];
        // dp[i][0]：表示持有股票
        // dp[i][1]：表示不持有股票
        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        for(int i = 1; i < prices.length; i++) {
            dp[i % 2][0] = Math.max(dp[(i - 1) % 2][0], dp[(i - 1) % 2][1] - prices[i]);
            dp[i % 2][1] = Math.max(dp[(i - 1) % 2][1], prices[i] + dp[(i - 1) % 2][0]);
        }
        return dp[(prices.length - 1) % 2][1];
    }
}
```



### 123、买卖股票的最佳时机III

#### 题目

题目链接：**[123. 买卖股票的最佳时机 III - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/)**

给定一个数组，它的第 `i` 个元素是一支给定的股票在第 `i` 天的价格

设计一个算法来计算你所能获取的最大利润。你最多可以完成 **两笔** 交易。

**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**示例 1:**

```
输入：prices = [3,3,5,0,0,3,1,4]
输出：6
解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。
```

**示例 2：**

```
输入：prices = [1,2,3,4,5]
输出：4
解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
```

**示例 3：**

```
输入：prices = [7,6,4,3,1] 
输出：0 
解释：在这个情况下, 没有交易完成, 所以最大利润为 0。
```

**示例 4：**

```
输入：prices = [1]
输出：0
```

**提示：**

- 1 <= prices.length <= 10<sup>5</sup>
- 0 <= prices[i] <= 10<sup>5</sup>

#### 思路

> 本题关键：**至多买卖两次**，这意味着可以买卖一次，可以买卖两次，也可以不买卖

动归五部曲：

1. 确定dp数组以及下标的含义
   一天一共就有五个状态

   - 0 => 没有操作
   - 1 => 第一次买入
   - 2 => 第一次卖出
   - 3 => 第二次买入
   - 4 => 第二次卖出

   `dp[i][j]`中的  i 表示第 i 天，j 为 以上五个状态（取值[0 - 4]），`do[i][j]`表示第 i 天状态 j 所剩的最大现金

2.  确定递推公式

   > 注意：`dp[i][1]`，表⽰的是第i天，买⼊股票的**状态**，并不是说⼀定要第i天买⼊股票

   1）达到`dp[i][1]`状态，有两个具体操作

   - 操作一：第 i 天买入股票，那么`dp[i][1] = dp[i - 1][0] - prices[i]`
   - 操作二：第 i 天没有操作，而是保持前一天买入的状态，即`dp[i][1] = dp[i - 1][1]`

   => `dp[i][1] = Math.max(dp[i - 1][0] - prices[i], dp[i - 1][1]);`

   2）同理`dp[i][2]`也有两个操作

   - 操作一：第 i 天卖出股票，那么`dp[i][2] = dp[i - 1][1] + prices[i]`
   - 操作二：第 i 天没有操作，而是保持前一天卖出的状态，即`dp[i][2] = dp[i - 1][2]`

   => `dp[i][2] = Math.max(dp[i - 1][1] + prices[i], dp[i - 1][2]);`

   3）同理推出剩下的状态

   =>  `dp[i][3] = Math.max(dp[i - 1][2] - prices[i], dp[i - 1][3]);`

   =>  `dp[i][4] = Marh.max(dp[i - 1][3] + prices[i], dp[i - 1][4]);`

3. dp数组初始化

   - 第 0 天没有操作，`dp[0][0] = 0`

   - 第 0 天做第一次买入的状态，`dp[0][1] = -prices[0]`

   - 第 0 天做第一次卖出的操作，`dp[0][2] = 0`

     > 卖出操作一定是收获利润，整个股票买卖最差情况也就是没有盈利即全程无操作，现金为0
     >
     > 从递推公式中可以看出每次都是取最大值，那么既然是收获利润，如果比0还小就没有必要了
     >
     > => `dp[0][2] = 0`

   - 第 0 天做第二次买入操作，`dp[0][3] = -prices[0]`

     > 不⽤管第⼏次，现在⼿头上没有现⾦，只要买⼊，现⾦就做相应的减少。

   - 第 0 天做第二次卖出操作，`dp[0][4] = 0`

4. 确定遍历顺序
   从递推公式其实已经可以看出，⼀定是从前向后遍历，因为`dp[i]`，依靠`dp[i - 1]`的数值

5. 举例推导dp数组
   以输入[1,2,3,4,5]为例
   ![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221219104835.png)
   **利润最大的时候一定是卖出的状态，而两次卖出的状态利润最大一定是最后一次卖出的状态**

#### 实现

Java代码：

```java
// 时间复杂度：O(n)
// 空间复杂度：O(n * 5)
class Solution {
    public int maxProfit(int[] prices) {
        int[][] dp = new int[prices.length][5];
        dp[0][1] = -prices[0];
        dp[0][3] = -prices[0];
        for(int i = 1; i < prices.length; i++) {
            dp[i][0] = dp[i - 1][0];
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
            dp[i][2] = Math.max(dp[i - 1][2], dp[i - 1][1] + prices[i]);
            dp[i][3] = Math.max(dp[i - 1][3], dp[i - 1][2] - prices[i]);
            dp[i][4] = Math.max(dp[i - 1][4], dp[i - 1][3] + prices[i]);
        }
        return dp[prices.length - 1][4];
    }
}
```

LeetCode官方题解：

```java
// 时间复杂度：O(n)
// 空间复杂度：O(1)
class Solution {
    public int maxProfit(int[] prices) {
        int n = prices.length;
        int buy1 = -prices[0], sell1 = 0;
        int buy2 = -prices[0], sell2 = 0;
        for (int i = 1; i < n; ++i) {
            buy1 = Math.max(buy1, -prices[i]);
            sell1 = Math.max(sell1, buy1 + prices[i]);
            buy2 = Math.max(buy2, sell1 - prices[i]);
            sell2 = Math.max(sell2, buy2 + prices[i]);
        }
        return sell2;
    }
}
```

> `sell1` 利用的就是当天的 `buy1`
>
> `buy1 = Math.max(buy1, -prices[i]);`，
>
> 如果`buy1`取`buy1`，即保持第一次买入股票的状态，那么`sell1 = Math.max(sell1, buy1 + prices[i]);`中的`buy1 +  prices[i]`就是今天第一次卖出
>
> 如果`buy1`取`0 - prices[i]`，即今天第一次买入股票，那么`sell1 = Math.max(sell1, buy1 + prices[i]);`中的`buy1 +  prices[i]`就相当于是今天再卖出股票，一买一卖收益为0.对所得现金没有影响，相当于今天买入股票又卖出股票，等于没有操作，保持昨天卖出股票的状态



### 188、买卖股票的最佳时机IV

#### 题目

题目链接：**[188. 买卖股票的最佳时机 IV - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/)**

给定一个整数数组 `prices` ，它的第 `i` 个元素 `prices[i]` 是一支给定的股票在第 `i` 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 **k** 笔交易。

**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。



**示例 1：**

```
输入：k = 2, prices = [2,4,1]
输出：2
解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。
```

**示例 2：**

```
输入：k = 2, prices = [3,2,6,5,0,3]
输出：7
解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。
     随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。
```

**提示：**

- `0 <= k <= 100`
- `0 <= prices.length <= 1000`
- `0 <= prices[i] <= 1000`

#### 思路

动归五部曲：

1. 确定dp数组以及下标的含义
   使⽤⼆维数组 `dp[i][j] `：第 i 天的状态为 j，所剩下的最⼤现⾦是`dp[i][j]`
   j 的状态表示：

   - 0表示不操作
   - 1第一次买入
   - 2第一次卖出
   - 3第二次买入
   - 4第二次卖出
   - ……

   > 规律：除了 0 以外，偶数就是卖出，奇数就是买入
   >
   > 题目要求是至多有K笔交易，那么 j 的范围就定义为 2 \* k + 1

   ```java 
   int[][] dp = new int[prices.length][2 * k + 1];
   ```

2. 确定递推公式

   > 注意：`dp[i][1]`，表⽰的是第i天，买⼊股票的**状态**，并不是说⼀定要第i天买⼊股票

   1）达到`dp[i][1]`状态，有两个具体操作

   - 操作一：第 i 天买入股票，那么`dp[i][1] = dp[i - 1][0] - prices[i]`
   - 操作二：第 i 天没有操作，而是保持前一天买入的状态，即`dp[i][1] = dp[i - 1][1]`

   => `dp[i][1] = Math.max(dp[i - 1][0] - prices[i], dp[i - 1][1]);`

   2）同理`dp[i][2]`也有两个操作

   - 操作一：第 i 天卖出股票，那么`dp[i][2] = dp[i - 1][1] + prices[i]`
   - 操作二：第 i 天没有操作，而是保持前一天卖出的状态，即`dp[i][2] = dp[i - 1][2]`

   => `dp[i][2] = Math.max(dp[i - 1][1] + prices[i], dp[i - 1][2]);`

   3）同理类比剩下的状态

   ```java
   for (int j = 0; j < 2 * k - 1; j += 2) {
        dp[i][j + 1] = Math.max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i]);
        dp[i][j + 2] = Math.max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i]);
   }
   ```

   > 本题与**[123. 买卖股票的最佳时机 III - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/)**最大区别就是这里要类比 j 为奇数是买入，偶数是卖出的状态

3. dp数组初始化

   - 第 0 天没有操作，`dp[0][0] = 0`

   - 第 0 天做第一次买入的状态，`dp[0][1] = -prices[0]`

   - 第 0 天做第一次卖出的操作，`dp[0][2] = 0`

     > 卖出操作一定是收获利润，整个股票买卖最差情况也就是没有盈利即全程无操作，现金为0
     >
     > 从递推公式中可以看出每次都是取最大值，那么既然是收获利润，如果比0还小就没有必要了
     >
     > => `dp[0][2] = 0`

   - 第 0 天做第二次买入操作，`dp[0][3] = -prices[0]`

     > 不⽤管第⼏次，现在⼿头上没有现⾦，只要买⼊，现⾦就做相应的减少。

   - 同理推出**`dp[0][j]`当 j 为奇数时都初始化为`-prices[0]`**

     ```java
     for (int j = 1; j < 2 * k; j += 2) {
      	dp[0][j] = -prices[0];
     }
     ```

     **在初始化的地⽅同样要类⽐ j 为偶数是卖出、奇数是买入的状态。**

4. 确定遍历顺序
   从递推公式其实已经可以看出，⼀定是从前向后遍历，因为`dp[i]`，依靠`dp[i - 1]`的数值

5. 举例推导dp数组
   以输入[1,2,3,4,5]，k=2为例
   ![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221219104835.png)
   **最后⼀次卖出，⼀定是利润最⼤的，`dp[prices.length - 1][2 * k]`即红⾊部分就是最后求解**

#### 实现

Java代码

```java
class Solution {
    public int maxProfit(int k, int[] prices) {
        if(prices.length == 0) return 0;
        int[][] dp = new int[prices.length][k * 2 + 1];
        for(int j = 1;j < k * 2; j += 2) {
            dp[0][j] = -prices[0];
        }
        for(int i = 1; i < prices.length; i++) {
            for(int j = 0; j < k * 2 - 1; j += 2) {
                dp[i][j + 1] = Math.max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i]);
                dp[i][j + 2] = Math.max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i]);
            }
        }
        return dp[prices.length - 1][k * 2];
    }
}
```



### 309、最佳买卖股票时机含冷冻期

#### 题目

题目链接：**[309. 最佳买卖股票时机含冷冻期 - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/)**

给定一个整数数组`prices`，其中第 `prices[i]` 表示第 `i` 天的股票价格 。

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

- 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**示例 1:**

```
输入: prices = [1,2,3,0,2]
输出: 3 
解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]
```

**示例 2:**

```
输入: prices = [1]
输出: 0
```

**提示：**

- `1 <= prices.length <= 5000`
- `0 <= prices[i] <= 1000`

#### 思路

> 本题相当于在**[122. 买卖股票的最佳时机 II - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)**的基础杀昂加了一个冷冻期
>
> 在**[122. 买卖股票的最佳时机 II - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)**中有两个状态：
>
> - 持有股票后得到的最多现金
> - 不持有股票后得到的最多现金

动归五部曲：

1. 确定dp数组以及下标的含义
   `dp[i][j]`：表示第 i 天 状态为 j，所得的最多现金为`dp[i][j]`
   具体可以区分出如下四个状态（`j`的取值）

   - 状态一(`0`)：买入股票状态（今天买入股票，或者是之前就买入了股票然后没有操作）
   - 卖出股票状态
     - 状态二(`1`)：两天前就卖出了股票，度过了冷冻期，一直没操作，今天保持卖出股票状态
     - 状态三(`2`)：今天卖出了股票
   - 状态四(`3`)：今天为冷冻期状态，但冷冻期状态不可持续，只有一天

2. 确定递推公式
   1）达到买入股票的状态（状态一）即：`dp[i][0]`，有两个具体操作：

   - 操作一：前一天就是持有股票状态（状态一）`dp[i][0] = dp[i - 1][0]`

   - 操作二：今天买入股票，有两种情况

     - 前一天是冷冻期（状态四），`dp[i - 1][3] - prices[i]`
     - 前一天是保持卖出股票状态（状态二），`dp[i - 1][1] - prices[i]`

     => 操作二取最大值，`Math.max(dp[i - 1][3], dp[i - 1][1]) - prices[i]`

   => `dp[i][0] = Math.max(dp[i - 1][0],Math.max(dp[i - 1][3], dp[i - 1][1])  - prices[i])`

   2）达到保持卖出股票状态（状态二）即`dp[i][1]`，有两个具体操作：

   - 操作一：前一天就是状态二
   - 操作二：前一天是冷冻期（状态四）

   => `dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][3])`

   3）达到今天就卖出股票状态（状态三），即`dp[i][2]`，只有一个操作

   - 操作一：昨天一定是买入股票状态（状态一），今天卖出

   => `dp[i][2] = dp[i - 1][0] + prices[i]`

   4）达到今天为冷冻期状态（状态四），即`dp[i][3]`，只有一个操作

   - 操作一：昨天就卖出了股票（状态三）

   => `dp[i][3] = dp[i - 1][2]`

   ```java
   // 递推代码
   dp[i][0] = Math.max(dp[i - 1][0],Math.max(dp[i - 1][3], dp[i - 1][1])  - prices[i]);
   dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][3]);
   dp[i][2] = dp[i - 1][0] + prices[i];
   dp[i][3] = dp[i - 1][2];
   ```

3. dp数组初始化
   主要讨论第 0 天的初始化情况

   - 如果是持有股票状态（状态一），`dp[i][0] = -prices[0]`
   - 如果是卖出股票状态（状态二），第 0 天没有卖出，`dp[0][1] = 0`
   - 如果是今天卖出股票状态（状态三），`dp[0][2] = 0`，最少收益为0，绝对不会是负数
   - 如果是冷冻期状态，说明前一天是卖出股票状态，前一天收益为0，`dp[0][3] = 0`

4. 确定遍历顺序
   从递推公式其实已经可以看出，⼀定是从前向后遍历，因为`dp[i]`，依靠`dp[i - 1]`的数值

5. 举例推导dp数组
   以[1,2,3,0,2]为例
   ![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221219144628.png)

   > 最后结果是取**状态⼆**，**状态三**，和**状态四**的最⼤值
   >
   > 状态四是 冷冻期，最后⼀天如果是冷冻期也可能是最⼤值

#### 实现

Java代码：

```java
// 时间复杂度：O(n)
// 空间复杂度：O(n)
class Solution {
    public int maxProfit(int[] prices) {
        int pLen = prices.length;
        int[][] dp = new int[pLen][4];
        dp[0][0] = -prices[0];
        for(int i = 1; i < pLen; i++) {
            dp[i][0] = Math.max(dp[i - 1][0], Math.max(dp[i - 1][3], dp[i - 1][1]) - prices[i]);
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][3]);
            dp[i][2] = dp[i - 1][0] + prices[i];
            dp[i][3] = dp[i - 1][2];
        }
        return Math.max(dp[pLen - 1][1], Math.max(dp[pLen - 1][2], dp[pLen - 1][3]));
    }
}
```



### 714、最佳买卖股票时机含手续费

#### 题目

题目链接：**[714. 买卖股票的最佳时机含手续费 - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)**

给定一个整数数组 `prices`，其中 `prices[i]`表示第 `i` 天的股票价格 ；整数 `fee` 代表了交易股票的手续费用。

你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。

返回获得利润的最大值。

**注意：**这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。

**示例 1：**

```
输入：prices = [1, 3, 2, 8, 4, 9], fee = 2
输出：8
解释：能够达到的最大利润:
在此处买入 prices[0] = 1
在此处卖出 prices[3] = 8
在此处买入 prices[4] = 4
在此处卖出 prices[5] = 9
总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8
```

**示例 2：**

```
输入：prices = [1,3,7,5,10,3], fee = 3
输出：6
```

**提示：**

- 1 <= prices.length <= 5 * 10<sup>4</sup>
- 1 <= prices[i] < 5 * 10<sup>4</sup>
- 0 <= fee < 5 * 10<sup>4</sup>

#### 思路

> 本题相较于**[122. 买卖股票的最佳时机 II - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)**只需要在计算卖出的操作时减去手续费就可以了
>
> 唯一的差别在于递推公式部分，下面着重分析递推公式部分

回顾下dp数组的含义：

- `dp[i][1]`：表示第 i 天不持有股票所得最多现金
- `dp[i][0]`：表示第 i 天持有股票所得的最多现金

如果第 i 天持有股票即`dp[i][0]`，那么可以由两个状态推出：

- 第 i - 1 天就持有股票，保持现状，所得现金就是昨天持有股票的所得现金，即`dp[i - 1][0]`
- 第 i 天买入股票，所得现金就是昨天不持有股票所得的现金减去今天的股票价格，即`dp[i - 1][1]-prices[i]`

=> `dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] - prices[i]);`

如果第 i 天不持有股票即`dp[i][1]`的情况，可以由两个状态推出：

- 第 i - 1 天就不持有股票，保持现状，所得现金就是昨天不持有股票的所得现金，即`dp[i - 1][1]`
- 第 i 天卖出股票，所得现金就是按照今天股票的价格卖出后所得现金，**注意这里需要减去手续费**，即`prices[i] + dp[i - 1][0] - fee`

=> `dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i] - fee);`

#### 实现

Java代码

```java
// 时间复杂度：O(n)
// 空间复杂度：O(n)
class Solution {
    public int maxProfit(int[] prices, int fee) {
        int[][] dp = new int[prices.length][2];
        // `dp[i][1]`：表示第 i 天不持有股票所得最多现金
        // `dp[i][0]`：表示第 i 天持有股票所得的最多现金
        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        for(int i = 1; i < prices.length; i++) {
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] - prices[i]);
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i] - fee);
        }
        return dp[prices.length - 1][1];
    }
}
```

滚动数组实现

```java
class Solution {
    public int maxProfit(int[] prices, int fee) {
        int[] dp = new int[2];
        // `dp[i][1]`：表示第 i 天不持有股票所得最多现金
        // `dp[i][0]`：表示第 i 天持有股票所得的最多现金
        dp[0] = -prices[0];
        dp[1] = 0;
        for(int i = 1; i < prices.length; i++) {
            dp[0] = Math.max(dp[0], dp[1] - prices[i]);
            dp[1] = Math.max(dp[1], dp[0] + prices[i] - fee);
        }
        return dp[1];
    }
}
```

---

### 300、最长递增子序列

#### 题目

题目链接：**[300. 最长递增子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-increasing-subsequence/)**

给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。

**子序列** 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。

**示例 1：**

```
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
```

**示例 2：**

```
输入：nums = [0,1,0,3,2,3]
输出：4
```

**示例 3：**

```
输入：nums = [7,7,7,7,7,7,7]
输出：1
```

**提示：**

- 1 <= nums.length <= 2500
- -10<sup>4</sup> <= nums[i] <= 10<sup>4</sup>

#### 思路

动归五部曲：

1. dp数组以及下标的含义
   `dp[i]`表示 i 之前包括 i 的最长上升序列

2. 确定递推公式（状态转移方程）
   位置 i 的最长升序⼦序列等于 j 从 0 到 i - 1 各个位置的最长升序⼦序列 + 1 的最⼤值
   => `dp[i] = Math.max(dp[i], dp[j] + 1)`

3. dp数组的初始化
   对于每一个 i ，对应的`dp[i]`（即最长上升子序列）起始大小至少都是1

4. 确定遍历顺序
   `dp[i]`是由 0 到 i - 1 各个位置的最长升序⼦序列推导⽽来 => i 一定是从前往后遍历
    j 其实就是从 0 到 i - 1，遍历 i 的循环在外循环，遍历 j 的循环在内循环

   ```java
   for (int i = 1; i < nums.length; i++) {
        for (int j = 0; j < i; j++) {
        	if (nums[i] > nums[j]) dp[i] = Math.max(dp[i], dp[j] + 1);
        }
        if (dp[i] > result) result = dp[i]; // 取⻓的⼦序列
   }
   ```

5. 举例推导dp数组
   输入[0,1,0,3,2]为例
   ![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221219234510.png)

#### 实现

Java代码

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        if(nums.length == 1) return 1;
        int[] dp = new int[nums.length];
        Arrays.fill(dp,1);
        int res = 0;
        for(int i = 1; i < nums.length; i++) {
            for(int j = 0; j < i; j++) {
                if(nums[i] > nums[j]) dp[i] = Math.max(dp[i], dp[j] + 1);
            }
            if(res < dp[i]) res = dp[i];
        }
        return res;
    }
}
```







### 674、最长连续递增序列

#### 题目

题目链接：**[674. 最长连续递增序列 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-continuous-increasing-subsequence/)**

给定一个未经排序的整数数组，找到最长且 **连续递增的子序列**，并返回该序列的长度。

**连续递增的子序列** 可以由两个下标 `l` 和 `r`（`l < r`）确定，如果对于每个 `l <= i < r`，都有 `nums[i] < nums[i + 1]` ，那么子序列 `[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]` 就是连续递增子序列。

**示例 1：**

```
输入：nums = [1,3,5,4,7]
输出：3
解释：最长连续递增序列是 [1,3,5], 长度为3。
尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。
```

**示例 2：**

```
输入：nums = [2,2,2,2,2]
输出：1
解释：最长连续递增序列是 [2], 长度为1。
```

**提示：**

- 1 <= nums.length <= 10<sup>4</sup>
- -10<sup>9</sup> <= nums[i] <= 10<sup>9</sup>

#### 思路

##### 动态规划

> 本题相较于**[300. 最长递增子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-increasing-subsequence/)**最大区别在于**连续**

动规五部曲：

1. 确定dp数组以及下标的含义
   `dp[i]`：表示以下标 i 为结尾的数组的连续递增子序列的长度为 `dp[i]`

   > 注意这里的定义：一定是以下标 i 为结尾。并没有说以下标 0 为起始位置

2. 确定递推公式
   如果`nums[i + 1] > nums[i]`，那么以 i + 1 为结尾的数组的连续递增的子序列长度一定等于以 i 结尾的数组连续递增子序列的长度＋1
   => `dp[i + 1] = dp[i] + 1`

   > 因为本题要求连续递增⼦序列，所以就必然要⽐较`nums[i + 1]`与`nums[i]`，⽽不⽤去⽐较 `nums[j]`与`nums[i] `（ j 是在 0 到 i 之间遍历）。
   >
   >  既然不⽤ j 了，那么也不⽤两层for循环，本题⼀层for循环就⾏，⽐较`nums[i + 1]` 和 `nums[i]`。

3. dp数组初始化
   以下标 i 为结尾的数组的连续递增子序列长度最少也应该是1，即就是`nums[i]`这一个元素

   ```java
   int[] dp = new int[nums.length];
   Arrays.fill(dp, 1);
   ```

4. 确定遍历顺序
   从递推公式上可以看出， `dp[i + 1]`依赖`dp[i]`，所以⼀定是从前向后遍历。

   ```java
   for (int i = 0; i < nums.length - 1; i++) {
        if (nums[i + 1] > nums[i]) { // 连续记录
        	dp[i + 1] = dp[i] + 1; // 递推公式
        }
   }
   ```

5. 举例推导dp数组
   以输入nums = [1,3,5,4,7]为例
   ![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221220093659.png)
   `dp[i]`要取最大值

##### 贪心

遇到nums[i + 1] > nums[i]的情况，count就++，否则 count为1，记录count的最⼤值就可以了

#### 实现

##### 动态规划

Java代码

```java
// 时间复杂度：O(n)
// 空间复杂度：O(n)
class Solution {
    public int findLengthOfLCIS(int[] nums) {
        if(nums.length == 1) return 1;
        int[] dp = new int[nums.length];
        Arrays.fill(dp, 1);
        int res = 0;
        for(int i = 0; i < nums.length - 1; i++) {
            if(nums[i + 1] > nums[i]) {
                dp[i + 1] = dp[i] + 1;
            }
            if(res < dp[i + 1]) res = dp[i + 1];
        }
        return res;
    }
}
```

##### 贪心

Java代码

```java
// 时间复杂度：O(n)
// 空间复杂度：O(1)
class Solution {
    public int findLengthOfLCIS(int[] nums) {
        if(nums.length == 1) return 1;
        int res = 0;
        int count = 1;
        for(int i = 0; i < nums.length - 1; i++) {
            if(nums[i + 1] > nums[i]) {
                count++;
            } else count = 1;
            if(res < count) res = count;
        }
        return res;
    }
}
```

### 718、最长重复子数组

#### 题目

题目链接：**[718. 最长重复子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-length-of-repeated-subarray/)**

给两个整数数组 `nums1` 和 `nums2` ，返回 *两个数组中 **公共的** 、长度最长的子数组的长度* 。

**示例 1：**

```
输入：nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]
输出：3
解释：长度最长的公共子数组是 [3,2,1] 
```

**示例 2：**

```
输入：nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]
输出：5
```

**提示：**

- `1 <= nums1.length, nums2.length <= 1000`
- `0 <= nums1[i], nums2[i] <= 100`

#### 思路

> 题目中说的子数组，其实就是连续子序列，果断动态规划

动规五部曲：

1. 确定dp数组以及下标的含义
   `dp[i][j]`：表示以下标为 i - 1 为结尾的A，和以下标 j - 1 为结尾B，最长重复子数组的长度为`dp[i][j]`

   > `dp[i][j]`的定义也就决定着，我们在遍历`dp[i][j]`的时候 i  和 j 都要**从1开始**
   >
   > 定义`dp[i][j]`为 以下标  i为结尾的A，和以下标 j 为结尾的B，最长重复⼦数组长度，实现起来稍稍麻烦一些

2. 确定递推公式
   根据`dp[i][j]`的定义，`dp[i][j]`的状态只能由`dp[i - 1][j - 1]`推导出来。 即当`A[i - 1]` 和`B[j - 1]`相等的时候，`dp[i][j] = dp[i - 1][j - 1] + 1`; 根据递推公式可以看出，遍历i 和 j 要从1开始

3. dp数组初始化
   根据`dp[i][j]`的定义，`dp[i][0] `和`dp[0][j]`其实都是没有意义的！ 但`dp[i][0] `和`dp[0][j]`要初始值，因为 为了⽅便递归公式`dp[i][j] = dp[i - 1][j - 1] + 1`; 所以`dp[i][0] `和`dp[0][j]`初始化为0。 

   > 举个例⼦A[0]如果和B[0]相同的话，`dp[1][1] = dp[0][0] + 1`，只有`dp[0][0]`初始为0，正好符合递推公式逐步累加起来

4. 确定遍历顺序
   两层for循环，A数组和B数组顺序不用关心。这里采用外层遍历A数组，内层遍历B数组

   ```java
   for (int i = 1; i <= A.length; i++) {
        for (int j = 1; j <= B.length; j++) {
            if (A[i - 1] == B[j - 1]) {
            	dp[i][j] = dp[i - 1][j - 1] + 1;
            }
            if (dp[i][j] > result) result = dp[i][j];
        }
   }
   ```

5. 举例推导dp数组
   以示例一:A = [1,2,3,2,1], B= [3,2,1,4,7]为例
   ![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221220100426.png)
   最大长度为3

#### 实现

Java代码：

```java
// 时间复杂度O(n * m) n 为A长度，m为B长度
// 空间复杂度O(n * m)
class Solution {
    public int findLength(int[] A, int[] B) {
        int[][] dp = new int[A.length + 1][B.length + 1];
        int res = 0;
        for(int i = 1; i <= A.length; i++) {
            for(int j = 1; j <= B.length; j++) {
                if(A[i - 1] == B[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }
                if(dp[i][j] > res) res = dp[i][j];
            }
        }
        return res;
    }
}
```

滚动数组实现

> 由状态图可以看出：`dp[i][j]`都是由`dp[i - 1][j - 1]`推出。那么压缩为⼀维数组，也就是`dp[j]`都是由 `dp[j - 1]`推出，也就是相当于可以把上一层`dp[i-1][j]`拷贝到下一层`dp[i][j]`继续使用
>
> 此时在遍历内层循环时，就需要从后往前遍历了，这样可以避免重复覆盖（**跟一维滚动数组实现01背包同理**）

Java代码

```java
// 时间复杂度O(n * m) n 为A长度，m为B长度
// 空间复杂度O(m)
class Solution {
    public int findLength(int[] A, int[] B) {
        int[] dp = new int[B.length + 1];
        int res = 0;
        for(int i = 1; i <= A.length; i++) {
            for(int j = B.length; j > 0; j--) {
                if(A[i - 1] == B[j - 1]) {
                    dp[j] = dp[j - 1] + 1;
                } else dp[j] = 0; // 注意此处不相等时要赋值为0的操作
                if(dp[j] > res) res = dp[j];
            }
        }
        return res;
    }
}
```



### 1143、最长公共子序列

#### 题目

题目链接：**[1143. 最长公共子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-common-subsequence/)**

给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长 **公共子序列** 的长度。如果不存在 **公共子序列** ，返回 `0` 。

一个字符串的 **子序列** 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

- 例如，`"ace"` 是 `"abcde"` 的子序列，但 `"aec"` 不是 `"abcde"` 的子序列。

两个字符串的 **公共子序列** 是这两个字符串所共同拥有的子序列。

**示例 1：**

```
输入：text1 = "abcde", text2 = "ace" 
输出：3  
解释：最长公共子序列是 "ace" ，它的长度为 3 。
```

**示例 2：**

```
输入：text1 = "abc", text2 = "abc"
输出：3
解释：最长公共子序列是 "abc" ，它的长度为 3 
```

**示例 3：**

```
输入：text1 = "abc", text2 = "def"
输出：0
解释：两个字符串没有公共子序列，返回 0 。
```

**提示：**

- `1 <= text1.length, text2.length <= 1000`
- `text1` 和 `text2` 仅由小写英文字符组成

#### 思路

> 本题和**[718. 最长重复子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-length-of-repeated-subarray/)**的区别在于本题不要求是连续的了，但要有**相对顺序**

动归五部曲：

1. 确定dp数组以及下标的含义
   `dp[i][j]`：长度为[0, i - 1]的字符串text1与长度为[0, j - 1]的字符串text2的最长公共子序列为`dp[i][j]`

   > 此处不定义为长度为[0, i]的字符串text1主要为了实现方便

2. 确定递推公式
   主要分为两种情况

   - `text1[i - 1]` 与 `text2[j - 1]`相同：找到了一个共同元素 => `dp[i][j] = dp[i - 1][j - 1] + 1`
   - `text1[i - 1]` 与 `text2[j - 1]`不同：去tex1t[0, i - 2]和text2[0, j - 1]的最长公共子序列和tex1t[0, i - 1]和text2[0, j - 2] 的最长子序列的较大值=> `dp[i][j] = Math.max(dp[i][j - 2], dp[i - 1][j])`

   ```java
   if (text1.charAt(i - 1) == text2charAt(j - 1)) {
    	dp[i][j] = dp[i - 1][j - 1] + 1;
   } else {
    	dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
   }
   ```

3. dp数组初始化
   text1[0, i  - 1]和空串的最长公共子序列自然是0 => `dp[i][0] = 0`
   同理 `dp[0][j] = 0`
   其他下标都是随着递推公式逐步覆盖，所以初始化多少都可以，那就统一初始化为0

4. 确定遍历顺序
   从递推公式可以看出，有三个方向可以推出`dp[i][j]`
   ![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221220104624.png)
   => 那么为了在递推的过程中，这三个⽅向都是经过计算的数值，所以要**从前向后，从上到下**来 遍历这个矩阵

5. 举例推导dp数组
   以示例一输入text1 = "abcde", text2 = "ace" 为例
   ![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221220104734.png)

#### 实现

java代码

```java
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        int text1Len = text1.length();
        int text2Len = text2.length();
        int[][] dp = new int[text1Len + 1][text2Len + 1];
        for(int i = 1; i <= text1Len; i++) {
            for(int j = 1; j <= text2Len; j++) {
                if(text1.charAt(i - 1) == text2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[text1Len][text2Len];
    }
}
```



### 1035、不相交的线

#### 题目

题目链接：**[1035. 不相交的线 - 力扣（LeetCode）](https://leetcode.cn/problems/uncrossed-lines/)**

在两条独立的水平线上按给定的顺序写下 `nums1` 和 `nums2` 中的整数。

现在，可以绘制一些连接两个数字 `nums1[i]` 和 `nums2[j]` 的直线，这些直线需要同时满足满足：

-  `nums1[i] == nums2[j]`
- 且绘制的直线不与任何其他连线（非水平线）相交

请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。

以这种方法绘制线条，并返回可以绘制的最大连线数

**示例 1：**

![img](https://assets.leetcode.com/uploads/2019/04/26/142.png)

```
输入：nums1 = [1,4,2], nums2 = [1,2,4]
输出：2
解释：可以画出两条不交叉的线，如上图所示。 
但无法画出第三条不相交的直线，因为从 nums1[1]=4 到 nums2[2]=4 的直线将与从 nums1[2]=2 到 nums2[1]=2 的直线相交。
```

**示例 2：**

```
输入：nums1 = [2,5,1,2,5], nums2 = [10,5,2,1,5,2]
输出：3
```

**示例 3：**

```
输入：nums1 = [1,3,7,1,7,5], nums2 = [1,9,2,5,1]
输出：2
```

**提示：**

- `1 <= nums1.length, nums2.length <= 500`
- `1 <= nums1[i], nums2[j] <= 2000`

#### 思路

绘制一些连接两个数字`A[i]`和`B[j]`的直线，只要`A[i] == B[j]`，且直线不相交！

直线不能相交，就说明在字符串A中找到一个与字符串B相同的子序列，且这个子序列不能改变相对顺序，只要相对顺序不改变，连接相同数字的直线就不会相交

拿⽰例⼀`A = [1,4,2], B = [1,2,4]`为例，相交情况如图

![img](https://assets.leetcode.com/uploads/2019/04/26/142.png)

其实也就是说A和B的**最长公共⼦序列**是[1,4]，长度为2。 这个公共⼦序列指的是相对顺序 不变（即数字4在字符串A中数字1的后⾯，那么数字4也应该在字符串B数字1的后⾯）

=> 本题说是求绘制的最大连线数，其实就是**求两个字符串的最长公共子序列的长度**

直接复制**[1143. 最长公共子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-common-subsequence/)**的代码即可

#### 实现

Java代码：

```java
class Solution {
    public int maxUncrossedLines(int[] nums1, int[] nums2) {
        int nums1Len = nums1.length;
        int nums2Len = nums2.length;
        int[][] dp = new int[nums1Len + 1][nums2Len + 1];
        for(int i = 1; i <= nums1Len; i++) {
            for(int j = 1; j <= nums2Len; j++) {
                if(nums1[i - 1] == nums2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[nums1Len][nums2Len];
    }
}
```

### 53、最大子序和

#### 题目

题目链接：**[53. 最大子数组和 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-subarray/)**

给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**子数组** 是数组中的一个连续部分。

**示例 1：**

```
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
```

**示例 2：**

```
输入：nums = [1]
输出：1
```

**示例 3：**

```
输入：nums = [5,4,-1,7,8]
输出：23
```

**提示：**

- 1 <= nums.length <= 10<sup>5</sup>
- -104 <= nums[i] <= 10<sup>4</sup>

#### 思路

动归五部曲：

1. 确定dp数值以及下标的含义
   `dp[i]`：表示下标 i 之前的最大连续子序列和为`dp[i]`

2. 确定递推公式
   `dp[i]`可以由两个方向推出

   - `dp[i - 1] + nums[i]`，即：nums[i]加入当前连续子序列和
   - `nums[i]`，即：从头开始计算当前连续子序列和

   取较大的 => `dp[i] = Math.max(dp[i - 1] + nums[i], nums[i])`

3. dp数组初始化
   从递推公式可以看出来`dp[i]`是依赖于`dp[i - 1]`的状态，`dp[0]`就是递推公式的基础
   根据`dp[i]`的定义，很明显`dp[0] = nums[0]`

4. 确定遍历顺序
   递推公式中``dp[i]`依赖于`dp[i - 1]`的状态，需要从前往后遍历

5. 举例推导dp数组
   以示例一为例，输入nums = [-1,1,-3,4,-1,2,1,-5,4]
   ![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221220153334.png)
   遍历过程中需要保存当前遍历过程中最大的连续子序和

#### 实现

Java代码

```java
// 时间复杂度：O(n)
// 空间复杂度：O(n)
class Solution {
    public int maxSubArray(int[] nums) {
        if(nums.length == 1) return nums[0];
        int[] dp = new int[nums.length];
        dp[0] = nums[0];
        int res = nums[0];
        for(int i = 1; i < nums.length; i++) {
            dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]);
            res = Math.max(res, dp[i]);
        }
        return res;
    }
}
```

迭代实现

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int pre = 0;
        int res = nums[0];
        for(int num : nums){
            pre = Math.max(pre + num,num);
            res = Math.max(pre,res);
        }
        return res;
    }
}
```

---



### 392、判断子序列

#### 题目

题目链接：**[392. 判断子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/is-subsequence/)**

给定字符串 **s** 和 **t** ，判断 **s** 是否为 **t** 的子序列。

字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，`"ace"`是`"abcde"`的一个子序列，而`"aec"`不是）。

**示例 1：**

```
输入：s = "abc", t = "ahbgdc"
输出：true
```

**示例 2：**

```
输入：s = "axc", t = "ahbgdc"
输出：false
```

**提示：**

- `0 <= s.length <= 100`
- `0 <= t.length <= 10^4`
- 两个字符串都只由小写字符组成

#### 思路

> （这道题可以⽤双指针的思路来实现，时间复杂度就是O(n)） 
>
> 这道题应该算是编辑距离的⼊门题⽬，因为从题意中可以发现，只需要计算删除的情况，不⽤考虑增加和替换的情况

动归五部曲：

1. 确定dp数组以及下标的含义
   `dp[i][j]`：表示以下标 i - 1 为结尾的字符串s，和以下标 j - 1为结尾的字符串t，相同子序列的长度为`dp[i][j]`

   > 注意这⾥是判断s是否为t的⼦序列。即t的长度是⼤于等于s的
   >
   > 以下标i-1为结尾的字符串来计算，这样在下⾯的递归公式中会容易理解⼀些

2. 确定递推公式
   在确定递推公式的时候，首先要考虑如下两种操作：

   - `if(s[i - 1] == t[j - 1])` =>  t 中找到了一个字符在 s 中也出现了 => `dp[i][j] = dp[i - 1][j - 1] + 1`，因为找到了一个相同的字符，相同子序列长度自然要在`dp[i - 1][j - 1]`的基础上加1
   - `if(s[i - 1] != t[j - 1])` => 相当于 t 要删除元素，继续匹配，t如果把当前元素 t[j - 1] 删除，那么`dp[i][j]`的数值就是看`s[i - 1]`与`t[j - 2]`的比较结果了 =>  `dp[i][j] = dp[i][j - 1]`

3. dp数组初始化
   从递推公式可以看出`dp[i][j]`都是依赖于`dp[i - 1][j - 1] `和 `dp[i][j - 1]`，所以`dp[0][0]`和`dp[i][0] `是⼀定要初始化的

   > 在定义`dp[i][j]`含义的时候为什么要表⽰以下标i-1为结尾的字符串 s，和以下标j-1为结尾的字符串t，相同⼦序列的长度为`dp[i][j]`
   >
   > 因为这样的定义在dp二维矩阵中可以留出初始化的空间：
   > ![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221220155303.png)
   > 如果要是定义的`dp[i][j]`是以下标i为结尾的字符串s和以下标j为结尾的字符串t，初始化就⽐较⿇烦了

   这⾥`dp[i][0]`和`dp[0][j]`是没有含义的，仅仅是为了给递推公式做前期铺垫，所以初始化为0

4. 确定遍历顺序
   同理从从递推公式可以看出dp[i][j]都是依赖`于dp[i - 1][j - 1] `和 `dp[i][j - 1]`，那么遍历顺序也 应该是**从上到下，从左到右**
   ![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221220155442.png)

5. 举例推导dp数组
   以示例一为例，输入：s = "abc"，t="ahbgdc"
   ![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221220155543.png)
   `dp[i][j]`表⽰以下标i-1为结尾的字符串s和以下标j-1为结尾的字符串t 相同⼦序列的长度，所 以如果`dp[s.length()][t.length()] `与 字符串s的长度相同说明：s与t的最长相同⼦序列就是s，那么 s 就是 t 的⼦序列
   图中`dp[s.length()][t.length()] == 3; s.length() =3` => s是t的子序列，返回true

#### 实现

Java代码

```java
// 时间复杂度：O(n * m)
/空间复杂度：O(n * m)
class Solution {
    public boolean isSubsequence(String s, String t) {
        int sLen = s.length();
        int tLen = t.length();
        int[][] dp = new int[sLen + 1][tLen + 1];
        for(int i = 1; i <= sLen; i++) {
            for(int j = 1; j <= tLen; j++) {
                if(s.charAt(i - 1) == t.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = dp[i][j - 1];
                }
            }
        }
        return dp[sLen][tLen] == sLen;
    }
}
```



### 115、不同的子序列

#### 题目

题目链接：**[115. 不同的子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/distinct-subsequences/)**

给定一个字符串 `s` 和一个字符串 `t` ，计算在 `s` 的子序列中 `t` 出现的个数。

字符串的一个 **子序列** 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，`"ACE"` 是 `"ABCDE"` 的一个子序列，而 `"AEC"` 不是）

题目数据保证答案符合 32 位带符号整数范围。

**示例 1：**

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221220184641.png)

**示例 2：**

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221220184659.png)

**提示：**

- `0 <= s.length, t.length <= 1000`
- `s` 和 `t` 由英文字母组成

#### 思路

> 1）本题如果不是子序列，而是求连续序列的，可以考虑KMP算法
>
> 2）本题相较于**[72. 编辑距离 - 力扣（LeetCode）](https://leetcode.cn/problems/edit-distance/)**简单不少，因为本题相当于只涉及删除操作，不用考虑替换、增加之类的
>
> 3）本题相较于**[392. 判断子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/is-subsequence/)**，本题无法使用双指针AC

动归五部曲：

1. 确定dp数组以及下标的含义
   `dp[i][j]`：表示以 i - 1 结尾的s子序列中出现以 j - 1 为结尾的 t 的个数为`dp[i][j]`

2. 确定递推公式

   > 这一类问题，基本是要分析两种情况
   >
   > - `s[t - 1] == t[j - 1]`
   > - `s[t - 1] != t[j - 1]`

    1）当`s[t - 1] == t[j - 1]`时，`dp[i][j]`可以由两部分组成

   - 一部分使用`s[i - 1]`来匹配，此时个数为`dp[i - 1][j - 1]`
   - 一部分不使用`s[i - 1]`来匹配，此时个数为`dp[i - 1][j]`

   > 此处为什么还要考虑不使用`s[i - 1]`来匹配，按理说字符都想通了，指定要匹配
   >
   > 举个例子： s：bagg 和 t：bag ，s[3] 和 t[2]是相同的，但是字符串s也可以不⽤s[3]来匹配，即 ⽤s[0]s[1]s[2]组成的bag。 当然也可以⽤s[3]来匹配，即：s[0]s[1]s[3]组成的bag。

   => `dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]`

   2）当`s[t - 1] != t[j - 1]`时，`dp[i][j]`只由一部份组成，不适用`s[i - 1]`匹配，即`dp[i - 1][j]`

   => `dp[i][j] = dp[i - 1][j]`

3. dp数组初始化
   从递推公式： `dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]`和`dp[i][j] = dp[i - 1][j]`可以看出`dp[i][0]`和`dp[0][j]`是一定要初始化的

   > 每当初始化时，都需要回顾下`dp[i][j]`的定义
   >
   > - `dp[i][0]`表示以 i - 1 为结尾的 s 子序列可以随便删除元素后出现空字符串的个数 => `dp[i][0] = 1`
   > - `dp[0][j]`表示空字符串s可以随便删除元素后出现以 j - 1为结尾的字符串 t 的个数 => `dp[0][j] = 0`
   >
   > 最后看一个特殊位置，`dp[0][0]`
   >
   > - `dp[0][0] = 1`，因为空字符串 s 可以删除0个元素后出现空字符串t

   ```java
   // 初始化代码
   int[][] dp = new int[s.length() + 1][t.length() + 1];
   for (int i = 0; i <= s.length(); i++) dp[i][0] = 1;
   // 这行代码可以不写，因为dp数组创建的时候就默认赋值全0了，这里只是为了凸显初始化的逻辑，下面代码实现的时候不会再出现
   for (int j = 1; j <= t.length(); j++) dp[0][j] = 0; 
   ```

4. 确定遍历顺序
   从递推公式`dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]`; 和 `dp[i][j] = dp[i - 1][j]`; 中可以看出`dp[i][j]`都是根据左上⽅和正上⽅推出来的
   => 遍历顺序：从上到下，从左到右

   ```java
   for(int i = 1; i <= sLen; i++) {
       for(int j = 1; j <= tLen; j++) {
           if(s.charAt(i - 1) == t.charAt(j - 1)) {
               dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
           } else {
               dp[i][j] = dp[i - 1][j];
           }
       }
   }
   ```

5. 举例推导dp数组
   以 s: "baegg"，t: "bag"为例
   ![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221221075459.png)

#### 实现

Java代码：

```java
class Solution {
    public int numDistinct(String s, String t) {
        int sLen = s.length();
        int tLen = t.length();
        int[][] dp = new int[sLen + 1][tLen + 1];
        for(int i = 0; i <= sLen; i++) {
            dp[i][0] = 1;
        }
        for(int i = 1; i <= sLen; i++) {
            for(int j = 1; j <= tLen; j++) {
                if(s.charAt(i - 1) == t.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
                } else {
                    dp[i][j] = dp[i - 1][j];
                }
            }
        }
        return dp[sLen][tLen];
    }
}
```



### 583、两个字符串的删除操作

#### 题目

题目链接：**[583. 两个字符串的删除操作 - 力扣（LeetCode）](https://leetcode.cn/problems/delete-operation-for-two-strings/)**

给定两个单词 `word1` 和 `word2` ，返回使得 `word1` 和 `word2` **相同**所需的**最小步数**。

**每步** 可以删除任意一个字符串中的一个字符。

**示例 1：**

```
输入: word1 = "sea", word2 = "eat"
输出: 2
解释: 第一步将 "sea" 变为 "ea" ，第二步将 "eat "变为 "ea"
```

**示例  2:**

```
输入：word1 = "leetcode", word2 = "etco"
输出：4
```

**提示：**

- `1 <= word1.length, word2.length <= 500`
- `word1` 和 `word2` 只包含小写英文字母

#### 思路

> 本题和**[115. 不同的子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/distinct-subsequences/)**相比，其实就是两个字符串都可以删除了，情况复杂点，但是整体思路不变

动规五部曲：

1. 确定dp数组以及下标的含义
   `dp[i][j]`：以 i - 1 为结尾的字符串 word1，和以 j - 1为结尾的字符串 word2，想要达到相等，所需要删除元素的最少次数

2. 确定递推公式

   > 分析两种情况
   >
   > - `word1[t - 1] == word2[j - 1]`
   > - `word1[t - 1] != word2[j - 1]`

   1）当`word1[t - 1] == word2[j - 1]`时，`dp[i][j] = dp[i - 1][j - 1]`

   2）当`word1[t - 1] != word2[j - 1]`时，有三种情况

   - 情况一：删除`word1[i - 1]`，最少操作次数为`dp[i - 1][j] + 1`
   - 情况二：删除`word2[i - 1]`，最少操作次数为`dp[i][j - 1] + 1`
   - 情况三：同时删除`word1[i - 1]`和`word2[i - 1]`，最少操作次数为`dp[i - 1][j - 1] + 2`

   三者取较小值 => `dp[i][j] = Math.max(dp[i - 1][j - 1] + 2, Math.max(dp[i][j - 1] + 1, dp[i - 1][j] + 1));`

3. dp数组初始化
   从递推公式可以看出，`dp[i][0] `和` dp[0][j]`是⼀定要初始化的
   1）`dp[i][0]`：word2为空字符串，以 i - 1为结尾的字符串word2要删除 i 个元素才能和word1相同 => `dp[i][0] = i`
   2）`dp[0][j] = j`

   ```java
   int[][] dp = new int[word1.length() + 1][word2.length() + 1];
   for (int i = 0; i <= word1.length(); i++) dp[i][0] = i;
   for (int j = 0; j <= word2.length(); j++) dp[0][j] = j;
   ```

4. 确定遍历顺序
   从递推公式 `dp[i][j] = Math.max(dp[i - 1][j - 1] + 2, Math.max(dp[i][j - 1] + 1, dp[i - 1][j] + 1));` 和`dp[i][j] = dp[i - 1][j - 1]`可以看出`dp[i][j]`都是根据左上⽅、正上⽅、正左⽅推出来的。 所以遍历的时候⼀定是**从上到下，从左到右**，这样保证`dp[i][j]`可以根据之前计算出来的数值进⾏计算

5. 举例推导dp数组
   以word1:"sea"，word2:"eat"为例

   ![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221221100639.png)

   

#### 实现

Java代码

```java
class Solution {
    public int minDistance(String word1, String word2) {
        int word1Len = word1.length();
        int word2Len = word2.length();
        int[][] dp = new int[word1Len + 1][word2Len + 1];
        for(int i = 0; i <= word1Len; i++) dp[i][0] = i;
        for(int j = 0; j <= word2Len; j++) dp[0][j] = j;
        for(int i = 1; i <= word1Len; i++) {
            for(int j = 1; j <= word2Len; j++) {
                if(word1.charAt(i - 1) == word2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = Math.min(dp[i - 1][j - 1] + 2, Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1));
                }
            }
        }
        return dp[word1Len][word2Len];
    }
}
```



### 72、编辑距离

#### 题目

题目链接：**[72. 编辑距离 - 力扣（LeetCode）](https://leetcode.cn/problems/edit-distance/)**

给你两个单词 `word1` 和 `word2`， *请返回将 `word1` 转换成 `word2` 所使用的最少操作数* 。

你可以对一个单词进行如下三种操作：

- 插入一个字符
- 删除一个字符
- 替换一个字符

**示例 1：**

```
输入：word1 = "horse", word2 = "ros"
输出：3
解释：
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')
```

**示例 2：**

```
输入：word1 = "intention", word2 = "execution"
输出：5
解释：
intention -> inention (删除 't')
inention -> enention (将 'i' 替换为 'e')
enention -> exention (将 'n' 替换为 'x')
exention -> exection (将 'n' 替换为 'c')
exection -> execution (插入 'u')
```

**提示：**

- `0 <= word1.length, word2.length <= 500`
- `word1` 和 `word2` 由小写英文字母组成

#### 思路

动规五部曲：

1. 确定dp数组以及下标的含义
   `dp[i][j]`表示以下标 i - 1 为结尾的字符串word1，和以下标为 j - 1 为结尾的字符串word2，最近的编辑距离为`dp[i][j]`

2. 确定递推公式

   > 确定递推公式之前，先考虑清楚编辑距离的几种操作：
   >
   > ```java
   > if(word1.charAt(i - 1) == word2.charAt(j - 1)) {
   >     // 不操作
   > } else {
   >     // 对字符串进行 增删换 的操作
   > }
   > ```

   1）当`word1[i - 1] == word2[j - 1]`时，此时不需要任何的编辑，`dp[i][j] = dp[i - 1][j - 1]`

   > 回顾`dp[i][j]`的定义，word1[i - 1] 与 word2[j - 1]相等了，那么就不⽤编辑了，以下标 i - 2为结尾的字符串word1和以下标 j - 2 为结尾的字符串word2的最近编辑距离`dp[i - 1][j - 1]`就是 `dp[i][j]`了

   2）当`word1[i - 1] != word2[j - 1]`时，此时需要对字符串进行编辑

   - 操作一：word1删除一个元素，那么就是以下标为 i  - 2 为结尾的字符串word1 与 以下标为 j - 1 为结尾的字符串word2的最近编辑距离 再 加上一个操作 => `dp[i][j] = dp[i - 1][j] + 1`
   - 操作二：word2删除一个元素，那么就是以下标为 i  - 1 为结尾的字符串word1 与 以下标为 j - 2 为结尾的字符串word2的最近编辑距离 再 加上一个操作 => `dp[i][j] = dp[i][j - 1] + 1`

   > 简单分析下**添加元素的操作**
   >
   > word2添加⼀个元素，相当于word1删除⼀个元素，例如 word1 = "ad" ，word2 = "a"，word1删除元素'd' 和 word2添加⼀个元素'd'，变成word1="a", word2="ad"， 最终的操作数是⼀样！ dp数组如下图所⽰意的：
   >
   > ![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221221102757.png)
   >
   > => **删除元素操作包含了添加元素操作**

   - 操作三：替换元素，字符串word1 替换 字符`word1[i - 1]`使之与`word2[j - 1]`相同，此时不用再增加元素，那么以下标 i - 2为结尾的word1 与 j - 2为结尾的word2的最近编辑距离 再加上⼀个替换元素的操作 => `dp[i][j] = dp[i - 1][j - 1] + 1`

   => `dp[i][j] = Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i][j - 1])) + 1`

   ```java
   if(word1.charAt(i - 1) == word2.charAt(j - 1)) {
       // 不操作
       dp[i][j] = dp[i - 1][j - 1];
   } else {
       // 对字符串进行 增删换 的操作
       dp[i][j] = Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i][j - 1])) + 1;
   }
   ```

3. dp数组初始化

   > 回顾下`dp[i][j]`的定义：
   >
   > `dp[i][j]`表示以下标 i - 1 为结尾的字符串word1，和以下标为 j - 1 为结尾的字符串word2，最近的编辑距离为`dp[i][j]`

   1）`dp[i][0]`：以下标为 i - 1 为结尾的字符串word1和空字符串word2，最近的编辑距离为`dp[i][0]`，那么`dp[i][0] = i`，对word1 里的元素全部做删除操作使之和字符串word2相同

   2）`dp[0][j] = j`

   ```java
   for (int i = 0; i <= word1.length(); i++) dp[i][0] = i;
   for (int j = 0; j <= word2.length(); j++) dp[0][j] = j;
   ```

4. 确定遍历顺序
   从如下四个递推公式：

   - `dp[i][j] = dp[i - 1][j - 1] `
   - `dp[i][j] = dp[i - 1][j - 1] + 1 `
   - `dp[i][j] = dp[i][j - 1] + 1 `
   - ``dp[i][j] = dp[i - 1][j] + 1`

   可以看出`dp[i][j]`是依赖左⽅，上⽅和左上⽅元素的
   ![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221220104624.png)
   => dp矩阵中一定是**从上到下，从左到右**遍历的

   ```java
   for(int i = 1; i <= word1Len; i++) {
               for(int j = 1; j <= word2Len; j++) {
                   if(word1.charAt(i - 1) == word2.charAt(j - 1)) {
                       dp[i][j] = dp[i - 1][j - 1];
                   } else {
                       dp[i][j] = Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i][j - 1])) + 1;
                   }
               }
           }
   ```

5. 举例推导dp数组
   以⽰例1，输⼊：word1 = "horse", word2 = "ros"为例
   ![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221221103915.png)

#### 实现

Java代码

```java
class Solution {
    public int minDistance(String word1, String word2) {
        int word1Len = word1.length();
        int word2Len = word2.length();
        int[][] dp = new int[word1Len + 1][word2Len + 1];
        for(int i = 0; i <= word1Len; i++) dp[i][0] = i;
        for(int j = 0; j <= word2Len; j++) dp[0][j] = j;
        for(int i = 1; i <= word1Len; i++) {
            for(int j = 1; j <= word2Len; j++) {
                if(word1.charAt(i - 1) == word2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i][j - 1])) + 1;
                }
            }
        }
        return dp[word1Len][word2Len];
    }
}
```

### 647、回文子串

#### 题目

题目链接：**[647. 回文子串 - 力扣（LeetCode）](https://leetcode.cn/problems/palindromic-substrings/)**

给你一个字符串 `s` ，请你统计并返回这个字符串中 **回文子串** 的数目。

**回文字符串** 是正着读和倒过来读一样的字符串。

**子字符串** 是字符串中的由连续字符组成的一个序列。

具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。

**示例 1：**

```
输入：s = "abc"
输出：3
解释：三个回文子串: "a", "b", "c"
```

**示例 2：**

```
输入：s = "aaa"
输出：6
解释：6个回文子串: "a", "a", "a", "aa", "aa", "aaa"
```

**提示：**

- `1 <= s.length <= 1000`
- `s` 由小写英文字母组成

#### 思路

##### 动态规划

动规五部曲：

1. 确定dp数组以及下标的含义
   `dp[i][j]`：表示区间范围 [i, j ] （注意这里是左闭右闭）的字串是否是回文子串，如果是，`dp[i][j] = true`，否则为`false`

2. 确定递推公式

   > 分析以下两种情况
   >
   > - `s[i] != s[j]`
   > - `s[i] == s[j]`

   1）`s[i] != s[j]` => `dp[i][j] = false`

   2）`s[i] == s[j]`，此时有以下三种情况

   - 情况一：`i == j`，此时为同一个字符，为回文子串
   - 情况二：i 和 j 相差为1，比如`aa`，也为回文子串
   - 情况三：i 和 j 相差大于1的时候，例如`cabac`，此时`s[i] == s[j]`，判断区间 [i, j] 是否是回文子串就判断 `aba`是否是回文子串就可以了，`aba`所在区间为[i + 1, j - 1]，这个区间是否是回文子串就判断`dp[i + 1][j - 1] ?== true`

   ```java
   // result 统计回文子串的数量
   if (s.charAt(i) == s.charAt(j)) {
        if (j - i <= 1) { // 情况⼀ 和 情况⼆
            result++;
            dp[i][j] = true;
    	} else if (dp[i + 1][j - 1]) { // 情况三
            result++;
            dp[i][j] = true;
        }
   }
   ```

   > 此时没有列出`s[i] != s[j]`的情况，原因是Java初始化boolean数组时默认值为false

3. dp数组初始化
   一开始不可能全部都匹配上，所以`dp[i][j]`初始化为false

4. 确定遍历顺序
   从递推公式中可以看出，情况三是根据`dp[i + 1][j - 1]`是否为true，再对`dp[i][j]`进⾏赋值 true的
   `dp[i + 1][j - 1] `在` dp[i`][j]的左下⾓，如图：
   ![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221221110044.png)
   如果这矩阵是从上到下，从左到右遍历，那么会⽤到没有计算过的`dp[i + 1][j - 1]`，也就是根据不确定是不是回⽂的区间[i+1,j-1]，来判断了[i,j]是不是回⽂，那结果⼀定是不对的。 所以⼀定要**从下到上，从左到右**遍历，这样保证`dp[i + 1][j - 1]`都是经过计算的

   > 有的代码实现是优先遍历列，然后遍历⾏，其实也是⼀个道理，都是为了保证过程中用到的值是经过计算的，保证结果的**可把握性**和**准确性**

   ```java
   for(int i = sLen - 1; i >= 0; i--) { // 注意遍历顺序
       for(int j = i; j < sLen; j++) {
           if(s.charAt(i) == s.charAt(j)) { 
               if(j - i <= 1) { // 情况一和情况二
                   dp[i][j] = true;
                   res++;
               } else if(dp[i + 1][j - 1]) { // 情况三
                   dp[i][j] = true;
                   res++;
               }
           }
       }
   }
   ```

5. 举例推导dp数组
   以输入"aaa"为例
   ![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221221110335.png)
   图中有6个true，也就是6个回文子串

   > 注意：因为`dp[i][j]`的定义，所以 `j >= i`，那么在填充`dp[i][j]`的时候就一定是只填充右上半部分

##### 双指针

> 动态规划的空间复杂度偏高

首先去欸的那个回文串，就是**找中心，然后向两边扩散判断是否对称即可**

**在遍历中⼼点的时候，要注意中⼼点有两种情况**：

- 一个元素可以作为中心点
- 两个元素可以作为中心点

> 因为三个元素可以由一个元素左右添加元素得到，四个元素可以由两个元素左右添加元素得到
>
> => 在计算的时候，注意一个元素为中心点和两个元素为中心点的情况

其实这两种情况可以放在一起运算，但分别计算思路更清晰

#### 实现

##### 动态规划

Java代码

```java
// 时间复杂度：O(n^2)
// 空间复杂度：O(n^2)
class Solution {
    public int countSubstrings(String s) {
        int sLen = s.length();
        boolean[][] dp = new boolean[sLen][sLen];
        int res = 0;
        for(int i = sLen - 1; i >= 0; i--) { // 注意遍历顺序
            for(int j = i; j < sLen; j++) {
                if(s.charAt(i) == s.charAt(j)) { 
                    if(j - i <= 1) { // 情况一和情况二
                        dp[i][j] = true;
                        res++;
                    } else if(dp[i + 1][j - 1]) { // 情况三
                        dp[i][j] = true;
                        res++;
                    }
                }
            }
        }
        return res;
    }
}
```

以上代码是为了凸显情况一二三，其实是可以简洁一点的

```java
// 时间复杂度：O(n^2)
// 空间复杂度：O(n^2)
class Solution {
    public int countSubstrings(String s) {
        int sLen = s.length();
        boolean[][] dp = new boolean[sLen][sLen];
        int res = 0;
        for(int i = sLen - 1; i >= 0; i--) {
            for(int j = i; j < sLen; j++) {
                if(s.charAt(i) == s.charAt(j) && (j - i <= 1 || dp[i + 1][j - 1])) { 
                    dp[i][j] = true;
                    res++;
                }
            }
        }
        return res;
    }
}
```

##### 双指针

```java
// 时间复杂度：O(n^2)
// 空间复杂度：O(1)
class Solution {
    public int countSubstrings(String s) {
        int res = 0;
        int sLen = s.length();
        for(int i = 0; i < sLen; i++) {
            res += extend(s, i, i, sLen); // 一个元素作为中心点
            res += extend(s, i, i + 1, sLen); // 两个元素作为中心点
        }
        return res;
    }
   private int extend(String s, int toLeft, int toRight, int rangeLen) {
       int res = 0;
       while(toLeft >= 0 && toRight < rangeLen && s.charAt(toLeft) == s.charAt(toRight)) {
           toLeft--;
           toRight++;
           res++;
       }
       return res;
   }
}
```



### 516、最长回文子序列

##### 题目

题目链接：**[516. 最长回文子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-palindromic-subsequence/)**

给你一个字符串 `s` ，找出其中最长的回文子序列，并返回该序列的长度。

子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。

**示例 1：**

```
输入：s = "bbbab"
输出：4
解释：一个可能的最长回文子序列为 "bbbb" 。
```

**示例 2：**

```
输入：s = "cbbd"
输出：2
解释：一个可能的最长回文子序列为 "bb" 。
```

**提示：**

- `1 <= s.length <= 1000`
- `s` 仅由小写英文字母组成

#### 思路

> 本题求的是**回文子序列**，而**[647. 回文子串 - 力扣（LeetCode）](https://leetcode.cn/problems/palindromic-substrings/)**求的是**回文子串**，首先要搞清楚二者的区别
>
> - 回文子串是要连续的
>   - **[647. 回文子串 - 力扣（LeetCode）](https://leetcode.cn/problems/palindromic-substrings/)**
>   - **[5. 最长回文子串 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-palindromic-substring/)**
> - 回文子序列不一定要连续
>
> 二者思路差不多，但本题要求的回文子序列比回文子串要简单一点，因为情况少了一点

动规五部曲

1. 确定dp数组以及下标的含义
   `dp[i][j]`：表示字符串s在区间[i, j ]范围内最长回文子序列的长度为`dp[i][j]`

2. 确定递推公式

   > 在判断回文子序列的题目中，关键逻辑就是看`s[i] ?== s[j]`

   1）`s[i] == s[j]` => `dp[i][j] = dp[i + 1][j - 1] + 2`
   ![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221221141520.png)

   2）`s[i] != s[j]`，那么说明`s[i] `和`s[j]`的同时加入并不能增加区间[i, j]回文子序列的长度，那么分别加入`s[i] `、`s[j]`，看哪一个可以组成较长回文子序列

   - 加入`s[j]`的回文子序列长度为`dp[i + 1][j]`
   - 加入`s[i]`的回文子序列长度为`dp[i][j - 1]`

   => `dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);`

   ![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221221142002.png)

   ```java
   if (s.charAt(i) == s.charAt(j)) {
    	dp[i][j] = dp[i + 1][j - 1] + 2;
   } else {
    	dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);
   }
   ```

3. dp数组初始化
   1）首先考虑`i == j`的情况，从递推公式：`dp[i][j] = dp[i + 1][j - 1] + 2;`可以看出递推公式是计算不到`i == j`的情况的 ，手动初始化，此时`dp[i][j] = 1`，即：一个字符的回文子序列长度为1
   2）其他情况`dp[i][j] == 0`即可，这样`dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);`中`dp[i][j]`才不会被初始值覆盖

   ```java
   int[][] dp = new int[s.length()][s.length()];
   for(int i = 0; i < s.length(); i++) dp[i][i] = 1;
   ```

4. 确定遍历顺序
   从递推公式`dp[i][j] = dp[i + 1][j - 1] + 2 `和 `dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]) `可以看出， `dp[i][j]`是依赖于`dp[i + 1][j - 1] `和` dp[i + 1][j]`，从矩阵的角度看，也就是`dp[i][j]`下一行的数据 =>  **所以遍历 i 的时候⼀定要从下到上遍历， 这样才能保证，下⼀⾏的数据是经过计算的。**

   递推公式：`dp[i][j] = dp[i + 1][j - 1] + 2`，`dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1])` 分别对应着下 图中的红⾊箭头⽅向![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221221142902.png)

   ```java
   for(int i = sLen - 1; i >= 0; i--) {
       for(int j = i + 1; j < sLen; j++) {
           if(s.charAt(i) == s.charAt(j)) {
               dp[i][j] = dp[i + 1][j - 1] + 2; 
           } else {
               dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);
           }
       }
   }
   ```

5. 举例推导dp数组
   输⼊s:"cbbd" 为例
   ![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221221143002.png)
   红色框`dp[0][s.length() - 1]`为最终结果

#### 实现

Java代码

```java
class Solution {
    public int longestPalindromeSubseq(String s) {
        int sLen = s.length();
        int[][] dp = new int[sLen][sLen];
        for(int i = 0; i < sLen; i++) dp[i][i] = 1;
        for(int i = sLen - 1; i >= 0; i--) {
            for(int j = i + 1; j < sLen; j++) {
                if(s.charAt(i) == s.charAt(j)) {
                    dp[i][j] = dp[i + 1][j - 1] + 2; 
                } else {
                    dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[0][sLen - 1];
    }
}
```



## 二、动态规划总结篇

动规五部曲：

1. 确定dp数组(dp table)以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组

一个理念：**简单题是用来巩固方法论的**

---



总的内容：

- 动规基础
- 背包问题
- 打家劫舍系列
- 股票系列
- 子序列系列
