![二叉树](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/%E4%BA%8C%E5%8F%89%E6%A0%91.png)

<!--more-->

<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [算法学习之路--二叉树篇](#%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF--%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AF%87)
  - [一、二叉树理论基础](#%E4%B8%80%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80)
    - [1、二叉树的种类](#1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%A7%8D%E7%B1%BB)
      - [1）满二叉树](#1%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91)
      - [2）完全二叉树](#2%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91)
      - [4）平衡二叉搜索树](#4%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91)
    - [2、二叉树的村塾方式](#2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9D%91%E5%A1%BE%E6%96%B9%E5%BC%8F)
    - [3、二叉树的遍历方式](#3%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F)
    - [4、二叉树的定义](#4%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89)
  - [二、二叉树的递归遍历](#%E4%BA%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86)
  - [三、二叉树的迭代遍历](#%E4%B8%89%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86)
    - [1、前序遍历（迭代法）](#1%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E8%BF%AD%E4%BB%A3%E6%B3%95)
    - [2、中序遍历（迭代法）](#2%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E8%BF%AD%E4%BB%A3%E6%B3%95)
    - [3、后序遍历（迭代法）](#3%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E8%BF%AD%E4%BB%A3%E6%B3%95)
  - [四、二叉树的统一迭代法](#%E5%9B%9B%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%9F%E4%B8%80%E8%BF%AD%E4%BB%A3%E6%B3%95)
    - [1、迭代法中序遍历](#1%E8%BF%AD%E4%BB%A3%E6%B3%95%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86)
    - [2、迭代法的前序遍历](#2%E8%BF%AD%E4%BB%A3%E6%B3%95%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86)
    - [3、迭代法的后序遍历](#3%E8%BF%AD%E4%BB%A3%E6%B3%95%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86)
  - [五、二叉树的层序遍历](#%E4%BA%94%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86)
    - [102、二叉树的层序遍历](#102%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86)
      - [题目](#%E9%A2%98%E7%9B%AE)
      - [思路](#%E6%80%9D%E8%B7%AF)
      - [实现](#%E5%AE%9E%E7%8E%B0)
    - [107、二叉树的层序遍历II](#107%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86ii)
      - [题目](#%E9%A2%98%E7%9B%AE-1)
      - [思路](#%E6%80%9D%E8%B7%AF-1)
      - [实现](#%E5%AE%9E%E7%8E%B0-1)
    - [199、二叉树的右视图](#199%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE)
      - [题目](#%E9%A2%98%E7%9B%AE-2)
      - [思路](#%E6%80%9D%E8%B7%AF-2)
      - [实现](#%E5%AE%9E%E7%8E%B0-2)
    - [637、二叉树的层平均值](#637%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC)
      - [题目](#%E9%A2%98%E7%9B%AE-3)
      - [思路](#%E6%80%9D%E8%B7%AF-3)
      - [实现](#%E5%AE%9E%E7%8E%B0-3)
    - [429、N叉树的层序遍历](#429n%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86)
      - [题目](#%E9%A2%98%E7%9B%AE-4)
      - [思路](#%E6%80%9D%E8%B7%AF-4)
      - [实现](#%E5%AE%9E%E7%8E%B0-4)
    - [515、在每个树行中找最大值](#515%E5%9C%A8%E6%AF%8F%E4%B8%AA%E6%A0%91%E8%A1%8C%E4%B8%AD%E6%89%BE%E6%9C%80%E5%A4%A7%E5%80%BC)
      - [题目：](#%E9%A2%98%E7%9B%AE)
      - [思路](#%E6%80%9D%E8%B7%AF-5)
      - [实现](#%E5%AE%9E%E7%8E%B0-5)
    - [116、填充每个节点的下一个右侧节点指针](#116%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88)
      - [题目](#%E9%A2%98%E7%9B%AE-5)
      - [思路](#%E6%80%9D%E8%B7%AF-6)
      - [实现](#%E5%AE%9E%E7%8E%B0-6)
    - [117、填充每个节点的下一个右侧节点指针II](#117%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88ii)
      - [题目](#%E9%A2%98%E7%9B%AE-6)
      - [思路](#%E6%80%9D%E8%B7%AF-7)
      - [实现](#%E5%AE%9E%E7%8E%B0-7)
  - [六、二叉树的翻转](#%E5%85%AD%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BF%BB%E8%BD%AC)
    - [226、翻转二叉树](#226%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91)
      - [题目](#%E9%A2%98%E7%9B%AE-7)
      - [思路](#%E6%80%9D%E8%B7%AF-8)
        - [递归法](#%E9%80%92%E5%BD%92%E6%B3%95)
        - [迭代法](#%E8%BF%AD%E4%BB%A3%E6%B3%95)
      - [实现](#%E5%AE%9E%E7%8E%B0-8)
        - [递归法](#%E9%80%92%E5%BD%92%E6%B3%95-1)
        - [迭代法](#%E8%BF%AD%E4%BB%A3%E6%B3%95-1)
  - [七、对称二叉树](#%E4%B8%83%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91)
    - [101、对称二叉树](#101%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91)
      - [题目](#%E9%A2%98%E7%9B%AE-8)
      - [思路](#%E6%80%9D%E8%B7%AF-9)
        - [（1）递归法](#1%E9%80%92%E5%BD%92%E6%B3%95)
        - [(2) 迭代法](#2-%E8%BF%AD%E4%BB%A3%E6%B3%95)
      - [实现](#%E5%AE%9E%E7%8E%B0-9)
        - [（1）递归法](#1%E9%80%92%E5%BD%92%E6%B3%95-1)
        - [（2）迭代法](#2%E8%BF%AD%E4%BB%A3%E6%B3%95)
  - [八、二叉树的深度](#%E5%85%AB%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6)
    - [104、二叉树的最大深度](#104%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6)
      - [题目](#%E9%A2%98%E7%9B%AE-9)
      - [思路](#%E6%80%9D%E8%B7%AF-10)
        - [（1）递归法](#1%E9%80%92%E5%BD%92%E6%B3%95-2)
        - [（2）迭代法](#2%E8%BF%AD%E4%BB%A3%E6%B3%95-1)
      - [实现](#%E5%AE%9E%E7%8E%B0-10)
        - [（1）递归法](#1%E9%80%92%E5%BD%92%E6%B3%95-3)
        - [（2）迭代法](#2%E8%BF%AD%E4%BB%A3%E6%B3%95-2)
        - [（3）栈模拟后序遍历](#3%E6%A0%88%E6%A8%A1%E6%8B%9F%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86)
    - [559、N叉树的最大深度](#559n%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6)
      - [题目](#%E9%A2%98%E7%9B%AE-10)
      - [思路](#%E6%80%9D%E8%B7%AF-11)
        - [（1）递归法](#1%E9%80%92%E5%BD%92%E6%B3%95-4)
        - [（2）迭代法](#2%E8%BF%AD%E4%BB%A3%E6%B3%95-3)
      - [实现](#%E5%AE%9E%E7%8E%B0-11)
        - [（1）递归法](#1%E9%80%92%E5%BD%92%E6%B3%95-5)
        - [（2）迭代法](#2%E8%BF%AD%E4%BB%A3%E6%B3%95-4)
    - [111、二叉树的最小深度](#111%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6)
      - [题目](#%E9%A2%98%E7%9B%AE-11)
      - [思路](#%E6%80%9D%E8%B7%AF-12)
        - [（1）递归法](#1%E9%80%92%E5%BD%92%E6%B3%95-6)
        - [（2）迭代法](#2%E8%BF%AD%E4%BB%A3%E6%B3%95-5)
      - [实现](#%E5%AE%9E%E7%8E%B0-12)
        - [（1）递归法](#1%E9%80%92%E5%BD%92%E6%B3%95-7)
        - [（2）迭代法](#2%E8%BF%AD%E4%BB%A3%E6%B3%95-6)
  - [九、完全二叉树的节点个数](#%E4%B9%9D%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0)
    - [222、完全二叉树的节点个数](#222%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0)
      - [题目](#%E9%A2%98%E7%9B%AE-12)
      - [思路](#%E6%80%9D%E8%B7%AF-13)
        - [1）普通二叉树](#1%E6%99%AE%E9%80%9A%E4%BA%8C%E5%8F%89%E6%A0%91)
        - [2）完全二叉树](#2%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91-1)
      - [实现](#%E5%AE%9E%E7%8E%B0-13)
        - [1)  普通二叉树](#1--%E6%99%AE%E9%80%9A%E4%BA%8C%E5%8F%89%E6%A0%91)
        - [2）完全二叉树](#2%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91-2)
  - [十、平衡二叉树](#%E5%8D%81%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91)
    - [110、平衡二叉树](#110%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91)
      - [题目](#%E9%A2%98%E7%9B%AE-13)
      - [思路](#%E6%80%9D%E8%B7%AF-14)
        - [1）递归](#1%E9%80%92%E5%BD%92)
        - [2）迭代法](#2%E8%BF%AD%E4%BB%A3%E6%B3%95)
      - [实现](#%E5%AE%9E%E7%8E%B0-14)
        - [1）递归法](#1%E9%80%92%E5%BD%92%E6%B3%95)
        - [2）迭代法](#2%E8%BF%AD%E4%BB%A3%E6%B3%95-1)
  - [十一、二叉树的所有路径](#%E5%8D%81%E4%B8%80%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84)
    - [257、二叉树的所有路径](#257%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84)
      - [题目](#%E9%A2%98%E7%9B%AE-14)
      - [思路](#%E6%80%9D%E8%B7%AF-15)
        - [1）递归](#1%E9%80%92%E5%BD%92-1)
        - [2） 迭代法](#2-%E8%BF%AD%E4%BB%A3%E6%B3%95)
      - [实现](#%E5%AE%9E%E7%8E%B0-15)
        - [1）递归](#1%E9%80%92%E5%BD%92-2)
        - [2）迭代法](#2%E8%BF%AD%E4%BB%A3%E6%B3%95-2)
  - [十二、左叶子之和](#%E5%8D%81%E4%BA%8C%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C)
    - [404、左叶子之和](#404%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C)
      - [思路](#%E6%80%9D%E8%B7%AF-16)
        - [1）递归法](#1%E9%80%92%E5%BD%92%E6%B3%95-1)
        - [2）迭代法](#2%E8%BF%AD%E4%BB%A3%E6%B3%95-3)
      - [实现](#%E5%AE%9E%E7%8E%B0-16)
        - [1）递归法](#1%E9%80%92%E5%BD%92%E6%B3%95-2)
        - [2）迭代法](#2%E8%BF%AD%E4%BB%A3%E6%B3%95-4)
  - [十三、树左下角的值](#%E5%8D%81%E4%B8%89%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC)
    - [513、找树左下角的值](#513%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC)
      - [题目](#%E9%A2%98%E7%9B%AE-15)
      - [思路](#%E6%80%9D%E8%B7%AF-17)
        - [1）递归法](#1%E9%80%92%E5%BD%92%E6%B3%95-3)
        - [2）迭代法](#2%E8%BF%AD%E4%BB%A3%E6%B3%95-5)
      - [实现](#%E5%AE%9E%E7%8E%B0-17)
        - [1）递归法](#1%E9%80%92%E5%BD%92%E6%B3%95-4)
        - [2）迭代法](#2%E8%BF%AD%E4%BB%A3%E6%B3%95-6)
  - [十三、路径总和](#%E5%8D%81%E4%B8%89%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C)
    - [112、路径总和](#112%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C)
      - [题目](#%E9%A2%98%E7%9B%AE-16)
      - [思路](#%E6%80%9D%E8%B7%AF-18)
        - [1）递归](#1%E9%80%92%E5%BD%92-3)
        - [2）迭代](#2%E8%BF%AD%E4%BB%A3)
      - [实现](#%E5%AE%9E%E7%8E%B0-18)
        - [1）递归法](#1%E9%80%92%E5%BD%92%E6%B3%95-5)
        - [2）迭代法](#2%E8%BF%AD%E4%BB%A3%E6%B3%95-7)
    - [113、路径总和II](#113%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8Cii)
      - [题目](#%E9%A2%98%E7%9B%AE-17)
      - [思路](#%E6%80%9D%E8%B7%AF-19)
      - [实现](#%E5%AE%9E%E7%8E%B0-19)
  - [十四、构造二叉树](#%E5%8D%81%E5%9B%9B%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91)
    - [106、从中序和后序遍历序列构造二叉树](#106%E4%BB%8E%E4%B8%AD%E5%BA%8F%E5%92%8C%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91)
      - [题目](#%E9%A2%98%E7%9B%AE-18)
      - [思路](#%E6%80%9D%E8%B7%AF-20)
      - [实现](#%E5%AE%9E%E7%8E%B0-20)
    - [105、从前序与后序遍历序列构造二叉树](#105%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91)
      - [题目](#%E9%A2%98%E7%9B%AE-19)
      - [思路](#%E6%80%9D%E8%B7%AF-21)
      - [实现](#%E5%AE%9E%E7%8E%B0-21)
    - [654、最大二叉树](#654%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91)
      - [题目](#%E9%A2%98%E7%9B%AE-20)
      - [思路](#%E6%80%9D%E8%B7%AF-22)
      - [实现](#%E5%AE%9E%E7%8E%B0-22)
  - [十五、合并二叉树](#%E5%8D%81%E4%BA%94%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91)
    - [617、合并二叉树](#617%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91)
      - [题目](#%E9%A2%98%E7%9B%AE-21)
      - [思路](#%E6%80%9D%E8%B7%AF-23)
        - [1）递归法](#1%E9%80%92%E5%BD%92%E6%B3%95-6)
        - [2）迭代法](#2%E8%BF%AD%E4%BB%A3%E6%B3%95-8)
      - [实现](#%E5%AE%9E%E7%8E%B0-23)
        - [1）递归法](#1%E9%80%92%E5%BD%92%E6%B3%95-7)
        - [2）迭代法](#2%E8%BF%AD%E4%BB%A3%E6%B3%95-9)
  - [十六、二叉树中的搜索专题](#%E5%8D%81%E5%85%AD%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2%E4%B8%93%E9%A2%98)
    - [700、二叉搜索树中的搜索](#700%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2)
      - [题目](#%E9%A2%98%E7%9B%AE-22)
      - [思路](#%E6%80%9D%E8%B7%AF-24)
        - [1）递归法](#1%E9%80%92%E5%BD%92%E6%B3%95-8)
        - [2）迭代法](#2%E8%BF%AD%E4%BB%A3%E6%B3%95-10)
      - [实现](#%E5%AE%9E%E7%8E%B0-24)
        - [1）递归法](#1%E9%80%92%E5%BD%92%E6%B3%95-9)
        - [2）迭代法](#2%E8%BF%AD%E4%BB%A3%E6%B3%95-11)
    - [98、验证二叉搜索树](#98%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91)
      - [题目](#%E9%A2%98%E7%9B%AE-23)
      - [思路](#%E6%80%9D%E8%B7%AF-25)
        - [1）递归法](#1%E9%80%92%E5%BD%92%E6%B3%95-10)
        - [2）迭代法](#2%E8%BF%AD%E4%BB%A3%E6%B3%95-12)
      - [实现](#%E5%AE%9E%E7%8E%B0-25)
        - [1）递归法](#1%E9%80%92%E5%BD%92%E6%B3%95-11)
        - [2）迭代法](#2%E8%BF%AD%E4%BB%A3%E6%B3%95-13)
    - [530、二叉搜索树的最小绝对差](#530%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE)
      - [题目](#%E9%A2%98%E7%9B%AE-24)
      - [思路](#%E6%80%9D%E8%B7%AF-26)
        - [1）递归](#1%E9%80%92%E5%BD%92-4)
        - [2）迭代法](#2%E8%BF%AD%E4%BB%A3%E6%B3%95-14)
      - [实现](#%E5%AE%9E%E7%8E%B0-26)
        - [1）递归](#1%E9%80%92%E5%BD%92-5)
        - [2）迭代法](#2%E8%BF%AD%E4%BB%A3%E6%B3%95-15)
    - [501、二叉搜索树中的众数](#501%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0)
      - [题目](#%E9%A2%98%E7%9B%AE-25)
      - [思路](#%E6%80%9D%E8%B7%AF-27)
        - [1）递归法](#1%E9%80%92%E5%BD%92%E6%B3%95-12)
        - [2）迭代法](#2%E8%BF%AD%E4%BB%A3%E6%B3%95-16)
      - [实现](#%E5%AE%9E%E7%8E%B0-27)
        - [1）递归法](#1%E9%80%92%E5%BD%92%E6%B3%95-13)
        - [2）迭代法](#2%E8%BF%AD%E4%BB%A3%E6%B3%95-17)
    - [236、二叉树的最近公共祖先](#236%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88)
      - [题目](#%E9%A2%98%E7%9B%AE-26)
      - [思路](#%E6%80%9D%E8%B7%AF-28)
      - [实现](#%E5%AE%9E%E7%8E%B0-28)
    - [235、二叉搜索树的最近公共祖先](#235%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88)
      - [题目](#%E9%A2%98%E7%9B%AE-27)
      - [思路](#%E6%80%9D%E8%B7%AF-29)
        - [1）递归法](#1%E9%80%92%E5%BD%92%E6%B3%95-14)
        - [2）迭代法](#2%E8%BF%AD%E4%BB%A3%E6%B3%95-18)
      - [实现](#%E5%AE%9E%E7%8E%B0-29)
        - [1）递归法](#1%E9%80%92%E5%BD%92%E6%B3%95-15)
        - [2）迭代法](#2%E8%BF%AD%E4%BB%A3%E6%B3%95-19)
    - [701、二叉搜索树中的插入操作](#701%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C)
      - [题目](#%E9%A2%98%E7%9B%AE-28)
      - [思路](#%E6%80%9D%E8%B7%AF-30)
        - [1）递归法](#1%E9%80%92%E5%BD%92%E6%B3%95-16)
        - [2）迭代法](#2%E8%BF%AD%E4%BB%A3%E6%B3%95-20)
      - [实现](#%E5%AE%9E%E7%8E%B0-30)
        - [1）递归法](#1%E9%80%92%E5%BD%92%E6%B3%95-17)
        - [2）迭代法](#2%E8%BF%AD%E4%BB%A3%E6%B3%95-21)
    - [450、删除二叉搜索树中的节点](#450%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9)
      - [题目](#%E9%A2%98%E7%9B%AE-29)
      - [思路](#%E6%80%9D%E8%B7%AF-31)
        - [1）递归法](#1%E9%80%92%E5%BD%92%E6%B3%95-18)
        - [2）普通二叉树的删除方式](#2%E6%99%AE%E9%80%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4%E6%96%B9%E5%BC%8F)
        - [3）迭代法](#3%E8%BF%AD%E4%BB%A3%E6%B3%95)
      - [实现](#%E5%AE%9E%E7%8E%B0-31)
        - [1）递归法](#1%E9%80%92%E5%BD%92%E6%B3%95-19)
        - [2）普通二叉树的删除](#2%E6%99%AE%E9%80%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4)
        - [3）迭代法](#3%E8%BF%AD%E4%BB%A3%E6%B3%95-1)
    - [669、修建二叉搜索树](#669%E4%BF%AE%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91)
      - [题目](#%E9%A2%98%E7%9B%AE-30)
      - [思路](#%E6%80%9D%E8%B7%AF-32)
        - [1）递归法](#1%E9%80%92%E5%BD%92%E6%B3%95-20)
        - [2）迭代法](#2%E8%BF%AD%E4%BB%A3%E6%B3%95-22)
      - [实现](#%E5%AE%9E%E7%8E%B0-32)
        - [1）递归法](#1%E9%80%92%E5%BD%92%E6%B3%95-21)
        - [2）迭代法](#2%E8%BF%AD%E4%BB%A3%E6%B3%95-23)
    - [108、将有序数组转换成为二叉搜索树](#108%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E6%88%90%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91)
      - [题目](#%E9%A2%98%E7%9B%AE-31)
      - [思路](#%E6%80%9D%E8%B7%AF-33)
        - [1）递归](#1%E9%80%92%E5%BD%92-6)
        - [2）迭代法](#2%E8%BF%AD%E4%BB%A3%E6%B3%95-24)
      - [实现](#%E5%AE%9E%E7%8E%B0-33)
        - [1）递归法](#1%E9%80%92%E5%BD%92%E6%B3%95-22)
        - [2）迭代法](#2%E8%BF%AD%E4%BB%A3%E6%B3%95-25)
    - [538、把二叉搜索树转换为累加树](#538%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91)
      - [题目](#%E9%A2%98%E7%9B%AE-32)
      - [思路](#%E6%80%9D%E8%B7%AF-34)
        - [1）递归](#1%E9%80%92%E5%BD%92-7)
        - [2）迭代法](#2%E8%BF%AD%E4%BB%A3%E6%B3%95-26)
      - [实现](#%E5%AE%9E%E7%8E%B0-34)
        - [1）递归](#1%E9%80%92%E5%BD%92-8)
        - [2）迭代法](#2%E8%BF%AD%E4%BB%A3%E6%B3%95-27)
- [二叉树篇--总结](#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AF%87--%E6%80%BB%E7%BB%93)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->



> [代码随想录 (programmercarl.com)](https://www.programmercarl.com/)

# 算法学习之路--二叉树篇

## 一、二叉树理论基础

### 1、二叉树的种类

*在解题过程中二叉树形式主要有两种：*

- 满二叉树
- 完全二叉树

#### 1）满二叉树

满⼆叉树：如果⼀棵⼆叉树只有度为0的结点和度为2的结点，并且度为0的结点在同⼀层 上，则这棵⼆叉树为满⼆叉树

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221222090231.png)

这棵二叉树为满二叉树，也可以说是深度为 `k`，有 `2 ^ k - 1`个节点的二叉树

#### 2）完全二叉树

完全⼆叉树：在完全⼆叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最⼤值，并且最下⾯⼀层的节点都集中在该层最左边的若⼲位置。若最底层为第 `h `层，则该层包含` 1~ 2 ^ h -1` 个节点

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221222090451.png)

####3）二叉搜索树

上述介绍的树都是没有数值的，而二叉搜索树是有数值的了，**二叉搜索树是一个有序树**

- 若它的左子树不空，则左子树上所有节点的值均小于它的根结点的值
- 若它的右子树不空，则右子树上所有节点的值均大于它的根结点的值
- 它的左、右子树也分别为二叉排序树

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221222090819.png)

#### 4）平衡二叉搜索树

平衡二叉搜索树：又称为AVL(Adelson - Velsky and Landis)树，它具有以下性质

- 它是一颗空树 或者 它的左右两颗子树的高度差的绝对值不超过1
- 左右两颗子树都是一颗平衡二叉树

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221222091200.png)

最后一颗不是平衡二叉树，因为它的左右两颗子树的高度差的绝对值超过1了

### 2、二叉树的村塾方式

**二叉树可以链式存储，也可以顺序存储**

链式存储（指针实现）：

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221222091825.png)

顺序存储（数组实现）：

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221222091910.png)

> 用数组来存储二叉树如何遍历呢？
>
> 如果父结点的数组下标是 i ，那么它的左节点就是`2 * i + 1`，右节点就是`2 * i + 2`

### 3、二叉树的遍历方式

1）二叉树的遍历方式主要有两种：

1. 深度优先遍历：先往深走，遇到叶子结点再往回走
2. 广度优先遍历：一层一层得去遍历

**这两种遍历方式是图论中最基本的两种遍历方式**

在此基础上拓展：

1. 深度优先遍历

   - 前序遍历（递归法、迭代法）
   - 中序遍历（递归法、迭代法）
   - 后序遍历（递归法、迭代法）

   ![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221222092514.png)

2. 广度优先遍历

   - 层序遍历（迭代法）

2）二叉树中深度优先遍历和广度优先遍历的实现方式

1. 经常使用递归的方式来实现深度优先遍历
2. *栈就是递归的一种实现结构*，深度优先遍历也可以借助栈使用非递归的方式实现
3. 广度优先遍历的实现一般使用队列来实现，这就是队列FIFO的特点决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树

### 4、二叉树的定义

1）顺序存储就是使用数组来存储

2）链式存储的二叉树节点的定义方式：

Java代码

```java
 public class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode() {}
    TreeNode(int val) { this.val = val; }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

## 二、二叉树的递归遍历

> 看看这是不是你？
>
> 看递归算法“一看就会，一写就废”
>
> 主要是对递归不成体系，没有方法论，**每次写递归代码都是靠玄学，代码能否AC纯靠运气**

**递归方法**

1. **确定递归函数的参数和返回值**
   确定哪些参数是递归的过程中需要处理的，那么就在递归里加上这个参数，并且还要明确每次递归的返回值进而确定递归函数的返回类型

2. **确定终止条件**

   写完了递归算法，运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈来保存每一层递归的信息，如果递归没有终止，操作系统的内存必然就会溢出

3. **确定单层递归的逻辑**
   确定每一层递归需要处理的信息，在这里也就会重复调用来实现递归的过程

【例子】二叉树的前、中、后序遍历

> - **[144. 二叉树的前序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-preorder-traversal/)**
> - **[94. 二叉树的中序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-inorder-traversal/)**
> - **[145. 二叉树的后序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-postorder-traversal/)**

1. 确定递归函数的参数和返回值
   因为要打印出前序遍历结点的数值，所以参数里面需要传入`List`存放结点的值，除了这一点就不需要再处理数据了，也不需要有返回值，所以递归函数的返回值类型就是`void`

   ```java
   void traversal(TreeNode cur, List<Integer> res);
   ```

2. 确定终止条件
   在递归的过程中，当前遍历的节点为空，本层的递归就结束了。所以如果当前遍历的这个结点为空，就直接`return`

   ```java
   if(cur == null) return;
   ```

3. 确定单层遍历的逻辑
   前序遍历是**中左右**的顺序，所以在单层递归的逻辑中，是要先取中间节点的数值

   ```java
   res.add(cur.val); // 中
   traversal(cur.left, res); // 左
   traversal(cur.right, res); // 右
   ```

前序遍历：

```java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        traversal(root, res);
        return res;
    }
    private void traversal(TreeNode cur, List<Integer> res) {
        if(cur == null) return;
        res.add(cur.val); // 中
        traversal(cur.left, res); // 左
        traversal(cur.right, res); // 右
    }
}
```

对应的，中序遍历和后序遍历

中序遍历：

```java
 private void traversal(TreeNode cur, List<Integer> res) {
     if(cur == null) return;
     traversal(cur.left, res); // 左
     res.add(cur.val); // 中
     traversal(cur.right, res); // 右
 }
```

后序遍历：

```java
 private void traversal(TreeNode cur, List<Integer> res) {
     if(cur == null) return;
     traversal(cur.left, res); // 左
     traversal(cur.right, res); // 右
     res.add(cur.val); // 中
 }
```

## 三、二叉树的迭代遍历

> 为什么可以用迭代法（非递归的方式）来实现二叉树的前中后序遍历呢？
>
> **递归的实现就是：每⼀次递归调⽤都会 把函数的局部变量、参数值和返回地址等压⼊调⽤栈中**，然后递归返回的时候，从栈顶弹出上⼀次递归的各项参数，所以这就是递归为什么可以返回上⼀层位置的原因

### 1、前序遍历（迭代法）

前序遍历是中左右，每次先处理的是中间结点，那么先将根结点放入栈中，然后将右节点加入栈，再加入左节点

> 为什么要先加入右节点，再加入左节点呢？
>
> 因为这样在加入结果列表的时候才是中左右的顺序

【代码实现】（**注意中间结点为空不入栈**）

```java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> ans = new ArrayList<>();
        if(root == null) return ans;

        Deque<TreeNode> stack = new LinkedList<>();
        // 根结点入栈
        stack.push(root);
        while(!stack.isEmpty()) {
            TreeNode cur = stack.pop();
            // 加入结果集合
            ans.add(cur.val);

            // 空节点不入栈
            // 右节点入栈（后出栈）
            if(cur.right != null) {
                stack.push(cur.right);
            } 
            // 左节点入栈（先于右节点出栈）
            if(cur.left != null) {
                stack.push(cur.left);
            } 
        }
        return ans;
    }
}
```

### 2、中序遍历（迭代法）

> 上述迭代过程有两个操作
>
> - 处理：将元素放入 ans 集合
> - 访问： 遍历结点

分析下为什么迭代法的前序遍历代码不能和中序遍历通用呢？

因为前序遍历的顺序是中左右，先访问的节点是中间结点，先处理的节点也是中间结点，所以才能写出相对简洁的代码，因为**要访问的节点和要处理的节点是一致的，都是中间结点**

再看中序遍历，中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左边的最底部，再开始处理节点（也就是再把节点的数值存入ans集合中），这就**造成了访问节点的顺序和处理节点的顺序不一致**

所以在使用迭代法写中序遍历的时候，就需要借助指针的遍历来帮助访问节点，栈则用来处理节点上的元素

动画展示（看官方题解）：[二叉树的中序遍历 - 二叉树的中序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-inorder-traversal/solution/er-cha-shu-de-zhong-xu-bian-li-by-leetcode-solutio/)

【代码实现】

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> ans = new ArrayList<>();
        if(root == null) return ans;

        Deque<TreeNode> stack = new LinkedList<>();
        TreeNode cur = root;
        while(cur != null || !stack.isEmpty()) {
            if(cur != null) {
                // 指针遍历
                stack.push(cur); // 访问的节点入栈
                cur = cur.left; // 左
            } else {
                cur = stack.pop(); // 处理节点
                ans.add(cur.val); // 中
                cur = cur.right; // 右
            }
        }
        return ans;
    }
}
```

### 3、后序遍历（迭代法）

前序遍历是中左右，后序遍历是左右中，那么只需要调整下前序遍历的代码顺序，就变成了中右左的遍历顺序，然后再反转ans集合，输出的结果顺序就是左右中了

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221222103148.png)

【代码实现】

```java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> ans = new ArrayList<>();
        if(root == null) return ans;

        Deque<TreeNode> stack = new LinkedList<>();
        // 根结点入栈
        stack.push(root);
        while(!stack.isEmpty()) {
            TreeNode cur = stack.pop();
            // 加入结果集合
            ans.add(cur.val);

            // 空节点不入栈
            // 左节点入栈（后出栈）
            if(cur.left != null) {
                stack.push(cur.left);
            } 
            // 右节点入栈（先于左节点出栈）
            if(cur.right != null) {
                stack.push(cur.right);
            } 
        }
        // 反转ans集合
        Collections.reverse(ans);
        return ans;
    }
}
```

## 四、二叉树的统一迭代法

> 迭代法实现的先中后序，其实风格也不是那么统⼀，除了先序和后序，有关 联，中序完全就是另⼀个风格了，⼀会⽤栈遍历，⼀会又⽤指针来遍历
>
> ⽆法同时解决访问节点（遍历节点）和处理节点（将元素放进结果集）不⼀致的情况

**解决方案**：将访问的节点放入栈中，把要处理的节点也放入栈中但是要做标记（要处理的节点放入栈后，紧接着放入一个空指针作为标记）

### 1、迭代法中序遍历

中序遍历Java代码：

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> ans = new ArrayList<>();
        if(root == null) return ans;
        Deque<TreeNode> stack = new LinkedList<>();
        stack.push(root);
        while(!stack.isEmpty()) {
            TreeNode cur = stack.pop();
            if(cur != null) {
                // 添加右节点
                if(cur.right != null) {
                    stack.push(cur.right);
                }
                // 添加中间结点
                stack.push(cur);
                // 添加标记，表明中间结点访问过但是尚未处理
                stack.push(null);
                // 添加左节点
                if(cur.left != null) {
                    stack.push(cur.left);
                }
            } else {
                // 当前弹出栈的节点为空节点，将此时栈顶元素弹出 加入结果集
                cur = stack.pop();
                ans.add(cur.val);
            }
        }
        return ans;
    }
}
```

### 2、迭代法的前序遍历

前序遍历Java代码：（和中序遍历相比，只改变两行代码的顺序）

```java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> ans = new ArrayList<>();
        if(root == null) return ans;
        Deque<TreeNode> stack = new LinkedList<>();
        stack.push(root);
        while(!stack.isEmpty()) {
            TreeNode cur = stack.pop();
            if(cur != null) {
                // 添加右节点
                if(cur.right != null) {
                    stack.push(cur.right);
                }
                // 添加左节点
                if(cur.left != null) {
                    stack.push(cur.left);
                }
                // 添加中间结点
                stack.push(cur);
                // 添加标记，表明中间结点访问过但是尚未处理
                stack.push(null);
                
            } else {
                // 当前弹出栈的节点为空节点，将此时栈顶元素弹出 加入结果集
                cur = stack.pop();
                ans.add(cur.val);
            }
        }
        return ans;
    }
}
```

### 3、迭代法的后序遍历

后序遍历Java代码：（和中序遍历相比，只改变两行代码的顺序）

```java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
         List<Integer> ans = new ArrayList<>();
        if(root == null) return ans;
        Deque<TreeNode> stack = new LinkedList<>();
        stack.push(root);
        while(!stack.isEmpty()) {
            TreeNode cur = stack.pop();
            if(cur != null) {
                // 添加中间结点
                stack.push(cur);
                // 添加标记，表明中间结点访问过但是尚未处理
                stack.push(null);
                // 添加右节点
                if(cur.right != null) {
                    stack.push(cur.right);
                }
                // 添加左节点
                if(cur.left != null) {
                    stack.push(cur.left);
                }
            } else {
                // 当前弹出栈的节点为空节点，将此时栈顶元素弹出 加入结果集
                cur = stack.pop();
                ans.add(cur.val);
            }
        }
        return ans;
    }
}
```

> 统一迭代法的关键就是**加标记的时机**，代码不好理解，但是风格统一

## 五、二叉树的层序遍历

### 102、二叉树的层序遍历

#### 题目

题目链接：**[102. 二叉树的层序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-level-order-traversal/)**

给你二叉树的根节点 `root` ，返回其节点值的 **层序遍历** 。 （即逐层地，从左到右访问所有节点）。

**示例 1：**

![img](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/tree1.jpg)

```
输入：root = [3,9,20,null,null,15,7]
输出：[[3],[9,20],[15,7]]
```

**示例 2：**

```
输入：root = [1]
输出：[[1]]
```

**示例 3：**

```
输入：root = []
输出：[]
```

**提示：**

- 树中节点数目在范围 `[0, 2000]` 内
- `-1000 <= Node.val <= 1000`

#### 思路

层序遍历一颗二叉树，就是从左到右一层一层的去遍历二叉树

![二叉树的层序遍历](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/ce41cf1cabfa7a56387f63d927c8819fe1479ecf6f193a2a1b47964f5a8d1c8e.jpg)

需要借助一个辅助数据结构**队列**来实现，**队列FIFO，符合一层一层遍历的逻辑**，而使用栈LIFO的特点，适合模拟深度优先遍历也就是递归的逻辑

而这种**层序遍历方式就是图论中的广度优先遍历**，只不过应用在二叉树上

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/2elr5.gif)



#### 实现

Java代码

```java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> ans = new ArrayList<>();
        if(root == null) return ans;
        Queue<TreeNode> seen = new LinkedList<>();
        seen.offer(root);
        while(!seen.isEmpty()) {
            List<Integer> levelList = new ArrayList<>();
            // 这⾥⼀定要使⽤固定⼤⼩size，不要使⽤seen.size()，因为队列大小是不断变化的
            int currentLevelSize = seen.size();
            for(int i = 0; i < currentLevelSize; i++) {
                TreeNode cur = seen.poll();
                levelList.add(cur.val);
                // 先加入左节点，因为先进先出，层序遍历是从左到右
                if(cur.left != null) {
                    seen.offer(cur.left);
                }
                if(cur.right != null) {
                    seen.offer(cur.right);
                }
            }
            ans.add(levelList);
        }
        return ans;
    }
}
```

### 107、二叉树的层序遍历II

#### 题目

题目链接：**[107. 二叉树的层序遍历 II - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/)**

给你二叉树的根节点 `root` ，返回其节点值 **自底向上的层序遍历** 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）

**示例 1：**

![img](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/tree1-16717597254843.jpg)

```
输入：root = [3,9,20,null,null,15,7]
输出：[[15,7],[9,20],[3]]
```

**示例 2：**

```
输入：root = [1]
输出：[[1]]
```

**示例 3：**

```
输入：root = []
输出：[]
```

**提示：**

- 树中节点数目在范围 `[0, 2000]` 内
- `-1000 <= Node.val <= 1000`

#### 思路

相较于**[102. 二叉树的层序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-level-order-traversal/)**，其实就是把最后的结果反转就可以了

#### 实现

Java代码

```java
class Solution {
    public List<List<Integer>> levelOrderBottom(TreeNode root) {
        List<List<Integer>> ans = new ArrayList<>();
        if(root == null) return ans;
        Queue<TreeNode> seen = new LinkedList<>();
        seen.offer(root);
        while(!seen.isEmpty()) {
            List<Integer> levelList = new ArrayList<>();
            int currentLevelSize = seen.size();
            for(int i = 0; i < currentLevelSize; i++) {
                TreeNode cur = seen.poll();
                levelList.add(cur.val);
                if(cur.left != null) seen.offer(cur.left);
                if(cur.right != null) seen.offer(cur.right);
            }
            ans.add(levelList);
        }
        // 反转结果集
        Collections.reverse(ans);
        return ans;
    }
}
```

### 199、二叉树的右视图

#### 题目

题目链接：给定一个二叉树的 **根节点** `root`，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

**示例 1:**

![img](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/tree.jpg)

```
输入: [1,2,3,null,5,null,4]
输出: [1,3,4]
```

**示例 2:**

```
输入: [1,null,3]
输出: [1,3]
```

**示例 3:**

```
输入: []
输出: []
```

**提示:**

- 二叉树的节点个数的范围是 `[0,100]`
- `-100 <= Node.val <= 100`

#### 思路

层序遍历的时候，判断是否遍历到单层最后的元素，如果是，就加入结果

#### 实现

```java
class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> ans = new ArrayList<>();
        if(root == null) return ans;
        Queue<TreeNode> seen = new LinkedList<>();
        seen.offer(root);
        while(!seen.isEmpty()) {
            int currentLevelSize = seen.size();
            for(int i = 0; i < currentLevelSize; i++) {
                TreeNode cur = seen.poll();
                if(cur.left != null) seen.offer(cur.left);
                if(cur.right != null) seen.offer(cur.right);
                // 判断是否是当前层的最后一个元素
                if(i == (currentLevelSize - 1)) ans.add(cur.val);
            }
        }
        return ans;
    }
}
```

### 637、二叉树的层平均值

#### 题目

题目链接：**[637. 二叉树的层平均值 - 力扣（LeetCode）](https://leetcode.cn/problems/average-of-levels-in-binary-tree/)**

给定一个非空二叉树的根节点 `root` , 以数组的形式返回每一层节点的平均值。与实际答案相差 `10-5` 以内的答案可以被接受。

**示例 1：**

![img](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/avg1-tree.jpg)

```
输入：root = [3,9,20,null,null,15,7]
输出：[3.00000,14.50000,11.00000]
解释：第 0 层的平均值为 3,第 1 层的平均值为 14.5,第 2 层的平均值为 11 。
因此返回 [3, 14.5, 11] 。
```

**示例 2:**

![img](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/avg2-tree.jpg)

```
输入：root = [3,9,20,15,7]
输出：[3.00000,14.50000,11.00000]
```

**提示：**



- 树中节点数量在 [1, 10^4^] 范围内
- -2^31^ <= Node.val <= 2^31^ - 1

#### 思路

本题就是在层序遍历的时候把一层的节点数值求总和之后在取平均值

#### 实现

Java代码

```java
class Solution {
    public List<Double> averageOfLevels(TreeNode root) {
        List<Double> ans = new ArrayList<>();
        if(root == null) return ans;
        Queue<TreeNode> seen = new LinkedList<>();
        seen.offer(root);
        while(!seen.isEmpty()) {
            int currentLevelSize = seen.size();
            // 统计每一层的数值和
            double sum = 0;
            for(int i = 0; i < currentLevelSize; i++) {
                TreeNode cur = seen.poll();
                sum += cur.val;
                if(cur.left != null) seen.offer(cur.left);
                if(cur.right != null) seen.offer(cur.right);
            }
           	// 将每一层的均值放入结果集
            ans.add(sum / currentLevelSize);
        }
        return ans;
    }
}
```

### 429、N叉树的层序遍历

#### 题目

题目链接：**[429. N 叉树的层序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/)**

给定一个 N 叉树，返回其节点值的*层序遍历*。（即从左到右，逐层遍历）。

树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。

**示例 1：**

![img](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/narytreeexample.png)

```
输入：root = [1,null,3,2,4,null,5,6]
输出：[[1],[3,2,4],[5,6]]
```

**示例 2：**

![img](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/sample_4_964.png)

```
输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
输出：[[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]
```

**提示：**

- 树的高度不会超过 `1000`
- 树的节点总数在 `[0, 10^4]` 之间

#### 思路

思路和上述几题类似，只不过一个节点存在多个子节点

#### 实现

Java代码

```java
class Solution {
    public List<List<Integer>> levelOrder(Node root) {
        List<List<Integer>> ans = new ArrayList<>();
        if(root == null) return ans;
        Queue<Node> seen = new LinkedList<>();
        seen.offer(root);
        while(!seen.isEmpty()) {
            List<Integer> levelList = new ArrayList<>();
            int currentLevelSize = seen.size();
            for(int i = 0; i < currentLevelSize; i++) {
                Node cur = seen.poll();
                levelList.add(cur.val);
                List<Node> childrenList = cur.children;
                for(Node children : childrenList) {
                    seen.offer(children);
                }
            }
            ans.add(levelList);
        }
        return ans;
    }
}
```

### 515、在每个树行中找最大值

#### 题目：

题目链接：**[515. 在每个树行中找最大值 - 力扣（LeetCode）](https://leetcode.cn/problems/find-largest-value-in-each-tree-row/)**

给定一棵二叉树的根节点 `root` ，请找出该二叉树中每一层的最大值。

**示例1：**

![img](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/largest_e1.jpg)

```
输入: root = [1,3,2,5,3,null,9]
输出: [1,3,9]
```

**示例2：**

```
输入: root = [1,2,3]
输出: [1,3]
```

**提示：**

- 二叉树的节点个数的范围是 [0,10^4^]
- -2^31^ <= Node.val <= 2^31^ - 1

#### 思路

层序遍历，取每层最大值

#### 实现

Java代码

```java
class Solution {
    public List<Integer> largestValues(TreeNode root) {
        List<Integer> ans = new ArrayList<>();
        if(root == null) return ans;
        Queue<TreeNode> seen = new LinkedList<>();
        seen.offer(root);
        while(!seen.isEmpty()) {
            int currentLevelSize = seen.size();
            int maxVal = Integer.MIN_VALUE;
            for(int i = 0; i < currentLevelSize; i++) {
                TreeNode cur = seen.poll();
                if(maxVal < cur.val) maxVal = cur.val;
                if(cur.left != null) seen.offer(cur.left);
                if(cur.right != null) seen.offer(cur.right);
            }
            ans.add(maxVal);
        }
        return ans;
    }
}
```

### 116、填充每个节点的下一个右侧节点指针

#### 题目

题目链接：**[116. 填充每个节点的下一个右侧节点指针 - 力扣（LeetCode）](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/)**

给定一个 **完美二叉树** ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：

```
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 `null`。

初始状态下，所有 next 指针都被设置为 `null`。

**示例 1：**

![img](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/116_sample.png)

```
输入：root = [1,2,3,4,5,6,7]
输出：[1,#,2,3,#,4,5,6,7,#]
解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，'#' 标志着每一层的结束。
```

**示例 2:**

```
输入：root = []
输出：[]
```

**提示：**

- 树中节点的数量在 `[0, 2^12 - 1]` 范围内
- `-1000 <= node.val <= 1000`

#### 思路

本题依然是层序遍历，只不过在单层遍历的时候记录下本层的头部节点，然后在遍历的时候让前一个节点指向本节点就可以了

#### 实现

Java代码

```java
class Solution {
    public Node connect(Node root) {
        if(root == null) {
            return root;
        }
        Queue<Node> seen = new LinkedList<>();
        seen.offer(root);
        while(!seen.isEmpty()) {
            int currentLevelSize = seen.size();
            Node cur = null;
            Node pre = null;
            for(int i = 0; i < currentLevelSize; i++) {
                if(i == 0) {
                    // 记录每层的头节点
                    pre = seen.poll();
                    cur = pre;
                } else {
                    cur = seen.poll();
                    // 本层前一个的节点的next指向本节点
                    pre.next = cur;
                    pre = pre.next;
                }
                if(cur.left != null) seen.offer(cur.left);
                if(cur.right != null) seen.offer(cur.right);
            }
            // 本层的最后一个节点指向null
            pre.next = null; 
        }
        return root;
    }
}
```

### 117、填充每个节点的下一个右侧节点指针II

#### 题目

题目链接：**[117. 填充每个节点的下一个右侧节点指针 II - 力扣（LeetCode）](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/)**

给定一个二叉树

```
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 `null`。

初始状态下，所有 next 指针都被设置为 `null`。

**示例：**

![img](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/117_sample.png)

```
输入：root = [1,2,3,4,5,null,7]
输出：[1,#,2,3,#,4,5,7,#]
解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化输出按层序遍历顺序（由 next 指针连接），'#' 表示每层的末尾
```

**提示：**

- 树中的节点数小于 `6000`
- `-100 <= node.val <= 100`

#### 思路

这道题⽬说是⼆叉树，但116题⽬说是完整⼆叉树，其实没有任何差别，⼀样的代码⼀样的逻辑⼀样的味道

#### 实现

Java代码

```java
class Solution {
    public Node connect(Node root) {
        if(root == null) return root;
        Queue<Node> seen = new LinkedList<>();
        seen.offer(root);
        while(!seen.isEmpty()) {
            int currentLevelSize = seen.size();
            Node cur = null;
            Node pre = null;
            for(int i = 0; i < currentLevelSize; i++) {
                if(i == 0) {
                    pre = seen.poll();
                    cur = pre;
                } else {
                    cur = seen.poll();
                    pre.next = cur;
                    pre = pre.next;
                }
                if(cur.left != null) seen.offer(cur.left);
                if(cur.right != null) seen.offer(cur.right);
            }
            pre.next = null;
        }
        return root;
    }
}
```

## 六、二叉树的翻转

### 226、翻转二叉树

#### 题目

题目链接：**[226. 翻转二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/invert-binary-tree/)**

给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。

**示例 1：**

![img](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/invert1-tree.jpg)

```
输入：root = [4,2,7,1,3,6,9]
输出：[4,7,2,9,6,3,1]
```

**示例 2：**

![img](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/invert2-tree.jpg)

```
输入：root = [2,1,3]
输出：[2,3,1]
```

**示例 3：**

```
输入：root = []
输出：[]
```

**提示：**

- 树中节点数目范围在 `[0, 100]` 内
- `-100 <= Node.val <= 100`

> 题外话
>
> [如何看待 Max Howell 被 Google 拒绝？ (qq.com)](https://mp.weixin.qq.com/s?__biz=MzI4ODE1MTQwNg==&mid=2247484027&idx=1&sn=08a3989aaa9fca824781e111b7566a19&chksm=ebc3807adcb4096cda22285cd9f6e74e1dad46937e7ef3388ed48b388f37ee3e8b8babcab41c&scene=27)

#### 思路

如果要从整棵树来看，翻转挺复杂，整个树以中间分割线进⾏翻转
![image-20221223105113815](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20221223105113815.png)

可以发现想要翻转它，其实就是把每一个节点的左右孩子交换一下就可以了

**关键在于遍历顺序**，遍历的过程中去反转每一个节点的左右孩⼦就可以达到整体翻转的效果。 **注意只要把每⼀个节点的左右孩⼦翻转⼀次，就可以达到整体翻转的效果**

> 这道题⽬使⽤前序遍历和后序遍历都可以，唯独中序遍历不⾏，因为中序遍历会把某些节点 的左右孩⼦翻转了两次！建议拿纸画⼀画，就理解了
>
> 那么层序遍历可以不可以呢？依然可以的！只要把每⼀个节点的左右孩⼦翻转⼀下的遍历⽅ 式都是可以的

=> 前序遍历 || 后序遍历 || 层序遍历

动画演示：[动画演示 两种实现 226. 翻转二叉树 - 翻转二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/invert-binary-tree/solution/dong-hua-yan-shi-liang-chong-shi-xian-226-fan-zhua/)

##### 递归法

递归三部曲：

1. 确定递归函数的参数和返回值
   参数就是要传⼊节点的指针，不需要其他参数了，通常此时定下来主要参数，如果在写递归 的逻辑中发现还需要其他参数的时候，随时补充。 
   返回值的话其实也不需要，但是题⽬中给出的要返回root节点的指针，可以直接使⽤题⽬定义好的函数，所以就函数的返回类型为`TreeNode`

   ```java
   TreeNode invertTree(TreeNode root);
   ```

   

2. 确定终止条件
   当前节点为空时，就返回

   ```java
   if(root == null) return root;
   ```

3. 确定单层遍历的逻辑

   > 这里采用前序遍历

   先进行交换左右孩子节点，然后翻转左子树，再翻转右子树

   ```java
   TreeNode tempNode = root.left;
   root.left = root.right;
   root.right = tempNode;
   invertTree(root.left);
   invertTree(root.right);
   ```

##### 迭代法

**深度优先遍历**

递归 ==> 栈实现

**广度优先遍历**

层序遍历，翻转每一个节点的左右节点

#### 实现

##### 递归法

Java代码：

```java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if(root == null) return null;
        TreeNode tempNode = root.left;
        root.left = root.right;
        root.right = tempNode;
        invertTree(root.left);
        invertTree(root.right);
        return root;
    }
}
```

##### 迭代法

**深度优先遍历**

前序遍历

```java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if(root == null) return root;
        Deque<TreeNode> stack = new LinkedList<>();
        stack.push(root);
        while(!stack.isEmpty()) {
            // 中间结点
            TreeNode cur = stack.pop(); 
            TreeNode tempNode = cur.left;
            cur.left = cur.right;
            cur.right = tempNode;
            // 右节点
            if(cur.right != null) stack.push(cur.right);
            // 左节点
            if(cur.left != null) stack.push(cur.left);
        }
        return root;
    }
}
```

统一迭代法的前序遍历

```java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if(root == null) return root;
        Deque<TreeNode> stack = new LinkedList<>();
        stack.push(root);
        while(!stack.isEmpty()) {
            TreeNode cur = stack.pop(); 
            if(cur != null) {
                // 右节点
                if(cur.right != null) stack.push(cur.right);
                // 左节点
                if(cur.left != null) stack.push(cur.left);
                // 中间结点
                stack.push(cur);
                stack.push(null);
            } else {
                cur = stack.pop();
                // 处理节点逻辑
                TreeNode tempNode = cur.left;
                cur.left = cur.right;
                cur.right = tempNode;
            }
        }
        return root;
    }
}
```



**广度优先遍历**

```java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if(root == null) return root;
        Queue<TreeNode> seen = new LinkedList<>();
        seen.offer(root);
        while(!seen.isEmpty()) {
            int currentLevelSize = seen.size();
            for(int i = 0; i < currentLevelSize; i++) {
                TreeNode cur = seen.poll();
                TreeNode tempNode = cur.left;
                cur.left = cur.right;
                cur.right = tempNode;
                if(cur.left != null) {
                    seen.offer(cur.left);
                }
                if(cur.right != null) {
                    seen.offer(cur.right);
                }
            }
        }
        return root;
    }
}
```

## 七、对称二叉树

### 101、对称二叉树

#### 题目

题目链接：**[101. 对称二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/symmetric-tree/)**

给你一个二叉树的根节点 `root` ， 检查它是否轴对称。

**示例 1：**

![img](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/symtree1.jpg)

```
输入：root = [1,2,2,3,4,4,3]
输出：true
```

**示例 2：**

![img](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/symtree2-16718438677105.jpg)

```
输入：root = [1,2,2,null,3,null,3]
输出：false
```

**提示：**

- 树中节点数目在范围 `[1, 1000]` 内
- `-100 <= Node.val <= 100`

#### 思路

首先想清楚，判断对称二叉树要比较的是那两个节点，要比较的可不是左右节点！

对于二叉树是否对称，要比较的是根结点的左子树和右子树是否是相互翻转的，理解这一点就知道了其实我们要比较的是两棵树（根结点的左右子树），所以在递归遍历的时候，也是要同时遍历两棵树

**比较的是两颗子树的里侧和外侧是否相等**

![image-20221224091409762](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20221224091409762.png)

**遍历顺序**

本题只能是**后序遍历**，因为我们要递归函数的返回值来判断两颗子树的内侧节点和外侧节点是否相等

正是因为要遍历两棵树而且是要比较内侧和外侧节点，所以准确的来说是其中一棵树的遍历顺序是**左右中**，另一棵树的遍历顺序是**右左中**

> 上述两种遍历方式都可以理解成后序遍历，尽管已经不是严格上的在一棵树上进行遍历的后序遍历
>
> 其实后序也可以理解成一种回溯

##### （1）递归法

递归三部曲：

1. 确定递归函数的参数以及返回值
   因为要比较的是根结点的两颗子树是否是可以相互翻转的，进而判断这两颗树是否是对称树，所以要比较的是这两棵树，参数自然也是左子树节点和右子树节点
   返回值自然是`boolean`类型

   ```java
   boolean compare(TreeNode left, TreeNode right);
   ```

2. 确定终止条件
   要比较两个节点数值相不相同，首先要把两个节点为空的情况搞清楚，否侧后面操作数值的时候就会NPE了

   节点为空的情况有：

   - 左节点为空，右节点不为空，不对称 => `return false`
   - 左节点不为空，右节点为空，不对称  => `return false`
   - 左右节点都为空，对称 => `return true`

   节点不为空的情况，比较节点数值，不相同 => `return false`

   ```java
   // 空节点的情况
   // 1.左右节点都为空
   if(left == null && right == null) return true;
   // 2.左右节点只有一个为空
   if(left == null || right == null) return false;
   // 数值不相等的情况
   if(left.val != right.val) return false;
   ```

3. 单层递归的逻辑

   单层递归的逻辑就是处理左右节点都不为空，且数值相同的情况

   - 比较二叉树外侧是否对称：传入的是左子树的左节点和右子树的右节点
   - 比较内侧是否对称：传入的是左子树的右节点和右子树的左节点
   - 如果内侧和外侧都对称就`return true`，只要有一侧不对称就`return false`

   ```java
   // 左右节点都不为空，数值相等的情况
   // 外侧：左子树的左节点， 右子树的右节点
   boolean outside = compare(left.left, right.right);
   // 内侧：左子树的右节点， 右子树的左节点
   boolean inside = compare(left.right, right.left);
   // 返回true的情况是 外侧和内侧都要对称
   return outside && inside;
   ```

##### (2) 迭代法

> 本题也可以使⽤迭代法，但要注意，这⾥的迭代法可不是前中后序的迭代写法，因为本题的本质是判断两个树是否是相互翻转的，其实已经不是所谓⼆叉树遍历的前中后序的关系了

**使用队列**

具体动画演示：**[「代码随想录」101. 对称二叉树:【递归法】【迭代法】详解！ - 对称二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/symmetric-tree/solution/101-dui-cheng-er-cha-shu-di-gui-fa-die-dai-fa-xian/)**

**使用栈**

和使用队列同理，迭代法其实就是把左右子树要比较的元素按照顺序存入一个容器，然后成对的取出来比较

#### 实现

##### （1）递归法

Java代码

```java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if(root == null) return true;
        return compare(root.left, root.right);
    }
    private boolean compare(TreeNode left, TreeNode right) {
        // 空节点的情况
        // 1.左右节点都为空
        if(left == null && right == null) return true;
        // 2.左右节点只有一个为空
        if(left == null || right == null) return false;
        // 数值不相等的情况
        if(left.val != right.val) return false;
        // 左右节点不空并且数值相等
        return compare(left.left, right.right) && compare(left.right, right.left);
    }
}
```

##### （2）迭代法

**使用队列**

```java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if(root == null) return true;
        Queue<TreeNode> queue = new LinkedList<>();
        // 加入根结点的左右节点
        queue.offer(root.left);
        queue.offer(root.right);
        // 判断两颗子树是否相互翻转
        while(!queue.isEmpty()) {
            TreeNode leftNode = queue.poll();
            TreeNode rightNode = queue.poll();
            // 左右节点都为空
            if(leftNode == null && rightNode == null) continue;
            // 左右节点有一个不空 或者 数值不等
            if(leftNode == null || rightNode == null || leftNode.val != rightNode.val) return false;

            // 判断外侧
            queue.offer(leftNode.left);
            queue.offer(rightNode.right);
            // 判断内侧
            queue.offer(leftNode.right);
            queue.offer(rightNode.left);
        }
        return true;
    }
}
```

**使用栈**

相较于使用栈，仅仅换了一个容器和对应API

```java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if(root == null) return true;
        Deque<TreeNode> stack = new LinkedList<>();
        // 加入根结点的左右节点
        stack.push(root.left);
        stack.push(root.right);
        // 判断两颗子树是否相互翻转
        while(!stack.isEmpty()) {
            TreeNode leftNode = stack.pop();
            TreeNode rightNode = stack.pop();
            // 左右节点都为空
            if(leftNode == null && rightNode == null) continue;
            // 左右节点有一个不空 或者 数值不等
            if(leftNode == null || rightNode == null || leftNode.val != rightNode.val) return false;

            // 判断外侧
            stack.push(leftNode.left);
            stack.push(rightNode.right);
            // 判断内侧
            stack.push(leftNode.right);
            stack.push(rightNode.left);
        }
        return true;
    }
}
```

## 八、二叉树的深度

### 104、二叉树的最大深度

#### 题目

题目链接：**[104. 二叉树的最大深度 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)**

给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

**说明:** 叶子节点是指没有子节点的节点。

**示例：**
给定二叉树 `[3,9,20,null,null,15,7]`，

```
    3
   / \
  9  20
    /  \
   15   7
```

返回它的最大深度 3 。

#### 思路

##### （1）递归法

本题依然是要后序遍历，因为要通过递归函数的返回值来计算树的高度

递归三部曲：

1. 确定递归函数的参数和返回值

   参数就是传入树的根结点，返回就是这棵树的深度，所以返回值为`int`类型

   ```java
   int getDepth(TreeNode cur);
   ```

2. 确定终止条件

   如果当前为空节点的话，就返回0，表示高度为0

   ```java
   if(cur == null) return 0;
   ```

3. 确定单层递归的逻辑

   先求它的左子树的深度，再求它的右子树的深度，最后取左右子树的较大深度数值再加一（加一是因为算上当前中间的节点）就是以当前节点为根结点的树的深度

   ```java
   int leftDepth = maxDepth(root.left);
   int rightDepth = maxDepth(root.right);
   int curDepth = Math.max(leftDepth, rightDepth) + 1;
   return curDepth;
   ```

##### （2）迭代法

使用迭代法的话，使用层序遍历是最合适的，因为最大的深度就是二叉树的层数，和层序遍历的方式及其相似

在⼆叉树中，⼀层⼀层的来遍历⼆叉树，记录⼀下遍历的层数就是⼆叉树的深度，如图所示：

![二叉树的层序遍历](E:/MyFile/TyporaImgs/ce41cf1cabfa7a56387f63d927c8819fe1479ecf6f193a2a1b47964f5a8d1c8e-16718480808477.jpg)

所以这道题的迭代法就是⼀道模板题，可以使⽤⼆叉树层序遍历的模板来解决的。

#### 实现

##### （1）递归法

```java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root == null) return 0;
        return Math.max(maxDepth(root.left),maxDepth(root.right)) + 1;
    }
}
```

##### （2）迭代法

```java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root == null) return 0;
        Queue<TreeNode> seen = new LinkedList<>();
        seen.offer(root);
        int depth = 0;
        while(!seen.isEmpty()) {
            int currentLevelSize = seen.size();
            depth++;
            for(int i = 0; i < currentLevelSize; i++) {
                TreeNode cur = seen.poll();
                if(cur.left != null) seen.offer(cur.left);
                if(cur.right != null) seen.offer(cur.right);
            }
        }
        return depth;
    }
}
```

##### （3）栈模拟后序遍历

```java
class Solution {
    public int maxDepth(TreeNode root) {
         if(root == null) return 0;
        Deque<TreeNode> stack = new LinkedList<>();
        stack.push(root);
        int depth = 0;
        int ans = 0;
        while(!stack.isEmpty()) {
            TreeNode cur = stack.pop();
            if(cur != null) {
                // 中
                stack.push(cur);
                stack.push(null);
                depth++;
                // 右
                if(cur.right != null) stack.push(cur.right);
                // 左
                if(cur.left != null) stack.push(cur.left);
            } else {
                cur = stack.pop();
                depth--;
            }
            ans = ans > depth ? ans : depth;
        }
        return ans;
    }
}
```



### 559、N叉树的最大深度

#### 题目

题目链接：**[559. N 叉树的最大深度 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/)**

给定一个 N 叉树，找到其最大深度。

最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。

N 叉树输入按层序遍历序列化表示，每组子节点由空值分隔（请参见示例）。

**示例 1：**

![img](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/narytreeexample-16718483757259.png)

```
输入：root = [1,null,3,2,4,null,5,6]
输出：3
```

**示例 2：**

![img](E:/MyFile/TyporaImgs/sample_4_964-167184839720711.png)

```
输入：root =[1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
输出：5
```

**提示：**

- 树的深度不会超过 `1000` 。
- 树的节点数目位于 `[0, 10^4]` 之间。

#### 思路

思路跟二叉树的思路是一样的

##### （1）递归法

##### （2）迭代法

#### 实现

##### （1）递归法

```java
class Solution {
    public int maxDepth(Node root) {
        if(root == null) return 0;
        int depth = 0;
        for(int i = 0; i < root.children.size(); i++) {
            depth = Math.max(depth, maxDepth(root.children.get(i)));
        }
        return depth + 1;
    }
}
```



##### （2）迭代法

```java
class Solution {
    public int maxDepth(Node root) {
         if(root == null) return 0;
        Queue<Node> seen = new LinkedList<>();
        seen.offer(root);
        int depth = 0;
        while(!seen.isEmpty()) {
            int currentLevelSize = seen.size();
            depth++;
            for(int i = 0; i < currentLevelSize; i++) {
                Node cur = seen.poll();
                for(int j = 0; j < cur.children.size(); j++) {
                    Node node = cur.children.get(j);
                    if(node != null) seen.offer(node);
                }
            }
        }
        return depth;
    }
}
```

---

### 111、二叉树的最小深度

#### 题目

题目链接：**[111. 二叉树的最小深度 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)**

给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

**说明：**叶子节点是指没有子节点的节点。

 

**示例 1：**

![img](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/ex_depth.jpg)

```
输入：root = [3,9,20,null,null,15,7]
输出：2
```

**示例 2：**

```
输入：root = [2,null,3,null,4,null,5,null,6]
输出：5
```

**提示：**

- 树中节点数的范围在 `[0, 10^5]` 内
- `-1000 <= Node.val <= 1000`

#### 思路

> 本题处理直觉上和**[104. 二叉树的最大深度 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)**差不多，但其实还是差不少的

遍历顺序上依然是后序遍历，因为要比较递归函数返回的结果，但在处理中间结点的逻辑上，最大深度很容易理解，最小深度存在一个误区，

![image-20221224104319753](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20221224104319753.png)

这里就要重新审题了，题目中说的是：**最小深度是从根节点到最近叶子节点的最短路径上的节点数量。**，注意是叶子结点

##### （1）递归法

递归三部曲

1. 确定递归函数的参数和返回值

   参数为要传入的二叉树根结点，返回值是`int`类型的深度

   ```java
   int minDepth(TreeNode cur);
   ```

2. 确定终止条件

   确定终止条件也是遇到空节点返回0，表示当前节点的高度为0

   ```java
   if(cur == null) return 0;
   ```

3. 确定单层递归的逻辑

   > 这里和求最大深度就不一样了。
   >
   > ```java
   > int leftDepth = getDepth(cur.left);
   > int rightDepth = getDepth(cur.right);
   > int result = 1 + Math.min(leftDepth, rightDepth);
   > return result;
   > ```
   >
   > 上述代码就犯了上图中的误区
   >
   > 如果这么求的话，没有左孩⼦的分⽀会算为最短深度

   如果左子树为空，右子树不空，说明最小深度是 `1 + 右子树的深度`

   反之右子树为空，左子树不空，说明最小深度是 `1 + 左子树的深度`

   如果左子树和右子树都不空，说明最小深度是`1 + 左右子树深度的较小值`

   ```java
    // 中
   // 左子树为空，右子树不空
   if(root.left != null && root.right == null) {
       return 1 + leftDepth;
   }
   // 左子树为空，右子树不空
   if(root.left == null && root.right != null) {
       return 1 + rightDepth;
   }
   // 左右子树都不空
   return Math.min(leftDepth, rightDepth) + 1;
   ```

   遍历的顺序为后序（左右中），可以看出：**求⼆叉树的最⼩深度和求⼆叉树的最⼤深度的差 别主要在于处理左右孩⼦不为空的逻辑**

##### （2）迭代法

层序遍历，需要注意的是，只有当左右节点都为空时，才说明遍历到最低点了，如果其中一个节点不为空，则说明不是最低点

#### 实现

##### （1）递归法

```java
class Solution {
    public int minDepth(TreeNode root) {
        if (root == null) return 0; 
        // 中
        // 左子树为空，右子树不空
        if(root.left != null && root.right == null) {
            return 1 + minDepth(root.left); 
        }
        // 左子树为空，右子树不空
        if(root.left == null && root.right != null) {
            return 1 + minDepth(root.right);
        }
        // 左右子树都不空
        return Math.min(minDepth(root.left), minDepth(root.right)) + 1;
    }
}
```

##### （2）迭代法

```java
class Solution {
    public int minDepth(TreeNode root) {
        if (root == null) return 0; 
        int depth = 0;
        Queue<TreeNode> seen = new LinkedList<>();
        seen.offer(root);
        while(!seen.isEmpty()) {
            int currentLevelSize = seen.size();
            depth++; // 记录最小深度
            for(int i = 0; i < currentLevelSize; i++) {
                TreeNode cur = seen.poll();
                if(cur.left != null) seen.offer(cur.left);
                if(cur.right != null) seen.offer(cur.right);
                // 左右节点都为空
                if(cur.left == null && cur.right == null) return depth;
            }
        }
        return depth;
    }
}
```

## 九、完全二叉树的节点个数

### 222、完全二叉树的节点个数

#### 题目

题目链接：**[222. 完全二叉树的节点个数 - 力扣（LeetCode）](https://leetcode.cn/problems/count-complete-tree-nodes/)**

给你一棵 **完全二叉树** 的根节点 `root` ，求出该树的节点个数。

[完全二叉树](https://baike.baidu.com/item/完全二叉树/7773232?fr=aladdin) 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 `h` 层，则该层包含 `1~ 2^h` 个节点。

**示例 1：**

![img](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/complete.jpg)

```
输入：root = [1,2,3,4,5,6]
输出：6
```

**示例 2：**

```
输入：root = []
输出：0
```

**示例 3：**

```
输入：root = [1]
输出：1
```

**提示：**

- 树中节点的数目范围是`[0, 5 * 10^4]`
- `0 <= Node.val <= 5 * 10^4`
- 题目数据保证输入的树是 **完全二叉树**

#### 思路

本题按照**普通二叉树**的求法和利用**完全二叉树**性质求解

#####  1）普通二叉树

> 本题的递归法和求二叉树的深度写法类似
>
> 迭代法和层序遍历相似，遍历模板稍稍修改，记录遍历结点的数量就可以了

**（1）递归法**

递归三部曲：

1. 确定递归函数的参数以及返回值类型：参数就是传入树的根结点，返回就是以该节点为根结点的二叉树的节点数量，所以返回值类型为`int`

   ```java
   int getNodesNum(TreeNode cur);
   ```

2. 确定终止条件：如果遇到空节点，就返回0，表示节点数为0

   ```java
   if(cur == null) return 0;
   ```

3. 确定单层递归的逻辑：先求以当前节点为根结点的树的左子树的节点数量，再求右子树的节点数量，最后取总和再加一（加一是因为要算上当前节点）就是以当前节点为根结点的节点数量

   ```java
   int leftNum = getNodesNum(cur.left); // 左
   int rightNum = getNodesNum(cur.right); // 右
   return leftNum + rightNum + 1; // 中
   ```

**（2）迭代法**

在模板遍历的基础上，加一个变量统计节点数量即可

##### 2）完全二叉树

完全二叉树只有两种情况

- 情况一：满二叉树
- 情况二：最后一层叶子结点没有满

针对情况一：可以直接使用`2 ^ 树深度 - 1`来计算，注意这里根结点深度为1

针对情况二：分别递归左子树和右子树，递归到某一深度一定会有左子树或者右子树为满二叉树，然后依然可以按照情况一来计算

![image-20221225102432115](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20221225102432115.png)

![image-20221225102713034](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20221225102713034.png)

可以看出如果整个树不是满二叉树，就递归左右子树直到遇到满二叉树为止，用公式计算这个子树（满二叉树）的节点数量

#### 实现

##### 1)  普通二叉树

 **（1）递归法**

```java
// 时间复杂度：O(n)
// 空间复杂度：O(logn)，算上了递归系统栈占⽤的空间
class Solution {
    public int countNodes(TreeNode root) {
        if(root == null) return 0;
        return getNodesNum(root);
    }

    private int getNodesNum(TreeNode cur) {
        if(cur == null) return 0;
        int leftNum = getNodesNum(cur.left); // 左
        int rightNum = getNodesNum(cur.right); // 右
        return leftNum + rightNum + 1; // 中
    }
}
```

精简版：

```java
// 时间复杂度：O(n)
// 空间复杂度：O(logn)，算上了递归系统栈占⽤的空间
class Solution {
    public int countNodes(TreeNode root) {
        if(root == null) return 0;
        return 1 + countNodes(root.left) + countNodes(root.right);
    }
}
```

**（2）迭代法**

```java
// 时间复杂度：O(n)
// 空间复杂度：O(n)
class Solution {
    public int countNodes(TreeNode root) {
        if(root == null) return 0;
        Queue<TreeNode> seen = new LinkedList<>();
        seen.offer(root);
        int result = 0;
        while(!seen.isEmpty()) {
            int currentLevelSize = seen.size();
            for(int i = 0; i < currentLevelSize; i++) {
                TreeNode cur = seen.poll();
                result++; // 记录节点数量
                if(cur.left != null) {
                    seen.offer(cur.left);
                }
                if(cur.right != null) {
                    seen.offer(cur.right);
                }
            }
        }
        return result;
    }
}
```

##### 2）完全二叉树

```java
// 时间复杂度：O(logn * logn)
// 空间复杂度：O(logn)
class Solution {
    public int countNodes(TreeNode root) {
        if(root == null) return 0;
        TreeNode left = root.left;
        TreeNode right = root.right;
        // 这里初始化为0是为了下面求指数方便
        int leftHight = 0;
        int rightHight = 0;
        // 求左子树深度
        while(left != null) {
            left = left.left;
            leftHight++;
        }
        // 求右子树深度
        while(right != null) {
            right = right.right;
            rightHight++;
        }
        if(leftHight == rightHight) {
            return (2 << leftHight) - 1;
        }
        return countNodes(root.left) + countNodes(root.right) + 1;
    }
}
```

## 十、平衡二叉树

### 110、平衡二叉树

#### 题目

题目链接：**[110. 平衡二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/balanced-binary-tree/)**

给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：一个二叉树*每个节点* 的左右两个子树的高度差的绝对值不超过 1 。

**示例 1：**

![img](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/balance_1.jpg)

```
输入：root = [3,9,20,null,null,15,7]
输出：true
```

**示例 2：**

![img](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/balance_2.jpg)

```
输入：root = [1,2,2,3,3,null,null,4,4]
输出：false
```

**示例 3：**

```
输入：root = []
输出：true
```

**提示：**

- 树中的节点数在范围 `[0, 5000]` 内
- `-10^4 <= Node.val <= 10^4`

#### 思路

> 强调一波**概念**
>
> - 二叉树节点的深度：指从根结点到该节点的最长简单路径边的条数
> - 二叉树节点的高度：指从该节点到叶子结点的最长简单路径边的条数
>
> ![image-20221225104213834](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20221225104213834.png)
>
> 因为求深度可以从上到下去查，所以需要前序遍历（中左右），而高度只能从下到上去查，所以只能后序遍历（左右中）
>
> 至于在**[104. 二叉树的最大深度 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)**中求的是二叉树的最大深度，也是使用后序遍历，是因为**代码逻辑其实是求的根结点的高度，而根结点的高度就是这棵树的最大深度，所以才可能使用后序遍历**
>
> 在**[104. 二叉树的最大深度 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)**中，如果真正求取二叉树的最大深度，代码应该写成如下（前序遍历）
>
> ```java
> class Solution {
>     private int result;
>     private void getDepth(TreeNode node, int depth) {
>         result = depth > result ? depth : result; // 中
>         if (node.left == null && node.right == null) return ;
>         if (node.left) { // 左
>             depth++; // 深度+1
>             getDepth(node.left, depth);
>             depth--; // 回溯，深度-1
>         }
>         if (node.right) { // 右
>             depth++; // 深度+1
>             getDepth(node.right, depth);
>             depth--; // 回溯，深度-1
>         }
>         return ;
>     }
>     public int maxDepth(TreeNode root) {
>         result = 0;
>         if (root == null) return result;
>         getDepth(root, 1);
>         return result;
>     }
> };
> ```
>
> 可以看出使用了前序遍历顺序，这才是真正求深度的逻辑！
>
> 简化下上述代码
>
> ```java
> class Solution {
>     private int result;
>     private void getDepth(TreeNode node, int depth) {
>         result = depth > result ? depth : result; // 中
>         if (node.left == null && node.right == null) return ;
>         if (node.left) { // 左
>             getDepth(node.left, depth + 1);
>         }
>         if (node.right) { // 右
>             getDepth(node.right, depth + 1);
>         }
>         return ;
>     }
>     int maxDepth(TreeNode root) {
>         result = 0;
>         if (root == null) return result;
>         getDepth(root, 1);
>         return result;
>     }
> };
> ```

##### 1）递归

既然要比较高度，必然是后序遍历

递归三部曲：

1. 确定递归函数的参数和返回值

   参数为传入的节点指针，返回值要返回以传入节点为根结点的树的高度

   那么如何标记左右子树的高度是否差值为1呢？

   如果以当前传入节点为根结点的二叉树已经不是二叉树了，还返回高度的话就没有意义了，所以如果已经不是平衡二叉树了，可以返回`-1`来标识以当前传入节点为根结点的树已经不符合平衡树的规则了

   ```java
   // -1 表示已经不是平衡⼆叉树了，否则返回值是以该节点为根节点树的⾼度
   int getDepth(TreeNode cur);
   ```

2. 确定终止条件

   递归过程中遇到空节点为终止，返回0，表示以当前节点为根结点的树的高度为0

   ```java
   if(cur == null) return 0;
   ```

3. 确定单层递归的逻辑

   分别求出以当前节点为根结点的树的左右子树的高度，如果差值小于等于1，则返回当前二叉树的高度，否则返回-1，表示不是平衡二叉树了

   ```java
   int leftDepth = getDepth(node.left); // 左
   if (leftDepth == -1) return -1;
   int rightDepth = getDepth(node.right); // 右
   if (rightDepth == -1) return -1;
   int result;
   if (Math.abs(leftDepth - rightDepth) > 1) { // 中
    	result = -1;
   } else {
    	result = 1 + Math.max(leftDepth, rightDepth); // 以当前节点为根节点的最⼤⾼度
   }
   return result;
   ```

   精简代码：

   ```java
   int leftDepth = getDepth(node.left);
   if (leftDepth == -1) return -1;
   int rightDepth = getDepth(node.right);
   if (rightDepth == -1) return -1;
   return Math.abs(leftDepth - rightDepth) > 1 ? -1 : 1 + Math.max(leftDepth,
   rightDepth);
   ```

##### 2）迭代法

> 在**[104. 二叉树的最大深度 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)**中我们可以使用层序遍历求深度，但是就不能使用层序遍历来求高度，这就体现出求高度和求深度是不同的

本题的迭代方式可以先定义一个函数，专门用来求高度

这个函数通过栈模拟后序遍历找每一个节点的高度（其实是通过求以传入节点为根结点的树的最大深度来求的高度）

```java
// cur节点的最⼤深度，就是cur的⾼度
private int getDepth(TreeNode cur) {
    Deque<TreeNode> stack = new LinkedList<>();
    if(cur != null) stack.push(cur);
    int depth = 0; // 记录深度
    int result = 0;
    while(!stack.isEmpty()) {
        TreeNode node = stack.pop();
        if (node != null) {
            stack.push(node); // 中
            stack.push(null);
            depth++;
            if (node.right != null) stack.push(node.right); // 右
            if (node.left != null) stack.push(node.left); // 左
        } else {
            node = stack.pop();
            depth--;
        }
        result = result > depth ? result : depth;
    }
    return result;
}
```

然后再用栈来模拟前序遍历，遍历每一个节点的时候，再去判断左右子树的高度是否符合

```java
public boolean isBalanced(TreeNode root) {
    if(root == null) return true;
    Deque<TreeNode> stack = new LinkedList<>();
    stack.push(root);
    while (!stack.isEmpty()) {
        TreeNode node = stack.pop(); // 中
        if (Math.abs(getDepth(node.left) - getDepth(node.right)) > 1) { // 判断左右子树⾼度是否符合
            return false;
        }
        if (node.right != null) stack.push(node.right); // 右（空节点不⼊栈）
        if (node.left != null) stack.push(node.left); // 左（空节点不⼊栈）
    }
    return true;
}
```



#### 实现

##### 1）递归法

```java
class Solution {
    public boolean isBalanced(TreeNode root) {
        return getDepth(root) == -1 ? false : true;
    }
    private int getDepth(TreeNode cur) {
        if(cur == null) return 0;
        int leftDepth = getDepth(cur.left);
        if(leftDepth == -1) return leftDepth;
        int rightDepth = getDepth(cur.right);
        if(rightDepth == -1) return rightDepth;
        return Math.abs(leftDepth - rightDepth) > 1 ? -1 : 1 + Math.max(leftDepth, rightDepth);
    }
}
```

##### 2）迭代法

```java
class Solution {
    public boolean isBalanced(TreeNode root) {
        if(root == null) return true;
        Deque<TreeNode> stack = new LinkedList<>();
        stack.push(root);
        while (!stack.isEmpty()) {
            TreeNode node = stack.pop(); // 中
            if (Math.abs(getDepth(node.left) - getDepth(node.right)) > 1) { // 判断左右子树⾼度是否符合
                return false;
            }
            if (node.right != null) stack.push(node.right); // 右（空节点不⼊栈）
            if (node.left != null) stack.push(node.left); // 左（空节点不⼊栈）
        }
        return true;
    }

    private int getDepth(TreeNode cur) {
        Deque<TreeNode> stack = new LinkedList<>();
        if(cur != null) stack.push(cur);
        int depth = 0; // 记录深度
        int result = 0;
        while(!stack.isEmpty()) {
            TreeNode node = stack.pop();
            if (node != null) {
                stack.push(node); // 中
                stack.push(null);
                depth++;
                if (node.right != null) stack.push(node.right); // 右
                if (node.left != null) stack.push(node.left); // 左
            } else {
                node = stack.pop();
                depth--;
            }
            result = result > depth ? result : depth;
        }
        return result;
    }
}
```

> 当然此题⽤迭代法，其实效率很低，因为没有很好的模拟回溯的过程，所以迭代法有很多重复的计算。 虽然理论上所有的递归都可以⽤迭代来实现，但是有的场景难度可能⽐较⼤。 例如：都知道**回溯法其实就是递归**，但是很少⼈⽤迭代的⽅式去实现回溯算法！ 因为对于回溯算法已经是⾮常复杂的递归了，如果在⽤迭代的话，就是⾃⼰给⾃⼰找⿇烦， 效率也并不⼀定⾼。

## 十一、二叉树的所有路径

### 257、二叉树的所有路径

#### 题目

题目链接：**[257. 二叉树的所有路径 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-paths/)**

给你一个二叉树的根节点 `root` ，按 **任意顺序** ，返回所有从根节点到叶子节点的路径。

**叶子节点** 是指没有子节点的节点。

 

**示例 1：**

![img](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/paths-tree.jpg)

```
输入：root = [1,2,3,null,5]
输出：["1->2->5","1->3"]
```

**示例 2：**

```
输入：root = [1]
输出：["1"]
```

**提示：**

- 树中节点的数目在范围 `[1, 100]` 内
- `-100 <= Node.val <= 100`

#### 思路

本题要求从根结点到叶子的路径，所以需要前序遍历，这样才方便让父结点指向子节点，找到对应的路径

在这道题中第一次涉及到**回溯**，因为我们需要把路径记录下来，需要回溯来回退一个路径再进入另一个路径

前序遍历以及回溯的过程如图：

![image-20221225135255818](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20221225135255818.png)

先使用递归的方式，先做前序遍历，**递归和回溯是一家**

##### 1）递归

递归三部曲：

1. 确定递归函数的参数以及返回值

   参数就是传入的根结点，记录每一条的路径的`path`，和存放结果集的`result`，这里递归不需要返回值

   ```java
   void traversal(TreeNode cur, List<Integer> path, List<String> result);
   ```

2. 确定递归终止条件

   遇到空节点，进行终止处理逻辑

   ```java
   if(cur == null) {
       // 终止处理逻辑
   }
   ```

   但是本题终止条件这样写会很麻烦，因为本题需要找到叶子节点，就开始进行终止的处理逻辑了（把结果存入结果集`result`）

   **找到叶子结点的时机**：当`cur`不空，其左右节点都为空时

   ```java
   if(cur.left == null && cur.right == null) {
       // 终止处理逻辑
   }
   ```

   > 为什么不用判断`cur `是否为空呢？ 因为下面的逻辑可以保证空节点不进入循环

   终止处理逻辑：

   使用`List<Integer>`集合`path`来记录路径，所以需要把`List<Integer>`集合`path`转成`String`类型存入结果集`List<String>`

   ```java
   if(cur.left == null && cur.right == null) {
       // 终止处理逻辑
       StringBuilder sPath = new StringBuilder();
       // 将path里记录的路径转成String格式
       for(int i = 0; i < path.size() - 1; i++) {
           sPath.append(path.get(i) + "->");
       }
       // 记录最后一个节点（叶子结点）
       sPath.append(path.get(path.size() - 1).toString());
       result.add(sPath);
       return;    
   }
   ```

3. 确定单层处理的逻辑

   因为是前序遍历，需要先处理中间结点，中间结点是要记录在路径上的节点，先存入`path`

   `path.add(cur.val)`

   然后是递归和回溯的过程，上面说过没有判断`cur ?= null`，那么在这里递归的时候，如果为空，就不进行下一层递归了

   所以在递归前要加上判断语句，下面要递归的节点是否为空

   ```java
   if(cur.left != null) {
        traversal(cur.left, path, result);
   }
   if(cur.right != null) {
       traversal(cur.righr, path, result);
   }
   ```

   此时还没有结束，递归结束，还需要回溯，因为`path`不能一直加入节点，还需要删除结点，然后才能加入新的节点

   > 错误回溯过程：
   >
   > ```java
   > if(cur.left != null) {
   >      traversal(cur.left, path, result);
   > }
   > if(cur.right != null) {
   >     traversal(cur.righr, path, result);
   > }
   > path.remove(path.size() - 1);
   > ```
   >
   > 这个回溯存在很大的问题！！！
   >
   > 回溯和递归是一一对应的，有一个递归，就要有一个回溯，这么写的话就相当于把递归和回溯拆开了，一个在花括号里，一个在花括号外

   正确回溯过程：

   ```java
   if(cur.left != null) {
       traversal(cur.left, path, result);
       path.remove(path.size() - 1); // 回溯
   }
   if(cur.right != null) {
       traversal(cur.righr, path, result);
       path.remove(path.size() - 1); // 回溯
   }
   ```

##### 2） 迭代法

⾄于⾮递归的⽅式，我们可以依然可以使⽤前序遍历的迭代⽅式来模拟遍历路径的过程，这里除了模拟递归需要一个栈，同时还需要一个栈来存放对应的遍历路径



#### 实现

##### 1）递归

```java
class Solution {
    public List<String> binaryTreePaths(TreeNode root) {
        List<String> result = new ArrayList<>();
        List<Integer> path = new ArrayList<>();
        traversal(root, path, result);
        return result;
    }

    private void traversal(TreeNode cur, List<Integer> path, List<String> result) {
        path.add(cur.val);
        // 找到了叶子结点
        if(cur.left == null && cur.right == null) {
            StringBuilder sPath = new StringBuilder();
            for(int i = 0; i < path.size() - 1; i++) {
                sPath.append(path.get(i) + "->");
            }
            // 处理叶子结点
            sPath.append(path.get(path.size() - 1));
            result.add(sPath.toString());
        }
        if(cur.left != null) {
            traversal(cur.left, path, result);
            path.remove(path.size() - 1);
        }
        if(cur.right != null) {
            traversal(cur.right, path, result);
            path.remove(path.size() - 1);
        }
    }
}
```

精简代码：

```java
class Solution {
    public List<String> binaryTreePaths(TreeNode root) {
        List<String> result = new ArrayList<>();
        String sPath = new String();
        traversal(root, sPath, result);
        return result;
    }

    private void traversal(TreeNode cur, String sPath, List<String> result) {
        sPath += cur.val; // 中间结点
        // 找到了叶子结点
        if(cur.left == null && cur.right == null) {
            result.add(sPath);
            return;
        }
        if(cur.left != null) {
            traversal(cur.left, sPath + "->", result);
        }
        if(cur.right != null) {
            traversal(cur.right, sPath + "->", result);
        }
    }
}
```

> 那么在如上代码中，貌似没有看到回溯的逻辑，其实不然，回溯就隐藏在`traversal(cur.left, path + "->", result)`;中的` path + "->"`。 每次函数调⽤完，`path`依然是没有加 上`"->"` 的，这就是**回溯**了

##### 2）迭代法

```java
class Solution {
    public List<String> binaryTreePaths(TreeNode root) {
        Deque<TreeNode> treeStack = new LinkedList<>(); // 保存树的遍历结点
        Deque<String> pathStack = new LinkedList<>(); // 保存遍历路径的节点
        List<String> result = new ArrayList<>(); // 保存最终路径的集合
        if(root == null) return result;
        treeStack.push(root);
        pathStack.push(String.valueOf(root.val));
        while(!treeStack.isEmpty()) {
            TreeNode cur = treeStack.pop(); // 中
            String path = pathStack.pop();
            // 遇到叶子结点
            if(cur.left == null && cur.right == null) {
                result.add(path);
            }
            // 右
            if(cur.right != null) {
                treeStack.push(cur.right);
                pathStack.push(path + "->" + cur.right.val);
            }
            // 左
            if(cur.left != null) {
                treeStack.push(cur.left);
                pathStack.push(path + "->" + cur.left.val);
            }
        }
        return result;
    }
}
```

**补充**

```java
class Solution {
    public List<String> binaryTreePaths(TreeNode root) {
        List<String> paths = new ArrayList<String>();
        constructPaths(root, "", paths);
        return paths;
    }

    public void constructPaths(TreeNode root, String path, List<String> paths) {
        if (root != null) {
            StringBuffer pathSB = new StringBuffer(path);
            pathSB.append(Integer.toString(root.val));
            if (root.left == null && root.right == null) {  // 当前节点是叶子节点
                paths.add(pathSB.toString());  // 把路径加入到答案中
            } else {
                pathSB.append("->");  // 当前节点不是叶子节点，继续递归遍历
                constructPaths(root.left, pathSB.toString(), paths);
                constructPaths(root.right, pathSB.toString(), paths);
            }
        }
    }
}
```



## 十二、左叶子之和

### 404、左叶子之和

给定二叉树的根节点 `root` ，返回所有左叶子之和。

**示例 1：**

![img](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/leftsum-tree.jpg)

```
输入: root = [3,9,20,null,null,15,7] 
输出: 24 
解释: 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24
```

**示例 2:**

```
输入: root = [1]
输出: 0
```

**提示:**

- 节点数在 `[1, 1000]` 范围内
- `-1000 <= Node.val <= 1000`

#### 思路

首先要注意判断是**左叶子**，而不是**二叉树的左侧节点**，因此不要想当然的使用层序遍历

**左叶子的明确定义**：如果左节点不为空，且左结点没有左右孩子，那么这个结点就是左叶子

下图中的左叶子之和是多少？

![image-20221226075133692](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20221226075133692.png)

其实是0，因为这棵树根本没有左叶子！

那么**判断当前节点是不是左叶子是无法判断的，必须要通过节点的父结点来判断其左孩子是不是左叶子**

=> 如果该节点的左节点不为空，并且该节点的左节点的左节点为空，该节点的左节点的右节点为空，则找到一个左叶子

```java
if(cur.left != null && cur.left.left != null && cur.left.right == null) {
    // 左叶子节点处理逻辑
}
```

##### 1）递归法

递归的遍历顺序为后序遍历，是因为要通过递归函数的返回值来累加求取左叶子的数值之和

递归三部曲：

1. 确定递归函数的参数以及返回值

   要求一棵树的左叶子之和，一定要传入树的根结点，递归函数的返回值为数值之和，所以类型为`int`

   ```java
   // 使用题目中给出的函数即可
   int sumOfLeftLeaves(TreeNode root) {
   
   }
   ```

2. 确定终止条件

   ```java
   if(root == null) return 0;
   ```

3. 确定单层递归的逻辑

   当遇到左叶子节点时，记录数值，然后通过递归求取左子树的左叶子之和，和右子树的左叶子之和，相加便是整棵树的左叶子之和

   ```java
   int leftVal = sumOfLeftLeaves(root.left); // 左子树的左叶子之和
   int rightVal = sumOfLeftLeaves(root.right); // 右子树的左叶子之和
   
   int midVal = 0; // 中
   if(root.left != null && root.left.left == null && root.left.right == null) {
       midVal = root.left.val;
   }
   return leftVal + rightVal + midVal;
   ```

##### 2）迭代法

本题迭代法使用前中后序都是可以的，只要把叶子结点统计起来就可以了

#### 实现

##### 1）递归法

```java
class Solution {
    public int sumOfLeftLeaves(TreeNode root) {
        if(root == null) return 0;
        int leftVal = sumOfLeftLeaves(root.left); // 左子树的左叶子之和
        int rightVal = sumOfLeftLeaves(root.right); // 右子树的左叶子之和

        int midVal = 0; // 中
        if(root.left != null && root.left.left == null && root.left.right == null) {
            midVal = root.left.val;
        }
        return leftVal + rightVal + midVal;
    }
}
```

精简代码

```java
class Solution {
    public int sumOfLeftLeaves(TreeNode root) {
        if(root == null) return 0;
        int midVal = 0; // 中
        if(root.left != null && root.left.left == null && root.left.right == null) {
            midVal = root.left.val;
        }
        return sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right) + midVal;
    }
}
```

##### 2）迭代法

前序遍历

```java
class Solution {
    public int sumOfLeftLeaves(TreeNode root) {
        if(root == null) return 0;
        Deque<TreeNode> stack = new LinkedList<>();
        stack.push(root);
        int result = 0;
        while(!stack.isEmpty()) {
            TreeNode cur = stack.pop();
            if(cur.left != null && cur.left.left == null && cur.left.right == null) {
                result += cur.left.val;
            }
            if(cur.right != null) stack.push(cur.right);
            if(cur.left != null) stack.push(cur.left);
        }
        return result;
    }
}
```

中序遍历

```java
class Solution {
    public int sumOfLeftLeaves(TreeNode root) {
        if(root == null) return 0;
        Deque<TreeNode> stack = new LinkedList<>();
        int result = 0;
        TreeNode cur = root;
        while(cur != null || !stack.isEmpty()) {
            if(cur != null) {
                // 指针遍历
                stack.push(cur);
                cur = cur.left; // 左
            } else {
                // 处理节点
                cur = stack.pop();
                if(cur.left != null && cur.left.left == null && cur.left.right == null) {
                    result += cur.left.val;
                }
                cur = cur.right; // 右
            }
        }
        return result;
    }
}
```

## 十三、树左下角的值

### 513、找树左下角的值

#### 题目

题目链接：**[513. 找树左下角的值 - 力扣（LeetCode）](https://leetcode.cn/problems/find-bottom-left-tree-value/)**

给定一个二叉树的 **根节点** `root`，请找出该二叉树的 **最底层 最左边** 节点的值。

假设二叉树中至少有一个节点。

**示例 1:**

![img](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/tree1-16720139492172.jpg)

```
输入: root = [2,1,3]
输出: 1
```

**示例 2:**

![img](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/tree2.jpg)

```
输入: [1,2,3,4,null,5,6,null,null,7]
输出: 7
```

**提示:**

- 二叉树的节点个数的范围是 `[1,10^4]`
- `-2^31 <= Node.val <= 2^31 - 1` 

#### 思路

> 本题要找出树的最后一行的最左边值，显然使用层序遍历是非常简单的，使用递归方法要困难一点

##### 1）递归法

分析一下题目：**在树的最后一行找到最左边的值**

首先是最后一行，其次是最左边的值

使用递归法，

1. 判断最后一行 => 其实就是深度最大的叶子结点一定是在最后一行 => 找深度最大的叶子结点
2. 找最左边的值 => 可以使用前序遍历，这样才优先在左边搜索，然后记录深度最大的叶子结点，此时就是树的最后一行最左边的值

递归三部曲：

1. 确定递归函数的参数以及返回值

   参数必须要要有遍历的树的根结点，其实就是一个`int`型的变量用来记录最大深度，不需要返回值，所以地府函数的返回值类型为`void`

   本题还需要在类里定义两个全局变量，`maxLen`用来记录最大深度，`maxLeftValue`记录最大深度最左边的数值

   ```java
   int maxLen = Integer.MIN_VALUE; // 记录最大深度
   int minLeftValue = 0; // 记录最大深度最左边的数值
   void traversal(TreeNode cur, int leftLen);
   ```

   > 为什么不能递归函数的返回值返回最大深度呢？
   >
   > 递归函数的返回值：**如果需要遍历整颗树，递归函数就不能有返回值。如果需要遍历某⼀条固定路线，递归函数 就⼀定要有返回值！**

2. 确定终止条件

   当遇到叶子结点的时候，就需要统计下最大的深度了，所以需要与到叶子结点来更新最大深度

   ```java
   if(cur.left == null && cur.right == null) {
       if(leftLen > maxLen) {
           maxLen = leftLen;
           maxLeftValue = cur.val;
       }
       return;
   }
   ```

3. 确定单层递归的逻辑

   在找最大深度的时候，递归的过程依然要使用回溯

   ```java
   // 中
   
   // 左
   if(cur.left != null) {
       leftLen++; // 深度加一
       traversal(cur.left, leftLen);
       leftLen--; // 回溯，深度减一
   }
   // 右
   if(cur.right != null) {
       leftLen++; // 深度加一
       traversal(cur.right, leftLen);
       leftLen--; // 回溯，深度减一
   }
   ```

##### 2）迭代法

本题使用层序遍历再合适不过了，比递归要好理解的多，只需要记录最后一行的第一个数值就可以了。

#### 实现

##### 1）递归法

```java
class Solution {
    private int maxLen;

    private int maxLeftValue;

    public Solution() {
        maxLen = Integer.MIN_VALUE;
        maxLeftValue = 0;
    }

    public int findBottomLeftValue(TreeNode root) {
        traversal(root, 0);
        return maxLeftValue;
    }

    private void traversal(TreeNode cur, int leftLen) {
        if(cur.left == null && cur.right == null) {
            if(leftLen > maxLen) {
                maxLen = leftLen;
                maxLeftValue = cur.val;
            }
            return;
        }
        // 左
        if(cur.left != null) {
            leftLen++; // 深度加一
            traversal(cur.left, leftLen);
            leftLen--; // 回溯，深度减一
        }
        // 右
        if(cur.right != null) {
            leftLen++; // 深度加一
            traversal(cur.right, leftLen);
            leftLen--; // 回溯，深度减一
        }
    }
}
```

精简代码

```java
class Solution {
    private int maxLen;

    private int maxLeftValue;

    public Solution() {
        maxLen = Integer.MIN_VALUE;
        maxLeftValue = 0;
    }

    public int findBottomLeftValue(TreeNode root) {
        traversal(root, 0);
        return maxLeftValue;
    }

    private void traversal(TreeNode cur, int leftLen) {
        if(cur.left == null && cur.right == null) {
            if(leftLen > maxLen) {
                maxLen = leftLen;
                maxLeftValue = cur.val;
            }
            return;
        }
        // 左
        if(cur.left != null) {
            traversal(cur.left, leftLen + 1); // 隐含有回溯
        }
        // 右
        if(cur.right != null) {
            traversal(cur.right, leftLen + 1); // 隐含有回溯
        }
    }
}
```

##### 2）迭代法

```java
class Solution {
    public int findBottomLeftValue(TreeNode root) {
        Queue<TreeNode> seen = new LinkedList<>();
        seen.offer(root);
        int result = 0;
        while(!seen.isEmpty()) {
            int currentLevelSize = seen.size();
            for(int i = 0; i < currentLevelSize; i++) {
                TreeNode cur = seen.poll();
                if(i == 0) result = cur.val;
                if(cur.left != null) seen.offer(cur.left);
                if(cur.right != null) seen.offer(cur.right);
            }
        }
        return result;
    }
}
```

## 十三、路径总和

> 解决：递归函数什么时候需要返回值？

### 112、路径总和

#### 题目

题目链接：**[112. 路径总和 - 力扣（LeetCode）](https://leetcode.cn/problems/path-sum/)**

给你二叉树的根节点 `root` 和一个表示目标和的整数 `targetSum` 。判断该树中是否存在 **根节点到叶子节点** 的路径，这条路径上所有节点值相加等于目标和 `targetSum` 。如果存在，返回 `true` ；否则，返回 `false` 。

**叶子节点** 是指没有子节点的节点。

**示例 1：**

![img](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/pathsum1.jpg)

```
输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
输出：true
解释：等于目标和的根节点到叶节点路径如上图所示。
```

**示例 2：**

![img](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/pathsum2.jpg)

```
输入：root = [1,2,3], targetSum = 5
输出：false
解释：树中存在两条根节点到叶子节点的路径：
(1 --> 2): 和为 3
(1 --> 3): 和为 4
不存在 sum = 5 的根节点到叶子节点的路径。
```

**示例 3：**

```
输入：root = [], targetSum = 0
输出：false
解释：由于树是空的，所以不存在根节点到叶子节点的路径。
```

**提示：**

- 树中节点的数目在范围 `[0, 5000]` 内
- `-1000 <= Node.val <= 1000`
- `-1000 <= targetSum <= 1000`

#### 思路

本题需要遍历从根结点到叶子结点的路径看看总和而不是目标和

##### 1）递归

可以使用深度优先遍历的方式来遍历二叉树

> 本题前中后序都可以，因为中间结点没有处理逻辑

递归三部曲：

1. 确定递归函数的参数以及返回值类型

   参数：需要一个二叉树的根结点，还需要一个计数器，这个计数器用来计算二叉树的一条边之和是否正好是目标和，计数器为`int`类型

   讨论一下返回值，递归函数什么时候需要返回值，什么时候不需要返回值？

   > 递归函数的返回值：**如果需要遍历整颗树，递归函数就不能有返回值。如果需要遍历某⼀条固定路线，递归函数 就⼀定要有返回值！**

   而本题要找一条符合条件的路径，所以递归函数需要返回值，返回值类型是什么呢？

   ![image-20221226094750601](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20221226094750601.png)

   图中可以看出，遍历的路线，并不需要遍历整棵树，所以递归函数需要返回值，可以使用`boolean`类型表示

   ```java
   boolean traversal(TreeNode cur, int count);
   ```

2. 确定终止条件

   首先计数器如何统计这一条路径的和呢？不要去累加然后判断是否等于目标和，那样代码比较麻烦，可以使用递减，让计数器`count`初识为目标和，然后每次减去遍历路径节点上的数值

   如果最后`count == 0`，同时到了叶子结点的话，就说明找到了目标和

   如果遍历到了叶子结点，`count != 0`，就说明没找到

   ```java
   if(cur.left == null && cur.right == null && count == 0) return true; // 遇到叶子结点，并且计数器为0
   if(cur.left == null && cur.right == null) return false; // 与到叶子结点还没有找合适的边，直接返回
   ```

3. 确定单层递归的逻辑

   因为终止条件是判断叶子结点，所以递归的过程中就不要让空节点进入递归了

   递归函数是有返回值的，如果递归函数`return true`，说明找到了合适的路径，就直接返回

   ```java
   if (cur.left != null) { // 左 （空节点不遍历）
    // 遇到叶⼦节点返回true，则直接返回true
    	if (traversal(cur.left, count - cur.left.val)) return true; // 注意这⾥有回溯的逻辑
   }
   if (cur.right != null) { // 右 （空节点不遍历）
    // 遇到叶⼦节点返回true，则直接返回true
    	if (traversal(cur.right, count - cur.right.val)) return true; // 注意这⾥有回溯的逻辑
   }
   return false;
   ```

   > 以上代码中是包含着回溯的。 回溯隐藏在`traversal(cur.left, count - cur.left.val)`这⾥， 因为把`count - cur.left.val` 直接作为参数传进去，函数结束，count的数值没有改变。
   >
   > 为了把回溯的过程体现出来，可以改为如下代码：
   >
   > ```java
   > if (cur.left != null) { // 左 （空节点不遍历）
   >  // 遇到叶⼦节点返回true，则直接返回true
   >     count -= cur.left.val; // 递归，处理节点
   >  	if (traversal(cur.left, count)) return true; 
   >     count += cur.left.val; // 回溯，撤销处理结果
   > }
   > if (cur.right != null) { // 右 （空节点不遍历）
   >  // 遇到叶⼦节点返回true，则直接返回true
   >  	count -= cur.right.val; // 递归，处理节点
   >  	if (traversal(cur.right, count)) return true; 
   >     count += cur.right.val; // 回溯，撤销处理结果
   > }
   > return false;
   > ```

##### 2）迭代

可以使用两个队列，一个队列保存遍历的节点，一个队列保存遍历结点的数值和

> 也可以使用`javafx.util.Pair`类实现，键保存节点，值保存节点数值和

#### 实现

##### 1）递归法

```java
class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if(root == null) return false;
        return traversal(root, targetSum - root.val);
    }

    private boolean traversal(TreeNode cur, int count) {
        if(cur.left == null && cur.right == null && count == 0) return true;
        if(cur.left == null && cur.right == null) return false;

        if(cur.left != null) {
            if(traversal(cur.left, count - cur.left.val)) {
                return true;
            }
        }
        if(cur.right != null) {
            if(traversal(cur.right, count - cur.right.val)) {
                return true;
            }
        }
        return false;
    }
}
```

精简代码

```java
class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if(root == null) return false;
        if(root.left == null && root.right == null && targetSum == root.val) return true;
        return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);
    }
}
```

##### 2）迭代法

```java
class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if(root == null) return false;
        Queue<TreeNode> queNode = new LinkedList<>();
        Queue<Integer> queVal = new LinkedList<>();
        queNode.offer(root);
        queVal.offer(root.val);
        while(!queNode.isEmpty()) {
            TreeNode node = queNode.poll();
            int temp = queVal.poll();
            if(node.left == null && node.right == null) {
                if(temp == targetSum)  return true;
                continue;
            }
            
            if(node.left != null) {
                queNode.offer(node.left);
                queVal.offer(temp + node.left.val);
            }
            if(node.right != null) {
                queNode.offer(node.right);
                queVal.offer(temp + node.right.val);
            }
        }
        return false;
    }
}
```

### 113、路径总和II

#### 题目

题目链接：**[113. 路径总和 II - 力扣（LeetCode）](https://leetcode.cn/problems/path-sum-ii/)**

给你二叉树的根节点 `root` 和一个整数目标和 `targetSum` ，找出所有 **从根节点到叶子节点** 路径总和等于给定目标和的路径。

**叶子节点** 是指没有子节点的节点。

**示例1：**

![img](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/pathsumii1.jpg)

```
输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
输出：[[5,4,11,2],[5,8,4,5]]
```

**示例 2：**

![img](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/pathsum2-16720215039598.jpg)

```
输入：root = [1,2,3], targetSum = 5
输出：[]
```

**示例 3：**

```
输入：root = [1,2], targetSum = 0
输出：[]
```

**提示：**

- 树中节点总数在范围 `[0, 5000]` 内
- `-1000 <= Node.val <= 1000`
- `-1000 <= targetSum <= 1000`

#### 思路

**递归法**

本题要遍历整棵树，找到所有路径，所以递归函数不需要返回值

![image-20221226103246506](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20221226103246506.png)

#### 实现

**递归法**

完整版本

```java
class Solution {
    List<List<Integer>> ans = new ArrayList<>();
    Deque<Integer> path = new LinkedList<>();

    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
        if(root == null) return ans;
        path.offerLast(root.val); // 把根结点传入路径
        traversal(root, targetSum - root.val);
        return ans;
    }

    private void traversal(TreeNode cur, int count) {
        // 遇到了叶子结点且找到了和为targetSum的路径
        if(cur.left == null && cur.right == null && count == 0) {
            ans.add(new ArrayList<>(path));
            return;
        }
        // 遇到叶子结点而没有找合适的边，直接返回
        if(cur.left == null && cur.right == null) {
            return;
        }
        // 左（空节点不遍历）
        if(cur.left != null) {
            path.offerLast(cur.left.val);
            traversal(cur.left, count - cur.left.val); // 包含回溯
            path.pollLast(); // 回溯
        }
        // 右（空节点不遍历）
        if(cur.right != null) {
            path.offerLast(cur.right.val);
            traversal(cur.right, count - cur.right.val); // 包含回溯
            path.pollLast(); // 回溯
        }
    }
}
```

精简改编版：

```java
class Solution {
    List<List<Integer>> ans = new ArrayList<>();
    Deque<Integer> path = new LinkedList<>();

    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
        traversal(root, targetSum);
        return ans;
    }

    private void traversal(TreeNode cur, int targetSum) {
        if(cur == null) return;
        path.offerLast(cur.val);
        targetSum -= cur.val;
        if(cur.left == null && cur.right == null && targetSum == 0) {
            ans.add(new ArrayList<>(path));
        }
        traversal(cur.left, targetSum);
        traversal(cur.right, targetSum);
        path.pollLast(); // 回溯
    }
}
```

## 十四、构造二叉树

### 106、从中序和后序遍历序列构造二叉树

#### 题目

题目链接：**[106. 从中序与后序遍历序列构造二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)**

给定两个整数数组 `inorder` 和 `postorder` ，其中 `inorder` 是二叉树的中序遍历， `postorder` 是同一棵树的后序遍历，请你构造并返回这颗 *二叉树* 。

**示例 1:**

![img](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/tree-16720637433131.jpg)

```
输入：inorder = [9,3,15,20,7],postorder = [9,15,7,20,3]
输出：[3,9,20,null,null,15,7]
```

**示例 2:**

```
输入：inorder = [-1], postorder = [-1]
输出：[-1]
```

**提示:**

- `1 <= inorder.length <= 3000`
- `postorder.length == inorder.length`
- `-3000 <= inorder[i], postorder[i] <= 3000`
- `inorder` 和 `postorder` 都由 **不同** 的值组成
- `postorder` 中每一个值都在 `inorder` 中
- `inorder` **保证**是树的中序遍历
- `postorder` **保证**是树的后序遍历

#### 思路

> 根据两个顺序构造出一个唯一的二叉树：
>
> => 以后序数组的最后一个元素为切割点，先切割中序数组，根据中序数组反过来切割后序数组，一层一层切下去，每次后续数组的最后一个元素就是节点元素
>
> 以`inorder = [9,3,15,20,7],postorder = [9,15,7,20,3]`为例，流程如图：
>
> ![image-20221226222511312](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20221226222511312.png)

一层一层切割 => 递归

步骤：

1. 如果数组大小为零，说明是空节点
2. 如果不为空，那么取后序数组的最后一个元素作为节点元素
3. 找到后序数组最后一个元素在中序数组中的位置，作为切割点
4. 切割中序数组，切割成中序左数组和中序右数组
5. 切割后序数组，切成后序左数组和后序右数组
6. 递归处理左区间和右区间

**难点：**如何切割，以及如何找边界值

> 注意切割的标准，是左闭右闭，还是左开右闭，还是左闭右开，这个是个不变量，要在递归中保持这个变量
>
> 在切割的过程会产生四个区间，把握不好不变量的结果就是乱套

1）首先要切割中序数组

> 为什么？
>
> 切割点在后序数组的最后一个元素，就是利用这个元素来切割中序数组，所以必要先切割中序数组

中序数组相对比较好切，找到切割点（后序数组的最后一个元素）在中序数组的位置，然后切割（以下代码采用**左闭右开**的原则）

2）然后切割后序数组

首先后序数组的最后一个元素需要丢弃，这是切割点也是当前二叉树中间结点的元素

后序数组的切割点怎么找？

后序数组没有明确的切割元素来进⾏左右切割，不像中序数组有明确的切割点，切割点左右分开就可以了。

**一个很重要的点，就是中序数组大小一定是和后序数组的大小相同的**

中序数组已经拆分成中序左数组和中序右数组，那么后序数组就可以按照中序左数组的大小来切割，切割成后序左数组和后序右数组

此时，中序数组和后序数组切割完成，可以递归了



#### 实现

Java代码

```java
class Solution {
    Map<Integer, Integer> map;  // 方便根据数值查找位置

    public TreeNode buildTree(int[] inorder, int[] postorder) {
        map = new HashMap<>();
        for (int i = 0; i < inorder.length; i++) { // 用map保存中序序列的数值对应位置
            // key - 数值   value - 下标
            map.put(inorder[i], i);
        }

        return findNode(inorder,  0, inorder.length, postorder,0, postorder.length);  // 前闭后开
    }

    public TreeNode findNode(int[] inorder, int inBegin, int inEnd, int[] postorder, int postBegin, int postEnd) {
        // 参数里的范围都是前闭后开
        if (inBegin >= inEnd || postBegin >= postEnd) {  // 不满足左闭右开，说明没有元素，返回空树
            return null;
        }
        int rootIndex = map.get(postorder[postEnd - 1]);  // 找到后序遍历的最后一个元素在中序遍历中的位置
        TreeNode root = new TreeNode(inorder[rootIndex]);  // 构造结点
        int lenOfLeft = rootIndex - inBegin;  // 保存中序左子树个数，用来确定后序数列的个数
        root.left = findNode(inorder, inBegin, rootIndex,
                postorder, postBegin, postBegin + lenOfLeft);
        root.right = findNode(inorder, rootIndex + 1, inEnd,
                postorder, postBegin + lenOfLeft, postEnd - 1);

        return root;
    }
}
```

### 105、从前序与后序遍历序列构造二叉树

#### 题目

题目链接：**[105. 从前序与中序遍历序列构造二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)**

给定两个整数数组 `preorder` 和 `inorder` ，其中 `preorder` 是二叉树的**先序遍历**，`inorder` 是同一棵树的**中序遍历**，请构造二叉树并返回其根节点。

**示例 1:**

![img](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/tree-16721014893041.jpg)

```
输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
输出: [3,9,20,null,null,15,7]
```

**示例 2:**

```
输入: preorder = [-1], inorder = [-1]
输出: [-1]
```

**提示:**

- `1 <= preorder.length <= 3000`
- `inorder.length == preorder.length`
- `-3000 <= preorder[i], inorder[i] <= 3000`
- `preorder` 和 `inorder` 均 **无重复** 元素
- `inorder` 均出现在 `preorder`
- `preorder` **保证** 为二叉树的前序遍历序列
- `inorder` **保证** 为二叉树的中序遍历序列

#### 思路

和**[106. 从中序与后序遍历序列构造二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)**一个道理，后序数组的最后一个元素 ==> 前序数组的第一个元素

####  实现

Java代码

```java
class Solution {

    // 方便根据数值查找位置（数值 -> 下标）
    Map<Integer, Integer> map;

    public TreeNode buildTree(int[] preorder, int[] inorder) {
        map = new HashMap<>();
        for(int i = 0; i < inorder.length; i++) {
            map.put(inorder[i], i);
        }
        // 左闭右开
        return findNode(inorder, 0, inorder.length, preorder, 0, preorder.length);
    }

    private TreeNode findNode(int[] inorder, int inBegin, int inEnd, int[] preorder, int preBegin, int preEnd) {
        // 参数范围都是左闭右开
        if(inBegin >= inEnd || preBegin >= preEnd) {
            // 不满足左闭右开，说明没有元素，返回空树
            return null;
        }
        // 找到前序遍历的第一个元素在中序遍历中的位置
        int rootIndex = map.get(preorder[preBegin]);
        // 构造根节点
        TreeNode root = new TreeNode(inorder[rootIndex]);
        // 中序左数组元素个数
        int lenOfLeft = rootIndex - inBegin;
        // 注意好范围
        root.left = findNode(inorder, inBegin, rootIndex, preorder, preBegin + 1, preBegin + 1 + lenOfLeft);
        root.right = findNode(inorder, rootIndex + 1, inEnd, preorder, preBegin + 1 + lenOfLeft, preEnd);
        return root;
    }
}
```

> ### 思考
>
> 1. 前序和中序可以唯一确定一棵二叉树
> 2. 后序和中序可以唯一确定一棵二叉树
>
> 那么前序和后序能否唯一确定一棵二叉树呢？
>
> ### 答：
>
> **前序和后序不能唯一确定一棵二叉树**，因为没有中序遍历无法确定左右部分，也就是无法分割
>
> ![image-20221227085915397](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20221227085915397.png)
>
> 上图中
>
> - tree1的前序遍历为[1,2,3]，后序遍历为[3,2,1]
> - tree2的前序遍历为[1,2,3]，后序遍历为[3,2,1]
>
> =>  两棵不同的树的前序和后序完全相同！！！  =>  前序和后序不能唯一确定一棵二叉树的

### 654、最大二叉树

#### 题目

题目链接：**[654. 最大二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-binary-tree/)**

给定一个不重复的整数数组 `nums` 。 **最大二叉树** 可以用下面的算法从 `nums` 递归地构建:

1. 创建一个根节点，其值为 `nums` 中的最大值。
2. 递归地在最大值 **左边** 的 **子数组前缀上** 构建左子树。
3. 递归地在最大值 **右边** 的 **子数组后缀上** 构建右子树。

返回 *`nums` 构建的* ***最大二叉树*** 。

**示例 1：**

![img](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/tree1-16721037775083.jpg)

```
输入：nums = [3,2,1,6,0,5]
输出：[6,3,5,null,2,0,null,null,1]
解释：递归调用如下所示：
- [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。
	- [3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。
		- 空数组，无子节点
		- [2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。
			- 空数组，无子节点。
            - 只有一个元素，所以子节点是一个值为 1 的节点。
    - [0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。  
    	- 只有一个元素，所以子节点是一个值为 0 的节点。
        - 空数组，无子节点。
```

**示例 2：**

![img](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/tree2-16721038965555.jpg)

```
输入：nums = [3,2,1]
输出：[3,null,2,null,1]
```

**提示：**

- `1 <= nums.length <= 1000`
- `0 <= nums[i] <= 1000`
- `nums` 中的所有整数 **互不相同**

#### 思路

以[3,2,1,6,0,5]为例，最大二叉树构造过程：

![1.png](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/1660983388-JCEHCH-1.png)

构造树一般采用前序遍历，因为先构造中间结点，然后递归构造左子树和右子树

递归三部曲：

1. 确定递归函数的参数以及返回值

   参数就是传入存放元素的数组，以及要构造二叉树的数组的左边界和右边界（左闭右开），返回该数组构造的二叉树的根结点，返回值类型是节点类型

   ```java
   TreeNode helper(int[] nums, int leftIndex, int rightIndex);
   ```

2. 确定终止条件

   题目中说输入的数组大小一定是大于等于1的，所以不需要考虑小于1的情况，那么当递归遍历的时候，如果传入的数组大小为1，说明遍历到叶子结点了，那么应该定义一个新的节点，并把这个数组的数值赋值给新的节点，然后返回这个节点。这表示一个数组的大小是1的时候，构造了一个新节点，并返回。

   ```java
   if(rightIndex - leftIndex < 1) {
       // 没有元素了
       return null;
   }
   if(rightIndex - leftIndex == 1) {
       // 只有一个元素
       return new TreeNode(nums[leftIndex]);
   }
   ```

3. 确定单层递归的逻辑

   1）先找到数组中最大的值和对应的下标，最大的值构造根结点，下标用来下一步分割数组

   2）最大值所在的下标左区间构造左子树，这里需要判断`maxValueIndex > 0`，因为要保证左区间至少有一个数值

   3）最大值所在的下标右区间构造右子树，这里需要判断`maxValueIndex < (nums.length - 1)`，因为要保证右区间至少有一个数值

   > 上述判断过程可以使用传参的方式约束

   

#### 实现

Java代码

```java
class Solution {
    public TreeNode constructMaximumBinaryTree(int[] nums) {
        return helper(nums, 0, nums.length);
    }

    private TreeNode helper(int[] nums, int leftIndex, int rightIndex) {
        if(rightIndex - leftIndex < 1) {
            // 没有元素了
            return null;
        }
        if(rightIndex - leftIndex == 1) {
            // 只剩下一个元素了
            return new TreeNode(nums[leftIndex]);
        }

        // 最大值的下标
        int maxValueIndex = leftIndex;
        // 最大值
        int maxValue = nums[leftIndex];
        for(int i = leftIndex + 1; i < rightIndex; i++) {
            if(nums[i] > maxValue) {
                maxValue = nums[i];
                maxValueIndex = i;
            }
        } 
        // 构造当前区间的根结点
        TreeNode root = new TreeNode(maxValue);
        // 根据maxValueIndex划分左右子树
        root.left = helper(nums, leftIndex, maxValueIndex);
        root.right = helper(nums, maxValueIndex + 1, rightIndex);
        return root;
    }
}
```

## 十五、合并二叉树

### 617、合并二叉树

#### 题目

题目链接：**[617. 合并二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/merge-two-binary-trees/)**

给你两棵二叉树： `root1` 和 `root2` 。

想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，**不为** null 的节点将直接作为新二叉树的节点。

返回合并后的二叉树。

**注意:** 合并过程必须从两个树的根节点开始。

**示例 1：**

![img](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/merge.jpg)

```
输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]
输出：[3,4,5,5,4,null,7]
```

**示例 2：**

```
输入：root1 = [1], root2 = [1,2]
输出：[2,2]
```

**提示：**

- 两棵树中的节点数目在范围 `[0, 2000]` 内
- `-10^4 <= Node.val <= 10^4`

#### 思路

##### 1）递归法

> 二叉树使用递归，就要想使用哪种遍历方式？
>
> **本题使用哪种遍历都是可以的 ！**

前序遍历：

![recursion.gif](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/23fbf9388a4193475a7606a6390729f575e3329e0a810d2047682f701d3ddd1f-recursion.gif)

递归三部曲：

1. 确定递归函数的参数和返回值

   首先要想合并两棵二叉树，那么参数至少是要传入两棵二叉树的根结点，返回值就是合并之后的二叉树根结点

   ```java
   TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
   
   }
   ```

2. 确定终止条件

   因为是传入了两棵树，那么就有两棵树的遍历结点`root1`，`root2`，如果`root1 == null`，两棵树合并之后就是`root2`（`root2 == null`也没有关系，合并之后就是`null`）

   反之同理

   ```java
   if(root1 == null) return root2;
   if(root2 == null) return root1;
   ```

3. 确定单层递归的逻辑

   单层递归的逻辑就比较好写了，此处我们复用`root1`这棵树

   在单层递归中，就要把两棵树的元素加在一起

   ```java
   root1.val += root2.val;
   ```

   接下来合并两棵树的左子树和右子树

   ```java
   root1.left = mergeTrees(root1.left, root2.left);
   root1.right = mergeTrees(root1.right, root2.right);
   return root1;
   ```

##### 2）迭代法

- 使用栈
- 使用队列

#### 实现

##### 1）递归法

前序遍历

```java
class Solution {
    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
        if(root1 == null) return root2;
        if(root2 == null) return root1;

        root1.val += root2.val; // 中

        root1.left = mergeTrees(root1.left, root2.left); // 左
        root1.right = mergeTrees(root1.right, root2.right); // 右
        return root1;
    }
}
```

中序遍历

```java
class Solution {
    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
        if(root1 == null) return root2;
        if(root2 == null) return root1;

        root1.left = mergeTrees(root1.left, root2.left); // 左
        root1.val += root2.val; // 中
        root1.right = mergeTrees(root1.right, root2.right); // 右
        return root1;
    }
}
```

后序遍历

```java
class Solution {
    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
        if(root1 == null) return root2;
        if(root2 == null) return root1;

        root1.left = mergeTrees(root1.left, root2.left); // 左
        root1.right = mergeTrees(root1.right, root2.right); // 右
        root1.val += root2.val; // 中
        return root1;
    }
}
```

不改变树结构的前序遍历

```java
class Solution {
    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
        if(root1 == null) return root2;
        if(root2 == null) return root1;
		
        TreeNode root = new TreeNode(0);
        
        root.val = root1.val + root2.val; // 中
        root.left = mergeTrees(root1.left, root2.left); // 左
        root.right = mergeTrees(root1.right, root2.right); // 右
        return root;
    }
}
```

##### 2）迭代法

使用栈

```java
class Solution {
    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
        if(root1 == null) return root2;
        if(root2 == null) return root1;

        Deque<TreeNode> stack = new LinkedList<>();
        stack.push(root2);
        stack.push(root1);
        while(!stack.isEmpty()) {
            TreeNode node1 = stack.pop();
            TreeNode node2 = stack.pop();
            node1.val += node2.val; // 中
            // 右
            if(node2.right != null && node1.right != null) {
                stack.push(node2.right);
                stack.push(node1.right);
            } else {
                if(node1.right == null) {
                    node1.right = node2.right;
                }
            }
            // 左
            if(node2.left != null && node1.left != null) {
                stack.push(node2.left);
                stack.push(node1.left);
            } else {
                if(node1.left == null) {
                    node1.left = node2.left;
                }
            }
        }
        return root1;
    }
}
```

使用队列

```java
class Solution {
    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
        if(root1 == null) return root2;
        if(root2 == null) return root1;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root1);
        queue.offer(root2);
        while(!queue.isEmpty()) {
            TreeNode node1 = queue.poll();
            TreeNode node2 = queue.poll();

            // 此时两个节点一定不为空，val相加
            node1.val += node2.val;
            // 如果两棵树的左节点都不空，加入队列
            if(node1.left != null && node2.left != null) {
                queue.offer(node1.left);
                queue.offer(node2.left);
            }
            // 如果两棵树的右节点都不空，加入队列
            if(node1.right != null && node2.right != null) {
                queue.offer(node1.right);
                queue.offer(node2.right);
            }
            // 若node1的左节点为空，直接赋值
            if (node1.left == null) {
                node1.left = node2.left;
            }
            // 若node2的左节点为空，直接赋值
            if (node1.right == null) {
                node1.right = node2.right;
            }
        }
        return root1;
    }
}
```



## 十六、二叉树中的搜索专题

### 700、二叉搜索树中的搜索

#### 题目

题目链接：**[700. 二叉搜索树中的搜索 - 力扣（LeetCode）](https://leetcode.cn/problems/search-in-a-binary-search-tree/)**

给定二叉搜索树（BST）的根节点 `root` 和一个整数值 `val`。

你需要在 BST 中找到节点值等于 `val` 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 `null` 。

**示例 1:**

![img](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/tree1-16721431158231.jpg)

```
输入：root = [4,2,7,1,3], val = 2
输出：[2,1,3]
```

**示例 2:**

![img](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/tree2-16721431806195.jpg)

```
输入：root = [4,2,7,1,3], val = 5
输出：[]
```

**提示：**

- 数中节点数在 `[1, 5000]` 范围内
- `1 <= Node.val <= 10^7`
- `root` 是二叉搜索树
- `1 <= val <= 10^7`

#### 思路

> 二叉搜索树是一颗有序树：
>
> - 若它的左⼦树不空，则左⼦树上所有结点的值均⼩于它的根结点的值； 
> - 若它的右⼦树不空，则右⼦树上所有结点的值均⼤于它的根结点的值； 
> - 它的左、右⼦树也分别为⼆叉搜索树

##### 1）递归法

递归三部曲：

1. 确定递归函数的参数和返回值

   递归函数的参数就是根结点和要搜索的数值，返回值就是这个搜索数值所在的节点

   ```java
   TreeNode searchBST(TreeNode root, int val);
   ```

2. 确定终止条件

   如果root为空，或者找到了这个数值了，就返回root节点

   ```java
   if(root == null && root.val == val) return root;
   ```

3. 确定单层递归的逻辑

   因为二叉搜索树的节点是有序的，所以可以有方向的去搜素

   如果`root.val > val`，就去搜索左子树，如果`root.val < val`，就去搜索右子树，最后如果都没有搜索到，就返回`null`

   ```java
   if(root.val > val) return searchBST(root.left, val);
   if(root.val < val) return searchBST(root.right, val);
   return null;
   ```

   > 之前提过，如要要搜素一条边，递归函数就要加返回值
   >
   > 这里也是一样的道理，因为搜索到了目标节点，就要立即`return`，这样才是找到节点就返回（叟座某一条边），如果不加`return`，就是遍历整棵树了

##### 2）迭代法

> 一提到二叉树遍历的迭代法，可能立刻就想起使用栈来模拟深度优先遍历，使用队列来模拟广度优先遍历
>
> 对于二叉搜索树可就不一样了，因为二叉搜索树的特殊性，也就是节点的有序性，可以不使用栈或者队列就可以写出迭代法

对于一般二叉树，递归过程中还有回溯的过程，例如走一个左方向的分支走到头了，那么就要掉头，走右分支

**对于二叉搜索树，不需要回溯的过程，因为节点的有序性就帮助我们确定了搜索的方向**

【例子】要搜素元素3的节点，我们不需要搜索其他节点，也不需要回溯，查找的路径已经规划好了

中间结点如果小于3就往右走，如果大于3就往左走

![image-20221227204825710](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20221227204825710.png)

#### 实现

##### 1）递归法

```java
class Solution {
    public TreeNode searchBST(TreeNode root, int val) {
        if(root == null || root.val == val) return root;
        if(root.val > val) return searchBST(root.left, val);
        if(root.val < val) return searchBST(root.right, val);
        return null;
    }
}
```

##### 2）迭代法

```java
class Solution {
    public TreeNode searchBST(TreeNode root, int val) {
        while(root != null) {
            if(root.val == val) return root;
            else if(root.val > val) root = root.left;
            else root = root.right;
        }
        return root;
    }
}
```

### 98、验证二叉搜索树

#### 题目

题目链接：**[98. 验证二叉搜索树 - 力扣（LeetCode）](https://leetcode.cn/problems/validate-binary-search-tree/)**

给你一个二叉树的根节点 `root` ，判断其是否是一个有效的二叉搜索树。

**有效** 二叉搜索树定义如下：

- 节点的左子树只包含 **小于** 当前节点的数。
- 节点的右子树只包含 **大于** 当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。

**示例 1：**

![img](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/tree1-16721878442281.jpg)

```
输入：root = [2,1,3]
输出：true
```

**示例 2：**

![img](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/tree2-16721879146145.jpg)

```
输入：root = [5,1,4,null,null,3,6]
输出：false
解释：根节点的值是 5 ，但是右子节点的值是 4 。
```

**提示：**

- 树中节点数目范围在`[1, 10^4]` 内
- `-2^31 <= Node.val <= 2^31 - 1`

#### 思路

在中序遍历下，输出的二叉搜索树节点的数值是有序序列

##### 1）递归法

方法一：递归中序遍历将二叉搜索树转变成一个数组，然后判断这个数组是否有序，注意二叉搜索树中不能有重复元素

方法二：在递归遍历的过程中直接判断是否有序

> 本题比较容易踩的坑：
>
> - 坑1：**不能单纯的比较左节点小于中间结点，右节点大于中间结点**
>
>   ```java
>   // 此代码是错误的
>   if (root.val > root.left.val && root.val < root.right.val) {
>    	return true;
>   } else {
>    	return false;
>   }
>   ```
>
>   **要比较的是 左子树的所有节点小于中间结点，右子树的所有节点大于中间结点**
>
>   【例子】：`[10,5,15,null,null,6,20]`
>
>   ![image-20221228085116770](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20221228085116770.png)
>
>   节点10大于左节点5，小于右节点15，但是在右子树中出现了一个6，这就不符合二叉搜索树的定义
>
> - 坑2：**样例中的最小节点可能是Integer.MIN_VALUE**
>
>   此时可以初始化比较元素为**Long.MIN_VLAUE**
>
>   问题可以进一步演化，如果样例中的最小节点为**Long.MIN_VALUE**，怎么办？后续解答

递归三部曲：

1. 确定递归函数的参数以及返回值

   定义一个`long`类型的全局变量，用来比较遍历的节点是否有序，初始化为`Long.MIN_VALUE`

   递归函数的返回值为`boolean`，因为本题是在寻找一个不符合条件的节点，如果没有找到这个结点就遍历整棵树，如果找到了不符合条件的节点，立即返回

   ```java
   long maxVal = Long.MIN_VALUE;
   boolean isValidBST(TreeNode root);
   ```

2. 确定终止条件

   如果遍历到了空节点，返回`true`，因为二叉搜索树也可以为空！

   ```java
   if(root == null) {
       return true;
   }
   ```

3. 确定单层递归的逻辑

   中序遍历，一直更新`maxVal`，一旦发现`maxVal >= root.val`，就返回`false`，注意元素相同的时候也要返回`false`

   ```java
   boolean left = isValidBST(root.left);
   if(root.val > maxVal) maxVal = root.val;
   else return false;
   boolean right = isValidBST(root.right);
   
   return left && right;
   ```

##### 2）迭代法

迭代法中序遍历稍加改就可以了

#### 实现

##### 1）递归法

方法一

```java
class Solution {
    private List<Integer> nodeValueList;
    public boolean isValidBST(TreeNode root) {
        nodeValueList = new ArrayList<>();
        traversal(root);
        for(int i = 1; i < nodeValueList.size(); i++) {
            if(nodeValueList.get(i) <= nodeValueList.get(i - 1)) return false;
        }
        return true;
    }

    private void traversal(TreeNode root) {
        if(root == null) return;
        traversal(root.left);
        nodeValueList.add(root.val);
        traversal(root.right);
    }
}
```

方法二：

```java
class Solution {
    long maxVal = Long.MIN_VALUE;
    public boolean isValidBST(TreeNode root) {
        if(root == null) return true;
        boolean left = isValidBST(root.left);
        if(root.val > maxVal) maxVal = root.val;
        else return false;
        boolean right = isValidBST(root.right);

        return left && right;
    }
}
```

> 如果样例中的最小节点为**Long.MIN_VALUE**，建议避免初始化最小值，使用如下方法取到最左面的节点的数值来比较

```java
class Solution {
    TreeNode pre = null;
    public boolean isValidBST(TreeNode root) {
        if(root == null) return true;
        boolean left = isValidBST(root.left);
        if(pre != null && root.val <= pre.val) return false;;
        // 记录前一个节点
        pre = root;
        boolean right = isValidBST(root.right);

        return left && right;
    }
}
```

##### 2）迭代法

```java
class Solution {
    public boolean isValidBST(TreeNode root) {
        Deque<TreeNode> stack = new LinkedList<>();
        TreeNode cur = root;
        TreeNode pre = null;
        while(cur != null || !stack.isEmpty()) {
            if(cur != null) {
                stack.push(cur);
                cur = cur.left; // 左
            } else {
                cur = stack.pop(); // 中
                if(pre != null && cur.val <= pre.val) return false;
                pre = cur;  
                cur = cur.right; // 右
            }
        }
        return true;
    }
}
```

### 530、二叉搜索树的最小绝对差

####  题目

题目链接：**[530. 二叉搜索树的最小绝对差 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-absolute-difference-in-bst/)**

给你一个二叉搜索树的根节点 `root` ，返回 **树中任意两不同节点值之间的最小差值** 。

差值是一个正数，其数值等于两值之差的绝对值。

**示例 1：**

![img](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/bst1.jpg)

```
输入：root = [4,2,6,1,3]
输出：1
```

**示例 2：**

![img](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/bst2.jpg)

```
输入：root = [1,0,48,null,null,12,49]
输出：1
```

**提示：**

- 树中节点的数目范围是 `[2, 10^4]`
- `0 <= Node.val <= 10^5`

#### 思路

##### 1）递归

方法一：最直观的想法，把二叉搜索树转换成有序数组，然后遍历一遍数组，就统计出来最小差值了

方法二：在二叉搜索树的中序遍历过程中，直接计算差值，需要用到一个pre节点来记录cur节点的前一个节点

![image-20221228092838398](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20221228092838398.png)

##### 2）迭代法

普通迭代法

统一迭代法

#### 实现

##### 1）递归

方法一：

```java
class Solution {
    private List<Integer> nodeValueList;
    public int getMinimumDifference(TreeNode root) {
        nodeValueList = new ArrayList<>();
        traversal(root);
        if(nodeValueList.size() < 2) return 0;
        int result = Integer.MAX_VALUE;
        for(int i = 1; i < nodeValueList.size(); i++) {
            result = Math.min(result, nodeValueList.get(i) - nodeValueList.get(i - 1));
        }
        return result;
    }
    
    private void traversal(TreeNode root) {
        if(root == null) return;
        traversal(root.left);
        nodeValueList.add(root.val);
        traversal(root.right);
    }
}
```

方法二：

```java
class Solution {
    int result = Integer.MAX_VALUE;
    TreeNode pre = null;
    public int getMinimumDifference(TreeNode root) {
        traversal(root);
        return result;
    }

    private void traversal(TreeNode cur) {
        if(cur == null) return;
        traversal(cur.left);
        if(pre != null) {
            result = Math.min(result, cur.val - pre.val);
        }
        pre = cur;
        traversal(cur.right);
    }
}
```

##### 2）迭代法

```java
class Solution {
    public int getMinimumDifference(TreeNode root) {
        Deque<TreeNode> stack = new LinkedList<>();
        TreeNode cur = root;
        TreeNode pre = null;
        int result = Integer.MAX_VALUE;
        while(cur != null || !stack.isEmpty()) {
            if(cur != null) {
                stack.push(cur);
                cur = cur.left; // 左
            } else {
                cur = stack.pop(); // 中
                if(pre != null) {
                    result = Math.min(result, cur.val - pre.val);
                } 
                pre = cur;  
                cur = cur.right; // 右
            }
        }
        return result;
    }
}
```

### 501、二叉搜索树中的众数

#### 题目

题目链接：**[501. 二叉搜索树中的众数 - 力扣（LeetCode）](https://leetcode.cn/problems/find-mode-in-binary-search-tree/)**

给你一个含重复值的二叉搜索树（BST）的根节点 `root` ，找出并返回 BST 中的所有 [众数](https://baike.baidu.com/item/众数/44796)（即，出现频率最高的元素）。

如果树中有不止一个众数，可以按 **任意顺序** 返回。

假定 BST 满足如下定义：

- 结点左子树中所含节点的值 **小于等于** 当前节点的值
- 结点右子树中所含节点的值 **大于等于** 当前节点的值
- 左子树和右子树都是二叉搜索树

 **示例 1：**

![img](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/mode-tree.jpg)

```
输入：root = [1,null,2,2]
输出：[2]
```

**示例 2：**

```
输入：root = [0]
输出：[0]
```

 

**提示：**

- 树中节点的数目在范围 `[1, 10^4]` 内
- `-10^5 <= Node.val <= 10^5`

#### 思路

##### 1）递归法

**1、如果不是二叉搜索树**

如果不是二叉搜索树，最直观的方法就是遍历整棵树，用map统计频率，按照频率排序，最后取前面高频的元素的集合

具体步骤：

1. 遍历整棵树，用map统计频率（key - 元素，value - 出现频率）

   遍历顺序无所谓

2. 统计，按照value排序

3. 取前面高频的元素

**2）如果是二叉搜索树**

二叉搜索树的中序遍历是有序的

![image-20221228100114295](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20221228100114295.png)

遍历有序数组的元素出现频率，从头遍历，那么⼀定是相邻两个元素作⽐较，然后就把出现频率最⾼的元素输出就可以了。

针对于在二叉搜索树上的操作：设置⼀个指针指向前⼀个节点，这样每次`cur`（当前节点）才能和`pre`（前⼀个节点）作⽐较。 ⽽且初始化的时候`pre = null`，这样当pre为null时候，我们就知道这是⽐较的第⼀个元素。

```java
if (pre == null) { // 第⼀个节点
    count = 1; // 频率为1
} else if (pre.val == cur.val) { // 与前⼀个节点数值相同
    count++;
} else { // 与前⼀个节点数值不同
    count = 1;
}
pre = cur; // 更新上⼀个节点
```

> 此时又有问题了，因为要求最⼤频率的元素集合（注意是集合，不是⼀个元素，可以有多个众数），
>
> 数组的处理：应该是先遍历⼀遍数组，找出最⼤频率（`maxCount`），然后再重新遍历⼀遍数组把出现频率 为`maxCount`的元素放进集合。（因为众数有多个） 这种⽅式遍历了两遍数组。 
>
> 那么遍历两遍⼆叉搜索树，把众数集合算出来也是可以的。 但这⾥其实只需要遍历⼀次就可以找到所有的众数。

如果频率`count `等于 `maxCount`（最⼤频率），当然要把这个元素加⼊到结果集中

```java
if (count == maxCount) {
    resList.add(rootValue);
}
```

有一个问题，如果此时的maxCount不是最大频率呢？

解决操作：频率`count `⼤于 `maxCount`的时候，不仅要更新`maxCount`，⽽且要**清空结果集**，因为结果集之前的元素都失效了。

```java
if (count > maxCount) {
    resList.clear();
    resList.add(rootValue);
    maxCount = count;
}
```

##### 2）迭代法

普通迭代法

统一迭代法

#### 实现

##### 1）递归法

**1、如果不是二叉搜索树**

```java
class Solution {
    Map<Integer, Integer> frequencyMap;
    public int[] findMode(TreeNode root) {
        frequencyMap = new HashMap<>();
        if(root == null) return new int[]{};
        List<Integer> resultList = new ArrayList<>();
        // 获取 元素值-频率 map
        searchBST(root);
        // 按照频率降序排列
        List<Map.Entry<Integer, Integer>> mapList = frequencyMap.entrySet().stream()
				.sorted((c1, c2) -> c2.getValue().compareTo(c1.getValue()))
				.collect(Collectors.toList());
        // 取最高频次的元素
        resultList.add(mapList.get(0).getKey());
        // 把同样最高频次的元素加入集合
        for(int i = 1; i < mapList.size(); i++) {
            if (mapList.get(i).getValue() == mapList.get(i - 1).getValue()) {
				resultList.add(mapList.get(i).getKey());
			} else {
				break;
			}
        }
        return resultList.stream().mapToInt(Integer::intValue).toArray();
    }

    private void searchBST(TreeNode cur) {
		if (cur == null) return;
		frequencyMap.put(cur.val, frequencyMap.getOrDefault(cur.val, 0) + 1);
		searchBST(cur.left);
		searchBST(cur.right);
	}
}
```

**2、如果是二叉搜索树**

```java
class Solution {
    private ArrayList<Integer> resultList;
    private int maxCount;
    private int count;
    private TreeNode pre;

    public Solution() {
        resultList = new ArrayList<>();
        maxCount = 0;
        count = 0;
        pre = null;
    }

    public int[] findMode(TreeNode root) {
        helper(root);
        int[] result = new int[resultList.size()];
        for (int i = 0; i < resultList.size(); i++) {
            result[i] = resultList.get(i);
        }
        return result;
    }

    private void helper(TreeNode cur) {
        if(cur == null) return;
        helper(cur.left);
        int rootValue = cur.val;
        // 计算频率
        if (pre == null || pre.val != rootValue) {
            count = 1; // 频率为1
        } else if (pre.val == rootValue) {
            count++;
        } 

        if(count > maxCount) {
            resultList.clear();
            resultList.add(rootValue);
            maxCount = count;
        } else if(count == maxCount){
            resultList.add(rootValue);
        }
        // 更新上⼀个节点
        pre = cur; 
        helper(cur.right);
    }
}
```

##### 2）迭代法

```java
class Solution {
    public int[] findMode(TreeNode root) {
        int count = 0;
        int maxCount = 0;
        List<Integer> resultList = new ArrayList<>();
        Deque<TreeNode> stack = new LinkedList<>();
        TreeNode cur = root;
        TreeNode pre = null;
        while(cur != null || !stack.isEmpty()) {
            if(cur != null) {
                stack.push(cur);
                cur = cur.left; // 左
            } else {
                cur = stack.pop(); // 中
                if(pre == null || pre.val != cur.val) {
                    count = 1;
                } else {
                    count++;
                }
                if(count > maxCount) {
                    resultList.clear();
                    resultList.add(cur.val);
                    maxCount = count;
                } else if(count == maxCount) {
                    resultList.add(cur.val);
                }
                pre = cur;  
                cur = cur.right; // 右
            }
        }
        return resultList.stream().mapToInt(Integer::intValue).toArray();
    }
}
```

### 236、二叉树的最近公共祖先

#### 题目

题目链接：**[236. 二叉树的最近公共祖先 - 力扣（LeetCode）](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)**

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

[百度百科](https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”

**示例 1：**

![img](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/binarytree.png)

```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出：3
解释：节点 5 和节点 1 的最近公共祖先是节点 3 。
```

**示例 2：**

![img](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/binarytree-16722748834414.png)

```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出：5
解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。
```

**示例 3：**

```
输入：root = [1,2], p = 1, q = 2
输出：1
```

**提示：**

- 树中节点数目在范围 `[2, 10^5]` 内。
- `-10^9 <= Node.val <= 10^9`
- 所有 `Node.val` `互不相同` 。
- `p != q`
- `p` 和 `q` 均存在于给定的二叉树中。

#### 思路

本题首先想到的是自底向上查找二叉树的节点，自底向上查找的方式：**回溯、后序遍历**

判断一个节点是节点q和节点p的公共祖先：如果找到了一个节点，发现左子树出现节点p，右子树出现节点q，或者左子树出现节点q，右子树出现节点p，那么该节点就是节点p和q的最近公共祖先。

流程：使用后序遍历，回溯的过程就是从底向上遍历结点，一旦发现满足这个条件的节点，就是最近公共节点。

递归三部曲：

1. 确定递归函数的参数以及返回值

   递归函数的返回值用来标识是否找到节点p和节点q，返回值类型为`boolean`就可以了，但是还要返回最近公共节点，可以利用题目所给函数的返回值类型`TreeNode`，如果遇到了p或者q，就返回节点p或者q，返回值不为空，就说明找到了节点p或者q

   ```java
   TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
   
   }
   ```

2. 确定终止条件

   如果找到了节点p或者q，或者遇到空节点，就返回。

   ```java
   if(root == q || root == p || root == null) return root;
   ```

3. 确定单层递归的逻辑

   值得关注的是本题函数有返回值，是因为回溯的过程需要递归函数的返回值做判断，但是本题我们依然要遍历树的所有节点。

   因为本题处理返回值的方式有所不同。

   > 如果递归函数有返回值，如何区分要搜索一条边还是搜索整棵树？
   >
   > 1. 搜索一条边：
   >
   >    ```java
   >    if(recursionFunction(root.left)) return;
   >    if(recursionFunction(root.right)) return;
   >    ```
   >
   > 2. 搜索整棵树：
   >
   >    ```java
   >    left = recursionFunction(root.left);
   >    right = recursionFunction(root.right);
   >    // 处理 left 和 right
   >    ```
   >
   > => 在递归函数有返回值的情况下：
   >
   > - 如果要搜索一条边，递归函数返回值不为空的时候，立即返回；
   > - 如果要搜索整棵树，直接使用变量接收递归函数的返回值，并对返回值做后续处理，这也就是后序遍历中处理中间节点的逻辑（也是回溯）

那么为什么要遍历整棵树呢？从直观上来看，找到了最近的公共祖先，直接一路返回就可以了。

![image-20221229152648409](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20221229152648409.png)

就如上图中一样，直接返回7.

但是事实上还要遍历根结点的右子树（即使此时已经找到了目标节点），也就是图中的节点4、15、20

因为在本题的后序遍历中国，如果想要利用递归函数的返回值做逻辑处理，不能立即返回，而要等着返回值逻辑处理结束后才能返回。

```java
left = recursionFunction(root.left);
right = recursionFunction(root.right);
// 处理 left 和 right
```

这也就是为什么要遍历整棵树的原因。

处理本题的递归函数的返回值：

```java
TreeNode left = lowestCommonAncestor(root。left, p, q);
TreeNode right = lowestCommonAncestor(root。right, p, q);
```

- 如果`left != null && right != null`，就说明此时root就是最近公共节点
- 如果`left == null && right != null`，就返回right，**说明目标节点是通过right返回的**，反之亦然

> 解释：如果`left == null && right != null`，就返回right，为什么**说明目标节点是通过right返回的**
>
> ![image-20221229153829948](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20221229153829948.png)
>
> 图中节点10的左子树返回null，右子树返回目标值7，那么此时节点10的处理逻辑就是把右子树的返回值（最近公共祖先7）返回上去！

- 如果`left == null && right == null`，则返回left或者right都是可以的，也就返回null

```java
if(left != null && right != null) return root;
if (left == null && right != null) return right;
else if (left != null && right == null) return left;
else { // (left == null && right == null)
    return null;
}
```

=> 寻找最小公共祖先的完成流程图：

![image-20221229154346186](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20221229154346186.png)

图中可以看出回溯遍历整棵二叉树并将结果返回给根结点。



#### 实现

Java代码：

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root == q || root == p || root == null) return root;
        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);
        if(left != null && right != null) return root;
        if(left != null && right == null) return left;
        else if(left == null && right != null) return right;
        else return null;
    }
}
```

精简版：

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root == q || root == p || root == null) return root;
        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);
        if(left != null && right != null) return root;
        if(left != null) return left;
        else return right;
    }
}
```



### 235、二叉搜索树的最近公共祖先

#### 题目

题目链接：**[235. 二叉搜索树的最近公共祖先 - 力扣（LeetCode）](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/)**

给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。

[百度百科](https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”

例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5]

![img](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/binarysearchtree_improved.png)

**示例 1:**

```
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
输出: 6 
解释: 节点 2 和节点 8 的最近公共祖先是 6。
```

**示例 2:**

```
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
输出: 2
解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。
```

**说明:**

- 所有节点的值都是唯一的。
- p、q 为不同节点且均存在于给定的二叉搜索树中。

#### 思路

**二叉搜索树是一颗有序树。**

在有序树中，如何判断一个节点的左子树里有p，右子树里有q呢？

=> 只要从上到下遍历的时候，cur节点的数值在[p.val, q.val]区间中，则说明该节点cur就是最近公共祖先了

和普通二叉树求最近公共祖先问题不同，二叉搜索树是有序的（相当于自带方向），那么只要从上向下遍历就可以了，不需要使用回溯。

此时可以采用前序遍历（其实这里没有中间结点的处理逻辑，遍历顺序是无所谓的）

![image-20221229162510598](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20221229162510598.png)

可以看出直接按照指定的方向，就可以找到对应的节点为最近公共祖先，而且不需要遍历整棵树，找到结果就可以返回。

##### 1）递归法

递归三部曲：

1. 确定递归函数的参数以及返回值类型

   参数就是当前节点，以及两个节点p, q

   返回值是要返回的最近公共祖先，所以是`TreeNode`

   ```java
   TreeNode traversal(TreeNode cur, TreeNode p, TreeNode q)
   ```

2. 确定终止条件

   遇到空节点就可以返回了，

   ```java
   if(cur == null) return cur;
   ```

   其实都不需要这个终⽌条件，因为题⽬中说了p、q 为不同节点且均存在于给定的⼆叉搜索树 中。也就是说⼀定会找到公共祖先的，所以并不存在遇到空的情况。

3. 确定单层递归的逻辑

   在遍历二叉搜索树的时候就是寻找区间`[p.val, q.val]`（注意这里是左闭右闭）

   1）那么如果`cur.val > p.val && cur.val > q.val `，那就应该向左遍历，说明目标区间在左子树上。**需要注意的是，此时并不知道p.val 和 q.val哪个大，所以两个都要判断**

   ```java
   if (cur.val > p.val && cur.val > q.val) {
       TreeNode left = traversal(cur.left, p, q);
       if (left != null) {
           return left;
       }
   }
   ```

   > 在这⾥调⽤递归函数的地⽅，把递归函数的返回值left，直接return
   >
   > 本题就是标准的搜索一条边的写法，遇到递归函数的返回值不为空直接返回

   2）如果`cur.val < p.val && cur.val < q.val`，那么就应该向右遍历，说明目标区间在右子树上

   ```java
   if (cur.val < p.val && cur.val < q.val) {
       TreeNode right = traversal(cur.right, p, q);
       if (right != null) {
           return right;
       }
   }
   ```

   3）剩下的情况就是`cur.val <= p.val && cur.val >= q.val`或者`cur.val >= p.val && cur.val <= q.val`，那么cur就是最近公共祖先了，直接返回cur

##### 2）迭代法

思路同递归单层处理的逻辑

#### 实现

##### 1）递归法

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        return traversal(root, p, q);
    }

    private TreeNode traversal(TreeNode cur, TreeNode p, TreeNode q) {
        if(cur == null) return cur;
        if(cur.val < p.val && cur.val < q.val) {
            TreeNode right = traversal(cur.right, p, q);
            if(right != null) {
                return right;
            }
        }
        if (cur.val > p.val && cur.val > q.val) {
            TreeNode left = traversal(cur.left, p, q);
            if (left != null) {
                return left;
            }
        }
        return cur;
    }
}
```

精简版：

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root.val > q.val && root.val > p.val) {
            return lowestCommonAncestor(root.left, p, q);
        } else if(root.val < q.val && root.val < p.val) {
            return lowestCommonAncestor(root.right, p, q);
        } else return root;
    }
}
```

##### 2）迭代法

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        while(root != null) {
            if(root.val < p.val && root.val < q.val) {
                root = root.right;
            } else if(root.val > q.val && root.val > p.val) {
                root = root.left;
            } else {
                return root;
            }
        }
        return root;
    }
}
```

### 701、二叉搜索树中的插入操作

#### 题目

题目链接：**[701. 二叉搜索树中的插入操作 - 力扣（LeetCode）](https://leetcode.cn/problems/insert-into-a-binary-search-tree/)**

给定二叉搜索树（BST）的根节点 `root` 和要插入树中的值 `value` ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点 输入数据 **保证** ，新值和原始二叉搜索树中的任意节点值都不同。

**注意**，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 **任意有效的结果** 。

**示例 1：**

![img](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/insertbst.jpg)

```
输入：root = [4,2,7,1,3], val = 5
输出：[4,2,7,1,3,5]
解释：另一个满足题目要求可以通过的树是：
```

<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20221230090926517.png" alt="image-20221230090926517" style="zoom:50%;" />

**示例 2：**

```
输入：root = [40,20,60,10,30,50,70], val = 25
输出：[40,20,60,10,30,50,70,null,null,25]
```

**示例 3：**

```
输入：root = [4,2,7,1,3,null,null,null,null,null,null], val = 5
输出：[4,2,7,1,3,5]
```

**提示：**

- 树中的节点数将在 `[0, 10^4]`的范围内。
- `-10^8 <= Node.val <= 10^8`
- 所有值 `Node.val` 是 **独一无二** 的。
- `-10^8 <= val <= 10^8`
- **保证** `val` 在原始BST中不存在。

#### 思路

> 其实这道题⽬其实是⼀道简单题⽬，但是题⽬中的提⽰：**有多种有效的插⼊⽅式，还可以重构⼆叉搜索树**，⼀下⼦提高了层次，瞬间感觉题⽬复杂了很多。 其实可以不考虑题⽬中提⽰所说的改变树的结构的插⼊⽅式。
>
> 其实只要按照二叉搜索树的规则去遍历，遇到空节点就插入节点就可以了

##### 1）递归法

递归三部曲：

1. 确定递归函数的参数以及返回值

   参数就是根结点，以及要插入的元素。

   本题递归函数的返回值可以有也可以没有，但是递归函数没有返回值的情况处理起来比较麻烦。**有返回值的话，可以利用返回值完成新加入节点与其父结点的赋值操作**，递归函数的返回值类型为`TreeNode`

   ```java
   TreeNode insertIntoBST(TreeNode root, int val)
   ```

2. 确定终止条件

   终止条件就是找到遍历的节点为null的时候，就是要插入节点的位置了，并把插入的节点返回

   ```java
   if(root == null) {
       TreeNode node = new TreeNode(val);
       return node;
   }
   ```

   此处把添加的节点返回给上一层，就完成了父子节点的赋值操作了

3. 确定单层递归的逻辑

   由于是二叉搜索树BST，所以不需要遍历整棵树。搜索树是有方向的，可以根据插入元素的数值，决定递归方向

   ```java
   if(root.val < val) root.right = insertIntoBST(root.right, val);
   if(root.val > val) root.left = insertIntoBST(root.left, val);
   return root;
   ```

   本层通过`root.left`或者`root.right`接收递归函数返回值，这也就通过递归函数返回值完成了新加入节点的父子关系赋值操作

   > **没有返回值的话**，找到插入位置，直接让其父结点指向插入节点，结束递归
   >
   > 递归函数定义：
   >
   > ```java
   > TreeNode parent = null; // 记录遍历节点的父结点
   > void traversal(TreeNode cur, int val)
   > ```
   >
   > 没有返回值，需要记录上一个节点(`parent`)，遇到空节点了，就让parent左节点或者右节点指向新插入的节点。

##### 2）迭代法

在迭代法遍历的过程中，需要记录下当前遍历的节点的父结点，这样才能做插入节点的操作

在**[530. 二叉搜索树的最小绝对差 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-absolute-difference-in-bst/)**和**[501. 二叉搜索树中的众数 - 力扣（LeetCode）](https://leetcode.cn/problems/find-mode-in-binary-search-tree/)**中都是使用了`pre`和`cur`两个指针，在本题也适用。

#### 实现

##### 1）递归法

递归函数带返回值：

```java
class Solution {
    public TreeNode insertIntoBST(TreeNode root, int val) {
        if(root == null) return new TreeNode(val);
        if(root.val < val) root.right = insertIntoBST(root.right, val);
        if(root.val > val) root.left = insertIntoBST(root.left, val);
        return root;
    }
}
```

递归函数不带返回值

```java
class Solution {
    private TreeNode parent;

    public TreeNode insertIntoBST(TreeNode root, int val) {
        if(root == null) {
            return new TreeNode(val);
        }
        traversal(root, val);
        return root;
    }

    private void traversal(TreeNode cur, int val) {
        if(cur == null) {
            TreeNode node = new TreeNode(val);
            if(val > parent.val) parent.right = node;
            else parent.left = node;
            return;
        }
        parent = cur;
        if(val < cur.val) traversal(cur.left, val);
        if(val > cur.val) traversal(cur.right, val);
    }
}
```

##### 2）迭代法

```java
class Solution {
    public TreeNode insertIntoBST(TreeNode root, int val) {
        if(root == null) return new TreeNode(val);
        TreeNode cur = root;
        // 记录上一个节点，方便进行插入节点的操作
        TreeNode pre = root;
        while(cur != null) {
            pre = cur;
            if(cur.val > val) cur = cur.left;
            else cur = cur.right;
        }
        TreeNode node = new TreeNode(val);
        if(pre.val > val) pre.left = node;
        else pre.right = node;
        
        return root;
    }
}
```

### 450、删除二叉搜索树中的节点

#### 题目

题目链接：**[450. 删除二叉搜索树中的节点 - 力扣（LeetCode）](https://leetcode.cn/problems/delete-node-in-a-bst/)**

给定一个二叉搜索树的根节点 **root** 和一个值 **key**，删除二叉搜索树中的 **key** 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。

一般来说，删除节点可分为两个步骤：

1. 首先找到需要删除的节点；
2. 如果找到了，删除它。

**示例 1:**

![img](E:/MyFile/TyporaImgs/del_node_1.jpg)

```
输入：root = [5,3,6,2,4,null,7], key = 3
输出：[5,4,6,2,null,null,7]
解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。
一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。
另一个正确答案是 [5,2,6,null,4,null,7]。
```

<img src="E:/MyFile/TyporaImgs/image-20221230095022389.png" alt="image-20221230095022389" style="zoom: 50%;" />

**示例 2:**

```
输入: root = [5,3,6,2,4,null,7], key = 0
输出: [5,3,6,2,4,null,7]
解释: 二叉树不包含值为 0 的节点
```

**示例 3:**

```
输入: root = [], key = 0
输出: []
```

 

**提示:**

- 节点数的范围 `[0, 10^4]`.
- `-10^5 <= Node.val <= 10^5`
- 节点值唯一
- `root` 是合法的二叉搜索树
- `-10^5 <= key <= 10^5`

#### 思路

##### 1）递归法

递归三部曲：

1. 确定递归函数参数以及返回值

   参数就是根结点和要删除的节点值，返回值同**[701. 二叉搜索树中的插入操作 - 力扣（LeetCode）](https://leetcode.cn/problems/insert-into-a-binary-search-tree/)**，本题也可以通过递归返回值来删除节点

   ```java
   TreeNode deleteNode(TreeNode root, int val)
   ```

2. 确定终止条件

   遇到空节点返回，这也说明没有找到要删除的节点，遍历到空节点直接返回了

   ```java
   if(root == null) return root;
   ```

3. 确定单层递归的逻辑

   平衡二叉树中删除结点的情况有以下五种：

   没找到删除的节点

   - 情况一：遍历到空节点直接返回

   找到删除的节点：

   - 情况二：左右节点都为空，直接删除节点，返回null为根结点

     ![image-20221230100313240](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20221230100313240.png)

   - 情况三：删除结点的左节点为空，右节点不为空，删除结点，右节点补位，返回右节点为根结点

     ![image-20221230100302623](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20221230100302623.png)

   - 情况四：删除结点的右节点为空，左节点不为空，删除结点，左节点补位，返回左节点为根结点

     ![image-20221230100253791](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20221230100253791.png)

   - 情况五：删除结点的左右节点都不为空，则将删除结点的左子树头节点（删除结点的左节点）放到删除结点的右子树的最左面结点的左节点上，返回删除结点的右节点为新的根结点

     ![image-20221230100217296](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20221230100217296.png)

   ```java
   // 情况一：遍历到空节点直接返回
   if(root == null) return root;
   if(root.val == key) {
       // 情况二：左右节点都为空，直接删除节点，返回null为根结点
       // 情况三：删除结点的左节点为空，右节点不为空，删除结点，右节点补位，返回右节点为根结点
       if(root.left == null) return root.right;
       // 情况四：删除结点的右节点为空，左节点不为空，删除结点，左节点补位，返回左节点为根结点
       else if(root.right == null) return root.left;
       // 情况五：删除结点的左右节点都不为空，则将删除结点的左子树头节点（删除结点的左节点）放到删除结点的右子树的最左面结点的左节点上
       // 返回删除结点的右节点为新的根结点
       else {
           // 寻找右子树最左面的节点
           TreeNode cur = root.right;
           while(cur.left != null) {
               cur = cur.left;
           }
           // 把要删除的节点(root)左子树放在cur的左节点的位置
           cur.left = root.left;
           // 返回root的右节点作为新的root
           return root.right;
       }   
   }
   ```

   此处相当于把新的节点返回给上一层，上一层需要接收返回值

   ```java
   if(root.val > key) root.left = deleteNode(root.left, key);
   if(root.val < key) root.right = deleteNode(root.right, key);
   return root;
   ```

##### 2）普通二叉树的删除方式

普通⼆叉树的删除⽅式（没有使⽤搜索树的特性，遍历整棵树），⽤交换值的操作来删除⽬标节点

此处目标节点（要删除的节点）被操作了两次：

- 第一次是和目标节点的右子树最左面的节点交换
- 第二次直接被null覆盖了

##### 3）迭代法

思想跟递归一样，最关键的是删除结点的操作

#### 实现

##### 1）递归法

```java
class Solution {
    public TreeNode deleteNode(TreeNode root, int key) {
        // 情况一：遍历到空节点直接返回
        if(root == null) return root;
        if(root.val == key) {
            // 情况二：左右节点都为空，直接删除节点，返回null为根结点
            // 情况三：删除结点的左节点为空，右节点不为空，删除结点，右节点补位，返回右节点为根结点
            if(root.left == null) return root.right;
            // 情况四：删除结点的右节点为空，左节点不为空，删除结点，左节点补位，返回左节点为根结点
            else if(root.right == null) return root.left;
            // 情况五：删除结点的左右节点都不为空，则将删除结点的左子树头节点（删除结点的左节点）放到删除结点的右子树的最左面结点的左节点上
            // 返回删除结点的右节点为新的根结点
            else {
                // 寻找右子树最左面的节点
                TreeNode cur = root.right;
                while(cur.left != null) {
                    cur = cur.left;
                }
                // 把要删除的节点(root)左子树放在cur的左节点的位置
                cur.left = root.left;
                // 返回root的右节点作为新的root
                return root.right;
            }   
        }
        if(root.val > key) root.left = deleteNode(root.left, key);
        if(root.val < key) root.right = deleteNode(root.right, key);
        return root;
    }
}
```

##### 2）普通二叉树的删除

```java
class Solution {
    public TreeNode deleteNode(TreeNode root, int key) {
        if(root == null) {
            return root;
        }
        if(root.val == key) {
            // 第二次操作目标值：最终删除的作用
            if(root.right == null) {
                return root.left;
            }
            TreeNode cur = root.right;
            while(cur.left != null) {
                cur = cur.left;
            }
            // 第一次操作目标值，交换目标值其右子树最左面节点的值
            int tmp = root.val;
            root.val = cur.val;
            cur.val = tmp;
        }
        root.left = deleteNode(root.left, key);
        root.right = deleteNode(root.right, key);
        return root;
    }
}
```

##### 3）迭代法

```java
class Solution {
    public TreeNode deleteNode(TreeNode root, int key) {
        if(root == null) return root;
        TreeNode cur = root;
        TreeNode pre = null;
        while(cur != null) {
            if(cur.val == key) break;
            pre = cur;
            if(cur.val > key) cur = cur.left;
            else cur = cur.right;
        }
        // 如果搜索树只有头节点
        if(pre == null) {
            return deleteOneNode(cur);
        }
        // pre 要知道是删左节点还是右节点
        if(pre.left != null && pre.left.val == key) {
            pre.left = deleteOneNode(cur);
        }
        if(pre.right != null && pre.right.val == key) {
            pre.right = deleteOneNode(cur);
        }
        return root;
    }
    /*
        将目标节点（删除结点）的左子树放到目标节点的右子树的最左面节点的左节点的位置上
        并返回目标节点右孩子作为新的根结点
        对应情况五
     */
    private TreeNode deleteOneNode(TreeNode target) {
        if(target == null) return target;
        if(target.right == null) return target.left;
        TreeNode cur = target.right;
        while(cur.left != null) {
            cur = cur.left;
        }
        cur.left = target.left;
        return target.right;
    }
}
```

### 669、修建二叉搜索树

#### 题目

题目链接：**[669. 修剪二叉搜索树 - 力扣（LeetCode）](https://leetcode.cn/problems/trim-a-binary-search-tree/)**

给你二叉搜索树的根节点 `root` ，同时给定最小边界`low` 和最大边界 `high`。通过修剪二叉搜索树，使得所有节点的值在`[low, high]`中。修剪树 **不应该** 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 **唯一的答案** 。

所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。

 

**示例 1：**

![img](E:/MyFile/TyporaImgs/trim1.jpg)

```
输入：root = [1,0,2], low = 1, high = 2
输出：[1,null,2]
```

**示例 2：**

![img](E:/MyFile/TyporaImgs/trim2.jpg)

```
输入：root = [3,0,4,null,2,null,null,1], low = 1, high = 3
输出：[3,2,null,1]
```

 

**提示：**

- 树中节点数在范围 `[1, 10^4]` 内
- `0 <= Node.val <= 10^4`
- 树中每个节点的值都是 **唯一** 的
- 题目数据保证输入是一棵有效的二叉搜索树
- `0 <= low <= high <= 10^4`

#### 思路

##### 1）递归法

> 直接想法就是：递归处理，然后遇到`root.val < low || root.val > high`的时候直接`return null`，
>
> ```java
> class Solution {
>     public TreeNode trimBST(TreeNode root, int low, int high) {
>         if (root == null || root.val < low || root.val > high)
>             return null;
>         root.left = trimBST(root.left, low, high);
>         root.right = trimBST(root.right, low, high);
>         return root;
>     }
> };
> ```
>
> **然⽽[1, 3]区间在⼆叉搜索树的中可不是单纯的节点3和左孩⼦节点0就决定的，还要考虑节点0的右⼦树。**
>
> 第二个示例：
>
> ![image-20221230104800238](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20221230104800238.png)
>
> 所以以上代码是行不通的

从图中可以看出需要重构二叉树，但其实不需要重构二叉树。

从上图中可以发现节点0不符合区间要求，那么将节点0的右节点2直接赋给节点3的左节点就可以了（就是把节点0从二叉树中移除）

<img src="E:/MyFile/TyporaImgs/image-20221230105457413.png" alt="image-20221230105457413" style="zoom: 67%;" />

递归三部曲：

1. 确定递归函数的参数以及返回值

   参数就是根结点和区间值。

   此处为什么需要返回值？因为是要遍历整棵树，做修改，其实不需要返回值也可以，同样可以完成修改（其实就是从二叉树中移除节点）的操作，但是有返回值，更方便，可以通过递归函数的返回值来移除节点

   ```java
   TreeNode trimBST(TreeNode root, int low, int high)
   ```

2. 确定终止条件

   修建的操作并不是在终止条件上进行的，所以遇到空节点返回就可以了

   ```java
   if(root == null) return root;
   ```

3. 确定单层递归的逻辑

   - 如果`root`（当前节点）的元素小于low的数值，那么应该递归右子树，并返回右子树符合条件的头节点。

     ```java
     if (root.val < low) {
         TreeNode right = trimBST(root.right, low, high); // 寻找符合区间[low, high]的节点
         return right;
     }
     ```

   - 如果`root`（当前节点）的元素大于high的数值，那么应该递归左子树，并返回左子树符合条件的头节点。

     ```java
     if (root.val > high) {
         TreeNode left = trimBST(root.left, low, high); // 寻找符合区间[low, high]的节点
         return left;
     }
     ```

   - 接下来要将下一层处理完的左子树的结果赋给`root.left`，处理完的右子树的结果赋给`root.right`，最后返回`root`节点

     ```java
     root.left = trimBST(root.left, low, right);// root.left接⼊符合条件的左孩⼦
     root.right = trimBST(root.right, low, right);// root.right接⼊符合条件的右孩⼦
     return root;
     ```

   > 回顾下移除节点的过程：
   >
   > <img src="E:/MyFile/TyporaImgs/image-20221230110655079.png" alt="image-20221230110655079" style="zoom:67%;" />
   >
   > 如下代码相当于把节点0的右节点（节点2）返回给上一层
   >
   > ```java
   > if (root.val < low) {
   >     TreeNode right = trimBST(root.right, low, high); // 寻找符合区间[low, high]的节点
   >     return right;
   > }
   > ```
   >
   > 然后如下代码相当于用节点3的左节点接收下一层返回的节点2
   >
   > ```java
   > root.left = trimBST(root.left, low, right);// root.left接⼊符合条件的左孩⼦
   > ```
   >
   > 此时节点3的左节点变成了节点2，将节点0从二叉树中移除了

##### 2）迭代法

因为二叉搜索树的有序性，不需要使用栈来模拟递归的过程

在剪枝的时候，可以分成三步：

- 将`root`移动到`[low, high]`范围内，注意是左闭右闭
- 剪枝左子树
- 剪枝右子树

#### 实现

##### 1）递归法

```java
class Solution {
    public TreeNode trimBST(TreeNode root, int low, int high) {
        if(root == null) return root;
        if(root.val < low) {
            return trimBST(root.right, low, high);
        }
        if(root.val > high) {
            return trimBST(root.left, low, high);
        }
        root.left = trimBST(root.left, low, high);
        root.right = trimBST(root.right, low, high);
        return root;
    } 
}
```

##### 2）迭代法

```java
class Solution {
    public TreeNode trimBST(TreeNode root, int low, int high) {
        if(root == null) return root;
        // 处理头结点，将root移动到[low, high]范围内，注意是左闭右闭
        while(root != null && (root.val > high || root.val < low)) {
            // 小于low 向右走
            if(root.val < low) root = root.right;
            // 大于high往左走
            else root = root.left;
        }
        TreeNode cur = root;
        // 此时root已经在[low, high]范围内，处理左节点元素小于low的情况
        while(cur != null) {
            while(cur.left != null && cur.left.val < low) {
                cur.left = cur.left.right;
            }
            cur = cur.left;
        }
        cur = root;
        // 此时root已经在[low, high]范围内，处理右节点元素大于high的情况
        while(cur != null) {
            while(cur.right != null && cur.right.val > high) {
                cur.right = cur.right.left;
            }
            cur = cur.right;
        }
        return root;
    }
}
```

### 108、将有序数组转换成为二叉搜索树

#### 题目

题目链接：

给你一个整数数组 `nums` ，其中元素已经按 **升序** 排列，请你将其转换为一棵 **高度平衡** 二叉搜索树。

**高度平衡** 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。

 

**示例 1：**

![img](E:/MyFile/TyporaImgs/btree1.jpg)

```
输入：nums = [-10,-3,0,5,9]
输出：[0,-3,9,-10,null,5]
解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：
```

<img src="E:/MyFile/TyporaImgs/image-20221230121012695.png" alt="image-20221230121012695" style="zoom:67%;" />

**示例 2：**

![img](E:/MyFile/TyporaImgs/btree.jpg)

```
输入：nums = [1,3]
输出：[3,1]
解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。
```

 

**提示：**

- `1 <= nums.length <= 10^4`
- `-10^4 <= nums[i] <= 10^4`
- `nums` 按 **严格递增** 顺序排列

#### 思路

> 本题其实不需要强调平衡二叉搜索树，数组构造二叉树，构造成平衡树是自然而然的事，因为默认都是从数组中间位置取值作为节点元素，一般不会随便取，所以想构造成不平衡的二叉树是自找麻烦

本题**本质就是寻找分割点，分割点作为当前节点，然后递归左区间和右区间**

> 本题其实比[654. 最大二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-binary-tree/)、[105. 从前序与中序遍历序列构造二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)、[106. 从中序与后序遍历序列构造二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)要简单一些，因为有序数组构造二叉搜索树，寻找分割点比较容易

**分割点就是数组中间位置的节点。**

> 问题：如果数组长度为偶数，中间结点有两个，取哪一个合适？
>
> 取哪一个都可以，只不过构成了不同的平衡二叉树
>
> 例如：[-10,-3,0,5,9]
>
> 如果要分割的数组长度为偶数的时候，中间元素为两个，是取左边元素就是树1，取右边元素就是树2（这也是题目中强调答案不唯一的原因）
>
> ![image-20221230122247062](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20221230122247062.png)

##### 1）递归

递归三部曲：

1. 确定递归函数的参数以及返回值

   删除二叉树节点、增加二叉树节点都是通过用递归函数的返回值来完成，这样相对方便。本题要构造二叉树，依然使用递归函数的返回值来构造中间结点的左右节点，返回值类型为`TreeNode`

   参数首先是传入数组，然后就是左闭右闭区间`[left, right]`，构造二叉树的时候尽量不要重新定义左右区间数组，而是使用下标的方式操作数组

   ```java
   // 左闭右闭区间[left, right]
   TreeNode traversal(int[] nums, int left, int right)
   ```

   **注意：左闭右闭区间是一个循环不变量**

2. 确定终止条件

   此处定义的是左闭右闭区间，所以当区间`left > right`的时候，就是空节点了

   ```java
   if(left > right) return null;
   ```

3. 确定单层递归的逻辑

   1）首先取数组中间元素的位置，`int mid = left + (right - left) / 2`

   2）构造节点：`TreeNode root = new TreeNode(nums[mid])`

   3）划分区间，root的左节点接收下一层左区间的构造的节点，右节点接收下一层右区间构造的节点

   4）返回`root`

   ```java
   ```

   > 这里`int mid = left + (right - left) / 2`的写法是向下取整的，也就是说如果数组长度为偶数，中间位置有两个元素，取靠左边的

##### 2）迭代法

迭代法可以通过三个队列来模拟，一个队列放遍历的节点，一个队列放左区间下标，一个队列放右区间下标

模拟的就是不断分割的过程

#### 实现

##### 1）递归法

```java
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        return traversal(nums, 0, nums.length - 1);
    }

    private TreeNode traversal(int[] nums, int left, int right) {
        if(left > right) return null;
        int mid = left + (right - left) / 2;
        TreeNode root = new TreeNode(nums[mid]);
        root.left = traversal(nums, left, mid - 1);
        root.right = traversal(nums, mid + 1, right);
        return root;
    }
}
```

##### 2）迭代法

```java
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        if(nums.length == 0) return null;
        // 初始化根结点
        TreeNode root = new TreeNode(0);
        // 存放遍历的节点
        Queue<TreeNode> nodeQueue = new LinkedList<>();
        // 存放左区间下标
        Queue<Integer> leftQueue = new LinkedList<>();
        // 存放右区间下标
        Queue<Integer> rightQueue = new LinkedList<>();
        // 根结点入队列
        nodeQueue.offer(root);
        // 0为左区间下标初始位置
        leftQueue.offer(0);
        // nums.length - 1为右区间下标初识位置
        rightQueue.offer(nums.length - 1);

        while(!nodeQueue.isEmpty()) {
            TreeNode curNode = nodeQueue.poll();
            int leftIndex = leftQueue.poll();
            int rightIndex = rightQueue.poll();
            int mid = leftIndex + (rightIndex - leftIndex) / 2;

            // 将mid对应的元素赋值给中间节点
            curNode.val = nums[mid];

            // 处理左区间
            if(leftIndex <= mid - 1) {
                curNode.left = new TreeNode(0);
                nodeQueue.offer(curNode.left);
                leftQueue.offer(leftIndex);
                rightQueue.offer(mid - 1);
            } 

            // 处理右区间
            if(rightIndex >= mid + 1) {
                curNode.right = new TreeNode(0);
                nodeQueue.offer(curNode.right);
                leftQueue.offer(mid + 1);
                rightQueue.offer(rightIndex);
            }
        }
        return root;
    }
}
```

### 538、把二叉搜索树转换为累加树

#### 题目

题目链接：**[538. 把二叉搜索树转换为累加树 - 力扣（LeetCode）](https://leetcode.cn/problems/convert-bst-to-greater-tree/)**

给出二叉 **搜索** 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 `node` 的新值等于原树中大于或等于 `node.val` 的值之和。

提醒一下，二叉搜索树满足下列约束条件：

- 节点的左子树仅包含键 **小于** 节点键的节点。
- 节点的右子树仅包含键 **大于** 节点键的节点。
- 左右子树也必须是二叉搜索树。

**示例 1：**

**![img](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/tree.png)**

```
输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]
输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]
```

**示例 2：**

```
输入：root = [0,null,1]
输出：[1,null,1]
```

**示例 3：**

```
输入：root = [1,0,2]
输出：[3,3,2]
```

**示例 4：**

```
输入：root = [3,2,4,1]
输出：[7,9,4,10]
```

 

**提示：**

- 树中的节点数介于 `0` 和 `10^4` 之间。
- 每个节点的值介于 `-10^4` 和 `10^4` 之间。
- 树中的所有值 **互不相同** 。
- 给定的树为二叉搜索树。

#### 思路

由于二叉搜索树是有序的，那么有序的元素如何求累加呢？

其实换个角度看，这就是一个有序数组，例如`[2, 5, 13]`，求从后到前的累加数组，也就是`[20, 18, 13]`

数组是从后向前遍历，那么二叉搜索树的累加顺序是**右中左**，所以我们需要**反中序遍历**这棵二叉树，然后顺序累加

##### 1）递归

反中序遍历流程：

![image-20221230125801624](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20221230125801624.png)

本题依然需要一个pre指针记录当前遍历结点cur的前一个节点，这样才方便做累加

递归三部曲：

1. 确定递归函数的参数和返回值

   此处不需要递归函数的返回值，因为要遍历整棵树

   同时需要定义一个全局变量pre，用来保存cur节点的前一个节点的数值，定义为`int`类型

   ```java
   int pre; // 记录前一个节点的数值
   void traversal(TreeNode cur)
   ```

2. 确定终止条件

   遇到空节点就返回

   ```java
   if(cur == null) return;
   ```

3. 确定单层递归的逻辑

   注意要**右中左**的顺序来遍历二叉树，中间节点的处理逻辑就是`cur.val += pre`

   ```java
   traversal(cur.right); // 右
   cur.val += pre; // 中
   pre = cur.val;
   traversal(cur.left); // 左
   ```

##### 2）迭代法

迭代法其实就是中序模板题

#### 实现

##### 1）递归

```java
class Solution {
    private int pre;
    public TreeNode convertBST(TreeNode root) {
        traversal(root);
        return root;
    }
    private void traversal(TreeNode cur) {
        if(cur == null) return;
        traversal(cur.right);
        cur.val += pre;
        pre = cur.val;
        traversal(cur.left);
    }
}
```

##### 2）迭代法

```java
class Solution {
    public TreeNode convertBST(TreeNode root) {
        if(root == null) return root;
        Deque<TreeNode> stack = new LinkedList<>();
        TreeNode cur = root;
        int pre = 0;
        while(cur != null || !stack.isEmpty()) {
            if(cur != null) {
                stack.push(cur);
                cur = cur.right; // 右
            } else {
                cur = stack.pop();
                cur.val += pre; // 中
                pre = cur.val;
                cur = cur.left; // 左
            }
        } 
        return root;
    }
}
```

# 二叉树篇--总结

上述题目分类

- 涉及到二叉树的构造，无论是普通二叉树还是二叉搜索树，一定是前序遍历，都是先构造中间结点
- 求普通二叉树的属性，一般是后序遍历，一般需要递归函数的返回值做处理
- 求二叉搜索树的属性，一定是中序遍历，利用好二叉搜索树的有序性

> 注意在普通二叉树的属性中，一般是后序遍历，也有例外，例如单纯求深度就使用前序遍历，**[257. 二叉树的所有路径 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-paths/)**也使用了前序，这是为了方便让父结点指向子节点，所以求普通二叉树的属性还是要具体问题具体分析
