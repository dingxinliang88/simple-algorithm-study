![回溯算法](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95.png)

<!--more-->



<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [算法学习之路--回溯篇](#%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF--%E5%9B%9E%E6%BA%AF%E7%AF%87)
  - [回溯算法理论基础](#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80)
    - [1、回溯算法是什么](#1%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88)
    - [2、回溯法的效率](#2%E5%9B%9E%E6%BA%AF%E6%B3%95%E7%9A%84%E6%95%88%E7%8E%87)
    - [3、回溯算法解决的问题](#3%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98)
    - [4、理解回溯算法](#4%E7%90%86%E8%A7%A3%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95)
    - [5、回溯法模板](#5%E5%9B%9E%E6%BA%AF%E6%B3%95%E6%A8%A1%E6%9D%BF)
  - [组合问题](#%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98)
    - [77、组合](#77%E7%BB%84%E5%90%88)
      - [题目](#%E9%A2%98%E7%9B%AE)
      - [思路](#%E6%80%9D%E8%B7%AF)
      - [实现](#%E5%AE%9E%E7%8E%B0)
      - [剪枝优化](#%E5%89%AA%E6%9E%9D%E4%BC%98%E5%8C%96)
    - [216、组合总和III](#216%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8Ciii)
      - [题目](#%E9%A2%98%E7%9B%AE-1)
      - [思路](#%E6%80%9D%E8%B7%AF-1)
      - [实现](#%E5%AE%9E%E7%8E%B0-1)
      - [剪枝优化](#%E5%89%AA%E6%9E%9D%E4%BC%98%E5%8C%96-1)
    - [17、电话号码的字母组合](#17%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88)
      - [题目](#%E9%A2%98%E7%9B%AE-2)
      - [思路](#%E6%80%9D%E8%B7%AF-2)
      - [实现](#%E5%AE%9E%E7%8E%B0-2)
    - [39、组合总和](#39%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C)
      - [题目](#%E9%A2%98%E7%9B%AE-3)
      - [思路](#%E6%80%9D%E8%B7%AF-3)
      - [实现](#%E5%AE%9E%E7%8E%B0-3)
      - [剪枝优化](#%E5%89%AA%E6%9E%9D%E4%BC%98%E5%8C%96-2)
    - [40、组合总和II](#40%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8Cii)
      - [题目](#%E9%A2%98%E7%9B%AE-4)
      - [思路](#%E6%80%9D%E8%B7%AF-4)
      - [实现](#%E5%AE%9E%E7%8E%B0-4)
  - [分割问题](#%E5%88%86%E5%89%B2%E9%97%AE%E9%A2%98)
    - [131、分割回文串](#131%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2)
      - [题目](#%E9%A2%98%E7%9B%AE-5)
      - [思路](#%E6%80%9D%E8%B7%AF-5)
      - [实现](#%E5%AE%9E%E7%8E%B0-5)
    - [93、复原IP地址](#93%E5%A4%8D%E5%8E%9Fip%E5%9C%B0%E5%9D%80)
      - [题目](#%E9%A2%98%E7%9B%AE-6)
      - [思路](#%E6%80%9D%E8%B7%AF-6)
      - [实现](#%E5%AE%9E%E7%8E%B0-6)
  - [子集问题](#%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98)
    - [78、子集](#78%E5%AD%90%E9%9B%86)
      - [题目](#%E9%A2%98%E7%9B%AE-7)
      - [思路](#%E6%80%9D%E8%B7%AF-7)
      - [实现](#%E5%AE%9E%E7%8E%B0-7)
    - [90、子集II](#90%E5%AD%90%E9%9B%86ii)
      - [题目](#%E9%A2%98%E7%9B%AE-8)
      - [思路](#%E6%80%9D%E8%B7%AF-8)
      - [实现](#%E5%AE%9E%E7%8E%B0-8)
  - [其他](#%E5%85%B6%E4%BB%96)
    - [491、递增子序列](#491%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97)
      - [题目](#%E9%A2%98%E7%9B%AE-9)
      - [思路](#%E6%80%9D%E8%B7%AF-9)
      - [实现](#%E5%AE%9E%E7%8E%B0-9)
    - [332、重新安排行程](#332%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B)
      - [题目](#%E9%A2%98%E7%9B%AE-10)
      - [思路](#%E6%80%9D%E8%B7%AF-10)
      - [实现](#%E5%AE%9E%E7%8E%B0-10)
  - [排列问题](#%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98)
    - [46、全排列](#46%E5%85%A8%E6%8E%92%E5%88%97)
      - [题目](#%E9%A2%98%E7%9B%AE-11)
      - [思路](#%E6%80%9D%E8%B7%AF-11)
      - [实现](#%E5%AE%9E%E7%8E%B0-11)
    - [47、全排列II](#47%E5%85%A8%E6%8E%92%E5%88%97ii)
      - [题目](#%E9%A2%98%E7%9B%AE-12)
      - [思路](#%E6%80%9D%E8%B7%AF-12)
      - [实现](#%E5%AE%9E%E7%8E%B0-12)
      - [扩展](#%E6%89%A9%E5%B1%95)
  - [棋盘问题](#%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98)
    - [51、N皇后](#51n%E7%9A%87%E5%90%8E)
      - [题目](#%E9%A2%98%E7%9B%AE-13)
      - [思路](#%E6%80%9D%E8%B7%AF-13)
      - [实现](#%E5%AE%9E%E7%8E%B0-13)
    - [37、解数独](#37%E8%A7%A3%E6%95%B0%E7%8B%AC)
      - [题目](#%E9%A2%98%E7%9B%AE-14)
      - [思路](#%E6%80%9D%E8%B7%AF-14)
      - [实现](#%E5%AE%9E%E7%8E%B0-14)
  - [补充：性能分析](#%E8%A1%A5%E5%85%85%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90)
    - [子集问题](#%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98-1)
    - [排列问题](#%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98-1)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

> 教程地址：[代码随想录 (programmercarl.com)](https://www.programmercarl.com/)

# 算法学习之路--回溯篇

##  回溯算法理论基础

### 1、回溯算法是什么

1）回溯法也可叫做回溯搜索法，它是一种搜索的方式。

2）回溯是递归的副产品，只要有递归就会有回溯。

3）回溯函数也就是递归函数，指向的都是一个函数

### 2、回溯法的效率

**虽然回溯法很难，很不好理解，但是回溯法并不是什么很高效的方法，**它的本质是**穷举**，穷举所有可能，然后选出我们想要的答案。如果想让回溯法高效一些，可以加一些剪枝操作，但是也改变不了回溯法就是穷举的本质。

> 为什么回溯法并不高效还要使用它呢？
>
> 因为没得选，一些问题能暴力搜出来就不错了，顶多在剪枝一下，还没有更高效的方法

### 3、回溯算法解决的问题

回溯法，一般可以解决如下的几种问题：

1. 组合问题：N个数里面按一定规则找出k个数的集合
2. 切割问题：一个字符串按一定规则有几种切割方式
3. 子集问题：一个N个数的集合里有多少符合条件的子集
4. 排列问题：N个数按一定规则全排列，有几种排列方式
5. 棋盘问题：N皇后、解数独等问题

> **组合不强调元素顺序，排列强调元素顺序**

### 4、理解回溯算法

1）**回溯法解决的问题都可以抽象为树形结构**

2）因为回溯法解决的都是在集合中递归查找自己，集合的大小就构成了树的宽度，递归的深度就构成了树的深度

3）只要是递归，就要有终止条件，所以必然是一颗高度有限的数（N叉树）

### 5、回溯法模板

1. 回溯函数模板返回值以及参数

   在回溯算法中，个人习惯给函数起名`backtracking`，回溯算法中函数的返回值一般为`void`

   回溯算法需要的参数不像二叉树递归的时候那么容易一次性确定下来，所以一般是先写逻辑，然后需要什么参数，就填什么参数。

   ```java
   void backtracking(params)
   ```

2. 回溯函数终止条件

   回溯既然是树形结构，就一定要有终止条件

   什么时候达到了终止条件，树中就可以看出来，一般来说搜索到叶子结点，也就找到了满足条件的一条答案，把这个答案保存起来，并结束本层递归

   ```java
   if(终止条件) {
       存放结果;
       return;
   }
   ```

3. 回溯搜索的遍历过程

   回溯算法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成了树的深度

   ![image-20221231101331107](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20221231101331107.png)

   注意图中举例的时候集合大小和节点的大小是相等的。

   ```java
   for(选择：本层集合中的元素（树中节点孩子的数量就是集合的大小）) {
       处理节点;
       backtracking(路径, 选择列表); // 递归
       回溯，撤销处理结果
   }
   ```

   for循环就是在遍历集合区间，可以理解为一个节点有多少个孩子结点，这个for循环就遍历多少次

   `backtracking`这里实现递归

   从图中可以看出，**for循环可以理解成横向遍历，backtracking（递归）就是纵向遍历**，这样把整棵树都遍历一遍，一般来说，搜索叶子结点就是找到其中一个结果了。

=> 回溯算法模板框架：

```java
void backtracking(params) {
    if(终止条件) {
        存放结果;
        return;
    }
    for(选择：本层集合中的元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径, 选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

---

##  组合问题

### 77、组合

#### 题目

题目链接：**[77. 组合 - 力扣（LeetCode）](https://leetcode.cn/problems/combinations/)**

给定两个整数 `n` 和 `k`，返回范围 `[1, n]` 中所有可能的 `k` 个数的组合。

你可以按 **任何顺序** 返回答案。

 

**示例 1：**

```
输入：n = 4, k = 2
输出：
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
```

**示例 2：**

```
输入：n = 1, k = 1
输出：[[1]]
```

 

**提示：**

- `1 <= n <= 20`
- `1 <= k <= n`

#### 思路

*本题是回溯法的经典题目*

直接的解法当然是使用for循环，总共k层循环，每层n次。

> 当n和k很大时，for循环根本无从下手。
>
> 回溯搜索法虽然也是暴力，但是至少能写出来。

**回溯法使用递归解决暴力写法的嵌套层数的问题**，递归做层叠嵌套（可以理解为是开k层for循环），**每一次递归中嵌套了一个for循环**，那么递归就可以用于解决多层嵌套循环的问题了**。**

**为了便于理解，一定一定要画树形结构！！！**

组合问题可以抽象成如下树形结构

![image-20221231104843102](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20221231104843102.png)

从图中可以看出，**每次从集合中选取元素，可选择的范围随着选择的进行而收缩。调整可选择的范围**

**图中可以发现，n相当于树的宽度，k相当于树的深度**

收集结果集：**图中每次搜索到叶子结点，就找熬了一个结果**，相当于只要把达到叶子节点的结果收集起来，就可以得到n个数中k个数的组合集合



回溯三部曲：

1. 回溯函数的返回值和参数

   在这里要定义两个全局变量，一个用来存放符合条件的单一结果，一个用来存放符合条件结果的集合

   ```java
   // 存放符合条件结果的集合
   List<List<Integer>> result;
   // 存放符合条件的结果
   LinkedList<Integer> path;
   ```

   > 其实此处不定义这两个全局变量也是可以的，可以把这两个变量放入回溯函数的参数中，但是函数中参数太多影响可读性。

   函数里一定要有的两个参数：n 和 k。然后还需要一个参数，为`int`类型的`startIndex`，这个参数用于记录本层递归中集合([1,2,...,n])从哪里开始遍历。

   `startIndex`的必要性：每次从集合中选取元素，**可选择的范围随着选择的进行而收缩，调整可选择的范围，就是要靠startIndex**

   从下图中红线部分可以看出，在集合[1,2,3,4]取1之后，下一层递归就要在[2,3,4]中取数，那么一下层递归就是靠`startIndex`知道从[2,3,4]中取数

   ![image-20221231110007838](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20221231110007838.png)

   ```java
   // 存放符合条件结果的集合
   List<List<Integer>> result;
   // 存放符合条件的结果
   LinkedList<Integer> path;
   void backtracking(int n, int k, int startIndex)
   ```

2. 回溯函数终止条件

   到达叶子结点的标志：path这个集合的大小如果到达了k，就说明找到了一个子集大小为k的组合了，在图中path保存的就是根结点到叶子结点的路径，如下图红色部分：

   ![image-20221231110655885](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20221231110655885.png)

   此时使用result集合把path保存起来，并终止本次递归

   ```java
   // 终止条件代码
   if(path.size() == k) {
       result.add(new ArrayList<>(path));
       return;
   }
   ```

3. 单层搜索的过程

   回溯法的搜索过程就是一个树形结构的遍历过程，for循环用来横向遍历，递归的过程是纵向遍历

   ![image-20221231110957339](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20221231110957339.png)

   for循环每次从`startIndex`开始遍历，然后使用`path`保存节点i

   ```java
   for(int i = startIndex; i <= n; i++) {
       // 处理节点
       path.add(i);
       // 递归：控制树的纵向遍历，注意下一层搜索要从 i+1 开始
       backtracking(n, k, i + 1);
       // 回溯，撤销处理的节点
       path.removeLast();
   }
   ```

   `backtracking`（递归函数）通过不断调用自己一直往深处遍历，总会遇到叶子结点，遇到叶子结点就返回。

   `backtracking`的下面部分就是回溯的操作了，撤销本次的处理结果

#### 实现

Java代码：

```java
class Solution {
    private List<List<Integer>> result;
    private LinkedList<Integer> path;

    public List<List<Integer>> combine(int n, int k) {
        result = new ArrayList<>();
        path = new LinkedList<>();
        backtracking(n, k, 1);
        return result;
    }

    private void backtracking(int n, int k, int stratIndex) {
        if(path.size() == k) {
            result.add(new ArrayList<>(path));
            return;
        }

        for(int i = stratIndex; i <= n; i++) {
            path.add(i);
            backtracking(n, k, i + 1);
            path.removeLast();
        }
    }
}
```

####  剪枝优化

*回溯算法虽然是暴力搜索，但有时候也可以进行剪枝优化的*

在遍历的过程中，有如下代码：

```java
for(int i = stratIndex; i <= n; i++) {
    path.add(i);
    backtracking(n, k, i + 1);
    path.removeLast();
}
```

这个遍历的范围是可以剪枝优化的

【举例】`n = 4, k = 4`，那么第一层for循环，从元素2开始都没有意义了，第二层for循环从元素3开始都没有意义了

![image-20230101091238992](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20230101091238992.png)

图中的每一个节点（图中为矩形），就代表本层的一个for循环，那么每一层的for循环从第二个数开始遍历的话，都没有意义，都是无效遍历

=> 所以，**可以剪枝的地方就在递归中每一层的for循环所选择的起始位置**，如果for循环选择的起始位置之后的元素已经不足我们需要的元素了，那么就没有必要再搜索了。

注意代码中的`i`，就是for循环里选择的起始位置

```java
for(int i = stratIndex; i <= n; i++) {
```

优化的过程：

1. 已经选择的元素个数：`path.size()`

2. 还需要选择的元素个数：`k - path.size()`

3. 在集合n中至多要从该起始位置：`n - (k - path.size()) + 1`开始遍历

   > `+ 1`的原因：
   >
   > 因为包括起始位置，我们需要的是一个左闭右闭的集合
   >
   > 举个栗子：`n = 4, k = 3`，目前已经选择元素个数为0(`path.size() = 0`)，`n - (k - 1) + 1 = 4 - (3 - 0) + 1 = 2`，从2开始搜索都是合理的，可以是组合`[2,3,4]`

=> 优化之后的for循环：

```java
for(int i = startIndex; i <= n - (k - path.size()) + 1; i++) {
    // i 为本次搜索的起始位置
}
```

优化后的代码实现：

```java
class Solution {
    private List<List<Integer>> result;
    private LinkedList<Integer> path;

    public List<List<Integer>> combine(int n, int k) {
        result = new ArrayList<>();
        path = new LinkedList<>();
        backtracking(n, k, 1);
        return result;
    }

    private void backtracking(int n, int k, int stratIndex) {
        if(path.size() == k) {
            result.add(new ArrayList<>(path));
            return;
        }

        for(int i = stratIndex; i <= n - (k - path.size()) + 1; i++) {
            path.add(i);
            backtracking(n, k, i + 1);
            path.removeLast();
        }
    }
}
```

### 216、组合总和III

#### 题目

题目链接：**[216. 组合总和 III - 力扣（LeetCode）](https://leetcode.cn/problems/combination-sum-iii/)**

找出所有相加之和为 `n` 的 `k` 个数的组合，且满足下列条件：

- 只使用数字1到9
- 每个数字 **最多使用一次** 

返回 *所有可能的有效组合的列表* 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。

 

**示例 1:**

```
输入: k = 3, n = 7
输出: [[1,2,4]]
解释:
1 + 2 + 4 = 7
没有其他符合的组合了。
```

**示例 2:**

```
输入: k = 3, n = 9
输出: [[1,2,6], [1,3,5], [2,3,4]]
解释:
1 + 2 + 6 = 9
1 + 3 + 5 = 9
2 + 3 + 4 = 9
没有其他符合的组合了。
```

**示例 3:**

```
输入: k = 4, n = 1
输出: []
解释: 不存在有效的组合。
在[1,9]范围内使用4个不同的数字，我们可以得到的最小和是1+2+3+4 = 10，因为10 > 1，没有有效的组合。
```

 

**提示:**

- `2 <= k <= 9`
- `1 <= n <= 60`

#### 思路

本题就是在`[1,2,3,4,5,6,7,8,9]`这个集合中找到和为n的k个数的组合

相比于**[77. 组合 - 力扣（LeetCode）](https://leetcode.cn/problems/combinations/)**，只是多了一个限制，本题是要找到和为n的k个数的组合，而整个集合已经是固定的`[1,2,3,4,5,6,7,8,9]`

本题 k 相当于树的深度， 9 （也就是集合的长度）就是树的宽度

【例子】`k = 2, n = 4`，就是在集合`[1,2,3,4,5,6,7,8,9]`中求 k （个数）= 2，n（和） = 4的组合

![image-20230101094423175](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20230101094423175.png)

图中可以看出，只有组合[1,3]符合条件



回溯三部曲：

1. 确定回溯函数的参数

   和**[77. 组合 - 力扣（LeetCode）](https://leetcode.cn/problems/combinations/)**一样，依然需要集合`path`来存放符合条件的结果，集合`result`来存放结果集

   ```java
   // 存放符合条件结果的集合
   List<List<Integer>> result;
   // 存放符合条件的结果
   LinkedList<Integer> path;
   ```

   参数：

   - `targetSum(int)`目标和，也就是题目中的n
   - `k(int)`，就是题目中的k
   - `sum(int)`为已经收集的元素的总和，也就是`path`里的元素的总和
   - `startIndex(int)`为下一层for循环搜索的起始位置

   ```java
   // 存放符合条件结果的集合
   List<List<Integer>> result;
   // 存放符合条件的结果
   LinkedList<Integer> path;
   void backtracking(int targetSum, int k, int sum, int startIndex)
   ```

   其实这个`sum(int)`参数可以省略，每次`targetSum`减去选取元素的数值，然后判断`targetSum ?= 0`，如果是，说明收集到符合条件的结果了

   > 强调一点：回溯法中递归函数的参数很难一次性确定下来，一般先写逻辑，需要啥参数再填写啥参数

2. 确定终止条件

   上述 k 其实就已经限制了树的深度，因为就取k个元素，树再往下深没有意义，所以如果`path.size() == k`，就终止，如果此时`path`里收集到的元素和(`sum`)和`targetSum`（就是题目中描述的n)相等，就用`result`收集当前的结果

   ```java
   if(path.size() == k) {
       if(sum == targetSum) result.add(new ArrayList<>(path));
       return; // 如果`path.size() == k 而 sum != targetSum 直接返回
   }
   ```

3. 单层搜索逻辑

   本题和**[77. 组合 - 力扣（LeetCode）](https://leetcode.cn/problems/combinations/)**区别之一就是集合固定就是9个数[1,2,3,4,5,6,7,8,9]，所以for循环固定为`i <= 9`

   处理过程就是`path`收集每次选取的元素，相当于树型结构里的边，`sum`来统计`path`里元素的总和

   ```java
   for(int i = startIndex; i <= 9; i++) {
       sum += i;
       path.add(i);
       backtracking(targetSum, k, sum, i + 1); // 注意startIndex 调整为 i + 1
       sum -= i; // 回溯
       path.removeLast(); // 回溯
   }
   ```

   **处理过程和回溯过程是一一对应的，处理有加，回溯就要有减**

#### 实现

java代码：

```java
class Solution {
    private List<List<Integer>> result;
    private LinkedList<Integer> path;

    public List<List<Integer>> combinationSum3(int k, int n) {
        result = new ArrayList<>();
        path = new LinkedList<>();
        traversal(n, k, 0, 1);
        return result;
    }

    private void traversal(int targetSum, int k, int sum, int startIndex) {
        if(path.size() == k) {
            if(targetSum == sum) {
                result.add(new ArrayList<>(path));
            }
            return;
        }

        for(int i = startIndex; i <= 9; i++) {
            path.add(i);
            sum += i;
            traversal(targetSum, k, sum, i + 1);
            sum -= i;
            path.removeLast();
        }
    }
}
```

#### 剪枝优化

![image-20230101100545915](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20230101100545915.png)

已选元素总和如果大于n了，那么再往后遍历就没有意义了，直接剪枝

那么剪枝的地方一定是在递归终止的地方

```java
if(sum > targetSum) {
    // 剪枝操作
    return;
}
```

for循环范围也可以剪枝，`i <= 9 - (k - path.size()) + 1`就可以了

剪枝优化后代码：

```java
class Solution {
    private List<List<Integer>> result;
    private LinkedList<Integer> path;

    public List<List<Integer>> combinationSum3(int k, int n) {
        result = new ArrayList<>();
        path = new LinkedList<>();
        traversal(n, k, 0, 1);
        return result;
    }

    private void traversal(int targetSum, int k, int sum, int startIndex) {
        if(sum > targetSum) {
            return;
        }
        if(path.size() == k) {
            if(targetSum == sum) {
                result.add(new ArrayList<>(path));
            }
            return;
        }

        for(int i = startIndex; i <= 9 - (k - path.size()) + 1; i++) {
            path.add(i);
            sum += i;
            traversal(targetSum, k, sum, i + 1);
            sum -= i;
            path.removeLast();
        }
    }
}
```

### 17、电话号码的字母组合

#### 题目

题目链接：**[17. 电话号码的字母组合 - 力扣（LeetCode）](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)**

给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。答案可以按 **任意顺序** 返回。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

![img](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/200px-telephone-keypad2svg.png)

 

**示例 1：**

```
输入：digits = "23"
输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]
```

**示例 2：**

```
输入：digits = ""
输出：[]
```

**示例 3：**

```
输入：digits = "2"
输出：["a","b","c"]
```

 

**提示：**

- `0 <= digits.length <= 4`
- `digits[i]` 是范围 `['2', '9']` 的一个数字。

#### 思路

理解题意之后，要解决三个问题：

1. 数字和字母如何映射
2. 解决for多重循环
3. 输入`1*#`按键等等异常情况

**数字和字母如何映射**

使用Map或者定义一个二维数组，此处使用Map集合

```java
Map<Character,String> phoneMap = new HashMap<>(){{
    put('2',"abc");
    put('3', "def");
    put('4', "ghi");
    put('5', "jkl");
    put('6', "mno");
    put('7', "pqrs");
    put('8', "tuv");
    put('9', "wxyz");
}};
```

**回溯法解决n个for循环的问题**

![image-20230102102458661](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20230102102458661.png)

图中可以看出遍历的深度就是输入"23"的长度，而叶子结点就是要收集的结果，输出["ad","ae","af","bd","be","bf","cd","ce","cf"]

回溯三部曲：

1. 确定回溯函数的参数

   首先需要一个字符串集合result保存结果，需要一个`StringBuffer`来收集结果（此处放到参数列表），这两个可以定义为全局变量

   参数指定是有题目给定的`dights`，还需要一个参数就是`int`型的`index`，记录遍历到第几个数字了，就是用来遍历`dights`的，同时`index`也表示是树的深度

   ```java
   List<String> result;
   void backtracking(String dights, int index, StringBuffer s;)
   ```

2. 确定终止条件

   输入几个数字就递归几层，所以终止条件就是如果`index == dights.size()`，然后就收集结果，结束本层递归

   ```java
   if(index == dights.size()) {
       result.add(s.toString());
       return;
   }
   ```

3. 确定单层遍历的逻辑

   首先要取`index`指向的数字，并找到对应的字符集（手机键盘的字符集）

   然后使用for循环来处理这个for循环

   ```java
   char ch = dights.charAt(index);
   // 取数字对应的字符集
   String letters = phoneMap.get(ch);
   for(int i = 0; i < letters.length(); i++) {
       // 处理
       s.append(letters.charAt(i));
       // 递归，注意index+1，下一层要处理下一个数字了
       backtracking(dights, index + 1, s);
       // 回溯
       s.deleteCharAt(index);
   }
   ```

   此处的for循环是从0开始的，因为本题每个数字代表的是不同集合，也就是求不同集合之间的组合，而`LeetCode 76`和`LeetCode 216`都是求同一个集合中的组合！

**注意：输入`1*#`按键等等异常情况**

代码中最好考虑此类异常情况（加个if判断即可，如果是则跳过或者报异常），考虑到测试数据中没有异常情况和的数据，此处不加。**面试的时候问到一定要考虑到**

#### 实现

Java代码

```java
class Solution {
    private List<String> result;
    private Map<Character, String> phoneMap = new HashMap<>(){{
                put('2',"abc");
                put('3', "def");
                put('4', "ghi");
                put('5', "jkl");
                put('6', "mno");
                put('7', "pqrs");
                put('8', "tuv");
                put('9', "wxyz");
            }};
    public List<String> letterCombinations(String digits) {
        result = new ArrayList<>();
        if(digits.length() == 0) return result;
        backtracking(digits, 0, new StringBuffer());
        return result;
    }

    private void backtracking(String digits, int index, StringBuffer s) {
        if(index == digits.length()) {
            result.add(s.toString());
            return;
        }
        char ch = digits.charAt(index);
        String letters = phoneMap.get(ch);
        for(int i = 0; i < letters.length(); i++) {
            s.append(letters.charAt(i));
            backtracking(digits, index + 1, s);
            s.deleteCharAt(index);
        }
    }
}
```

### 39、组合总和

#### 题目

题目链接：**[39. 组合总和 - 力扣（LeetCode）](https://leetcode.cn/problems/combination-sum/)**

给你一个 **无重复元素** 的整数数组 `candidates` 和一个目标整数 `target` ，找出 `candidates` 中可以使数字和为目标数 `target` 的 所有 **不同组合** ，并以列表形式返回。你可以按 **任意顺序** 返回这些组合。

`candidates` 中的 **同一个** 数字可以 **无限制重复被选取** 。如果至少一个数字的被选数量不同，则两种组合是不同的。 

对于给定的输入，保证和为 `target` 的不同组合数少于 `150` 个。

 

**示例 1：**

```
输入：candidates = [2,3,6,7], target = 7
输出：[[2,2,3],[7]]
解释：
2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。
7 也是一个候选， 7 = 7 。
仅有这两种组合。
```

**示例 2：**

```
输入: candidates = [2,3,5], target = 8
输出: [[2,2,2,2],[2,3,3],[3,5]]
```

**示例 3：**

```
输入: candidates = [2], target = 1
输出: []
```

 

**提示：**

- `1 <= candidates.length <= 30`
- `2 <= candidates[i] <= 40`
- `candidates` 的所有元素 **互不相同**
- `1 <= target <= 40`

#### 思路

> 题目中提示`2 <= candidates[i] <= 40`，所以不需要考虑0

本题和`LeetCode 77`、`LeetCode 216`的区别是：本题没有数量要求，可以无限重复，但是有总和的限制，所以间接的也是有个数的限制

以`candidates = [2,5,8], target = 4`为例

![image-20230102112125217](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20230102112125217.png)

注意图中叶子结点的返回条件，因为本题没有组合数量要求，仅仅是总和的限制，所以递归没有层数的限制，只要选取的元素总和超过`target`就返回

回溯三部曲：

1. 确定递归函数的参数

   两个集合：`result`存放结果集、`path`存放符合条件的结果

   参数：集合`candidates`、目标值`target`、`sum(int)`来统一单一结果`path`里的总和，其实也可以不要，每次使用`target`做减法就可以了，最后如果`target == 0`就说明找到符合的结果了

   本题还需要`startIndex`来控制for循环的起始位置

   > 对于**组合问题**，什么时候需要`startIndex`呢？
   >
   > - 如果是⼀个集合来求组合的话，就需要`startIndex`
   > - 如果是多个集合取组合，各个集合之间相互不影响，那么就不用`startIndex`

   ```java
   List<List<Integer>> result;
   LinkedList<Integer> path;
   void backtracking(int[] candidates, int target, int sum, int startIndex)
   ```

2. 递归终止条件

   从上图叶子结点可以清晰看出，终止只有两种情况，`sum > target`、`sum == target`

   ```java
   if(sum > target) return;
   if(sum == target) {
       result.add(new ArrayList<>(path));
       return;
   }
   ```

3. 单层搜索的逻辑

   单层for循环依然是从`startIndex`开始，搜索`candidates`集合

   注意：**本题的元素为可重复选取**

   ```java
   for(int i = startIndex; i <= candidates.length; i++) {
       sum += candidates[i];
       path.add(candidates[i]);
       backtracking(candidates, target, sum, i); // 关键点：不使用 i+1，表示可以重复读取当前数
       // 回溯
       sum -= candidates[i];
       path.removeLast();
   }
   ```

#### 实现

Java代码

```java
class Solution {
    private List<List<Integer>> result;
    private LinkedList<Integer> path;
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        result = new ArrayList<>();
        path = new LinkedList<>();
        backtracking(candidates, target, 0, 0);
        return result;
    }

    private void backtracking(int[] candidates, int target, int sum, int startIndex) {
        if(sum > target) return;
        if(sum == target) {
            result.add(new ArrayList<>(path));
            return;
        }
        for(int i = startIndex; i < candidates.length; i++) {
            sum += candidates[i];
            path.add(candidates[i]);
            backtracking(candidates, target, sum, i);
            sum -= candidates[i];
            path.removeLast();
        }
    }
}
```

#### 剪枝优化

![image-20230102123647370](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20230102123647370.png)

在未优化之前，对于`sum > target`的情况，依然是进入下一层递归，只是下一层递归结束判断的时候，会判断出`sum > target`就返回

其实如果已经知道下一层的`sum > target`，就没有必要进入下一层循环了

可以再for循环的搜索范围上做文章，**对总集合排序之后，如果下一层的sum（就是本层的sum + candidates[i]）已经大于target，就可以结束本轮的for循环遍历**

![image-20230102124726423](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20230102124726423.png)

for循环剪枝代码：

```java
for(int i = startIndex; i < candidates.length && sum + candidates[i] <= target; i++)
```

剪枝优化后代码实现：

```java
class Solution {
    private List<List<Integer>> result;
    private LinkedList<Integer> path;
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        result = new ArrayList<>();
        path = new LinkedList<>();
        // 排序
        Arrays.sort(candidates);
        backtracking(candidates, target, 0, 0);
        return result;
    }

    private void backtracking(int[] candidates, int target, int sum, int startIndex) {
        if(sum == target) {
            result.add(new ArrayList<>(path));
            return;
        }
        // 如果 sum + candidates[i] > target直接结束本层的for循环
        for(int i = startIndex; i < candidates.length && sum + candidates[i] <= target; i++) {
            sum += candidates[i];
            path.add(candidates[i]);
            backtracking(candidates, target, sum, i);
            sum -= candidates[i];
            path.removeLast();
        }
    }
}
```



### 40、组合总和II

#### 题目

题目链接：**[40. 组合总和 II - 力扣（LeetCode）](https://leetcode.cn/problems/combination-sum-ii/)**

给定一个候选人编号的集合 `candidates` 和一个目标数 `target` ，找出 `candidates` 中所有可以使数字和为 `target` 的组合。

`candidates` 中的每个数字在每个组合中只能使用 **一次** 。

**注意：**解集不能包含重复的组合。 

 

**示例 1:**

```
输入: candidates = [10,1,2,7,6,1,5], target = 8,
输出:
[
[1,1,6],
[1,2,5],
[1,7],
[2,6]
]
```

**示例 2:**

```
输入: candidates = [2,5,2,1,2], target = 5,
输出:
[
[1,2,2],
[5]
]
```

 

**提示:**

- `1 <= candidates.length <= 100`
- `1 <= candidates[i] <= 50`
- `1 <= target <= 30`

#### 思路

本题和`LeetCode39 组合总和`有如下区别：

- 本题`candidates`中的每个数字在每个组合中只能使用一次
- 本题数组`candidates`的元素是有重复的，而`LeetCode39`是无重复元素的数组`candidates`

最后要求都是一样的：解集不能包含重复的组合

本题的难点：**集合（数组candidates）包含重复元素，但是不能有重复的组合**

> 方案一：先求出所有组合，再使用`Set`或者`Map`去重 => 容易超时
>
> 方案二：在搜索的过程中就去掉重复组合 ✔

**组合问题可以抽象为树形结构，那么“使用过”在这个树形结构上是有两个维度的，一个维度是同一树枝上使用过，一个维度是在同一树层上使用过。**

题目中描述的是：元素在同一个组合内是可以重复的，但两个组合不能重复 => **要去重的是同一树层上“使用过”，同一树枝上都是一个组合里的元素，不需要去重**

**树层去重，需要对数组排序**

【例子】`candidates=[1,1,2]，target=3`

![image-20230103085550824](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20230103085550824.png)

图中可以看出，每个节点都加了`used`数组，用来记录同一树枝上的元素是否使用过

回溯三部曲：

1. 确认递归函数参数以及返回值

   和`LeetCode 39`套路相同，此题还需要加一个`boolean`类型的集合`used`，用来记录同一树枝上的元素是否使用过（集合去重）

   ```java
   List<List<Integer>> result;
   LinkedList<Integer> path;
   void backtracking(int[] candidates, int target, int sum, int startIndex, boolean[] used)
   ```

2. 确定终止条件

   终止条件为：`sum > target`和`sum == target`

   ```java
   if(sum > target) return; // 这个条件可以省略，剪枝优化的时候
   if(sum == target) {
       result.add(new ArrayList<>(path));
       return;
   }
   ```

3. 单层搜索的逻辑

   判断同一树层上的元素（相同的元素）是否使用过：**如果`candidates[i] == candidates[i - 1] && used[i - 1] == false`，就说明前一个树枝使用了`candidiates[i]`，也就是说同一树层使用过`candidates[i - 1]`，**此时for循环里应该做`continue`操作

   ![image-20230103090946393](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20230103090946393.png)

   从图中可以看出，当`candidates[i] == candidates[i - 1]`时

   - `used[i - 1] = true`，说明在同一树枝`candidates[i - 1]`使用过
   - `used[i - 1] = false`，说明在同一树层`candidates[i - 1]`使用过

   ```java
   for(int i = startIndex; i < candidates.length && sum + candidates[i] <= target; i++) {
       // 对在同一树层上使用过的元素跳过
       if(i > 0 && candidates[i] == candidates[i - 1] && !used[i - 1]) {
           continue;
       }
       sum += candidates[i];
       path.add(candidates[i]);
       used[i] = true;
       backtracking(candidates, target, sum, i + 1, used);
       // 回溯
       sum -= candidates[i];
       path.removeLast();
       used[i] = false;
   }
   ```

#### 实现

Java 代码

```java
class Solution {
    private List<List<Integer>> result;
    private LinkedList<Integer> path;
    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        result = new ArrayList<>();
        path = new LinkedList<>();
        // 排序，让相同的元素都挨在⼀起
        Arrays.sort(candidates);
        backtracking(candidates, target, 0, 0, new boolean[candidates.length]);
        return result;
    }

    private void backtracking(int[] candidates, int target, int sum, int startIndex, boolean[] used) {
        if(sum == target) {
            result.add(new ArrayList<>(path));
            return; 
        }
        for(int i = startIndex; i < candidates.length && sum + candidates[i] <= target; i++) {
            // 对在同一树层上使用过的元素跳过
            if(i > 0 && candidates[i] == candidates[i - 1] && !used[i - 1]) {
                continue;
            }
            sum += candidates[i];
            path.add(candidates[i]);
            used[i] = true;
            backtracking(candidates, target, sum, i + 1, used);
            // 回溯
            sum -= candidates[i];
            path.removeLast();
            used[i] = false;
        }
    }
}
```

##  分割问题

### 131、分割回文串

#### 题目

题目链接：**[131. 分割回文串 - 力扣（LeetCode）](https://leetcode.cn/problems/palindrome-partitioning/)**

给你一个字符串 `s`，请你将 `s` 分割成一些子串，使每个子串都是 **回文串** 。返回 `s` 所有可能的分割方案。

**回文串** 是正着读和反着读都一样的字符串。

 

**示例 1：**

```
输入：s = "aab"
输出：[["a","a","b"],["aa","b"]]
```

**示例 2：**

```
输入：s = "a"
输出：[["a"]]
```

 

**提示：**

- `1 <= s.length <= 16`
- `s` 仅由小写英文字母组成

#### 思路

本题涉及的两个关键问题：

- 切割问题，有不同的切割方式
- 判断回文

> 回溯法是如何切割字符串的：
>
> 对于字符串`abcdef`
>
> - 组合问题：选取一个a之后，在bcdef中再去选第二个，选取b之后再在cdef中选取第三个……
> - 切割问题：切割一个a之后，在bcdef中再切割第二段，切割b之后再在cdef中切割第三段……

![image-20230103093900030](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20230103093900030.png)

递归用来纵向遍历，for循环用来横向遍历，切割线（图中的红线）切割到字符串的结尾，说明找到了一个切割方法

回溯三部曲：

1. 确定递归函数的参数

   两个集合：`result`存放结果集、`path`存放符合切割后的回文的子串

   参数需要`startIndex`来控制for循环的起始位置，因为切割过的地方不能重复切割

   ```java
   List<List<String>> result;
   Deque<String> path;
   void backtracking(String s, int startIndex)
   ```

2. 确认递归函数终止条件

   从上图中可以看出，切割线到了字符串的最后面，就说明找到了一种切割方法，此时就是本层递归的终止条件

   代码中的切割线：在处理组合问题的时候，递归函数需要传入`startIndex`，表示下一轮递归遍历的起始位置，这个`startIndex`就是切割线

   ```java
   if(startIndex >= s.length()) {
       result.add(new ArrayList<>(path));
       return;
   }
   ```

3. 单层搜索的逻辑

   在for循环中，定义了起始位置，那么`[startIndex, i]`就是要截取的子串

   首先判断这个子串是不是回文，如果是回文，就加入到`path`中

   ```java
   for(int i = startIndex; i < s.length(); i++) {
       if(isPalindrome(s, startIndex, i)) {
           // 是回文子串
           String str = s.substring(startIndex, i + 1);
           path.addLast(str);
       } else {
           // 不是则跳过
           continue;
       }
       // 寻找以 i+1 为起始位置的子串
       backtracking(s, i + 1);
       path.removeLast();
   }
   ```

   **注意切割过的位置，不能重复切割，所以backtracking(s, i + 1)，传入下一层的起始位置为i+1**

   判断回文子串，使用双指针即可

   ```java
   boolean isPalindrome(String s, int start, int end) {
       for(int i = start, j = end; i < j; i++, j--) {
           if(s.charAt(i) != s.charAt(j)) {
               return false;
           }
       }
       return true;
   }
   ```

   

#### 实现

Java代码

```java
class Solution {
    private List<List<String>> result;
    private Deque<String> path;

    public List<List<String>> partition(String s) {
        result = new ArrayList<>();
        path = new LinkedList<>();
        backtraking(s, 0);
        return result;
    }

    private void backtraking(String s, int startIndex) {
        if(startIndex >= s.length()) {
            result.add(new ArrayList<>(path));
            return;
        }

        for(int i = startIndex; i < s.length(); i++) {
            if(isPalindrome(s, startIndex, i)) {
                String str = s.substring(startIndex, i + 1);
                path.addLast(str);
            } else {
                continue;
            }
            backtraking(s, i + 1);
            path.removeLast();
        }
    }

    private boolean isPalindrome(String s, int start, int end) {
        for(int i = start, j = end; i < j; i++, j--) {
            if(s.charAt(i) != s.charAt(j)) {
                return false;
            }
        }
        return true;
    }
}
```

### 93、复原IP地址

#### 题目

题目链接：**[93. 复原 IP 地址 - 力扣（LeetCode）](https://leetcode.cn/problems/restore-ip-addresses/)**

**有效 IP 地址** 正好由四个整数（每个整数位于 `0` 到 `255` 之间组成，且不能含有前导 `0`），整数之间用 `'.'` 分隔。

- 例如：`"0.1.2.201"` 和` "192.168.1.1"` 是 **有效** IP 地址，但是 `"0.011.255.245"`、`"192.168.1.312"` 和 `"192.168@1.1"` 是 **无效** IP 地址。

给定一个只包含数字的字符串 `s` ，用以表示一个 IP 地址，返回所有可能的**有效 IP 地址**，这些地址可以通过在 `s` 中插入 `'.'` 来形成。你 **不能** 重新排序或删除 `s` 中的任何数字。你可以按 **任何** 顺序返回答案。

 

**示例 1：**

```
输入：s = "25525511135"
输出：["255.255.11.135","255.255.111.35"]
```

**示例 2：**

```
输入：s = "0000"
输出：["0.0.0.0"]
```

**示例 3：**

```
输入：s = "101023"
输出：["1.0.10.23","1.0.102.3","10.1.0.23","10.10.2.3","101.0.2.3"]
```

 

**提示：**

- `1 <= s.length <= 20`
- `s` 仅由数字组成

#### 思路

> 本题是切割问题，**切割问题就可以使用回溯搜索法把可能性搜索出来**

![image-20230104153603092](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20230104153603092.png)

回溯三部曲：

1. 确定递归函数的参数

   参数：`startIndex`，因为不能重复分割，所以需要记录下一层递归分割的起始位置

   还需要一个变量`pointNum`，记录添加逗点的数量

   ```java
   List<String> result;
   void backtraking(String s, int startIndex, int pointNum)
   ```

2. 确定终止条件

   本题明确要求只会**分割成4段**，所以不能使用切割线切到最后作为终止条件，而是分割的段数作为终止条件

   `pointNum`表示逗点数量，所以`pointNum == 3`就说明字符串分成了4段，然后验证第四段是否合法，如果合法就添加到结果集

   ```java
   if(pointNum == 3) {
       if(isValid(s, startIndex, s.length() - 1)) {
           result.add(s);
       }
   }
   ```

3. 确认单层搜索的逻辑

   在for循环中，定义了起始位置，那么`[startIndex, i]`就是要截取的子串

   首先判断这个子串是否合法，如果合法就在字符串后面加上符号`.`表示已经分割，如果不合法就结束本层循环，就如上图剪去的分支

   然后就是递归和回溯的过程，下一层递归的`startIndex`要从`i+2`开始（因为需要在字符串中加入分隔符`.`），同时记录分隔符的数量的变量`pointNum`要加一，回溯的时候撤销上述递归的过程

   ```java
   for (int i = startIndex; i < s.length(); i++) {
       if (isValid(s, startIndex, i)) {
           s = s.substring(0, i + 1) + "." + s.substring(i + 1);    //在str的后⾯插⼊⼀个逗点
           pointNum++;
           backTrack(s, i + 2, pointNum);// 插⼊逗点之后下⼀个⼦串的起始位置为i+2
           pointNum--;// 回溯
           s = s.substring(0, i + 1) + s.substring(i + 2);// 回溯删掉逗点
       } else {
           break;
       }
   }
   ```

**判断子串是否合法**

主要考虑以下三点：

- 子串以0为开头的数字不合法
- 子串中有非正整数字符不合法
- 子串如果大于了255不合法

```java
boolean isValid(String s, int start, int end) {
    if (start > end) {
        return false;
    }
    if (s.charAt(start) == '0' && start != end) { // 0开头的数字不合法
        return false;
    }
    int num = 0;
    for (int i = start; i <= end; i++) {
        if (s.charAt(i) > '9' || s.charAt(i) < '0') { // 遇到⾮数字字符不合法
            return false;
        }
        num = num * 10 + (s.charAt(i) - '0');
        if (num > 255) { // 如果⼤于255了不合法
            return false;
        }
    }
    return true;
}
```



#### 实现

版本一：

```java
class Solution {
    List<String> result;

    public List<String> restoreIpAddresses(String s) {
        result = new ArrayList<>();
        if(s.length() > 12) return result;
        backtracking(s, 0, 0);
        return result;
    }

    private void backtracking(String s, int startIndex, int pointNum) {
        if(pointNum == 3) {
            if(isValid(s, startIndex, s.length() - 1)) {
                result.add(s);
                return;
            }
        }
        for(int i = startIndex; i < s.length(); i++) {
            if(isValid(s, startIndex, i)) {
                s = s.substring(0, i + 1) + "." + s.substring(i + 1);
                pointNum++;
                backtracking(s, i + 2, pointNum);
                pointNum--;
                s = s.substring(0, i + 1) + s.substring(i + 2);
            } else break;
        }
    }

    private boolean isValid(String s, int start, int end) {
        if(start > end) return false;
        if(s.charAt(start) == '0' && start != end) return false;
        int num = 0;
        for(int i = start; i <= end; i++) {
            char ch = s.charAt(i);
            if(ch < '0' || ch > '9') {
                return false;
            }
            num = num * 10 + (ch - '0');
            if(num > 255) return false;
        }
        return true;
    }
}
```

版本二（更好的剪枝优化）

```java
class Solution {
    List<String> result = new ArrayList<String>();
	StringBuilder stringBuilder = new StringBuilder();

	public List<String> restoreIpAddresses(String s) {
		backtracking(s, 0, 0);
		return result;
	}

	// number表示stringbuilder中ip段的数量
	public void backtracking(String s, int start, int number) {
		// 如果start等于s的长度并且ip段的数量是4，则加入结果集，并返回
		if (start == s.length() && number == 4) {
			result.add(stringBuilder.toString());
			return;
		}
		// 如果start等于s的长度但是ip段的数量不为4，或者ip段的数量为4但是start小于s的长度，则直接返回
		if (start == s.length() || number == 4) {
			return;
		}
		// 剪枝：ip段的长度最大是3，并且ip段处于[0,255]
		for (int i = start; i < s.length() && i - start < 3 && Integer.parseInt(s.substring(start, i + 1)) >= 0
				&& Integer.parseInt(s.substring(start, i + 1)) <= 255; i++) {
			// 如果ip段的长度大于1，并且第一位为0的话，continue
			if (i + 1 - start > 1 && s.charAt(start) - '0' == 0) {
				continue;
			}
			stringBuilder.append(s.substring(start, i + 1));
			// 当stringBuilder里的网段数量小于3时，才会加点；如果等于3，说明已经有3段了，最后一段不需要再加点
			if (number < 3) {
				stringBuilder.append(".");
			}
			number++;
			backtracking(s, i + 1, number);
			number--;
			// 删除当前stringBuilder最后一个网段，注意考虑点的数量的问题
			stringBuilder.delete(start + number, i + number + 2);
		}
    }
}
```

##  子集问题

### 78、子集

#### 题目

题目链接：**[78. 子集 - 力扣（LeetCode）](https://leetcode.cn/problems/subsets/)**

给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的子集（幂集）。

解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。

 

**示例 1：**

```
输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
```

**示例 2：**

```
输入：nums = [0]
输出：[[],[0]]
```

 

**提示：**

- `1 <= nums.length <= 10`
- `-10 <= nums[i] <= 10`
- `nums` 中的所有元素 **互不相同**

#### 思路

> 求**子集问题**和求**组合、分割**问题思路变化
>
> 如果把子集问题、组合问题、分割问题都抽象成一棵树的话，那么**组合问题和分割问题都是收集树的叶子结点，而子集问题是找树的所有节点**

其实子集问题也是一种组合问题，因为它的集合是无序的，子集`{1,2}`和子集`{2,1}`是一样的

=> **既然是无序，取过的元素不会重复取，写回溯算法的时候，for循环就要从startIndex开始，而不是从0开始**

> 从0开始的是**排列问题**

以`{1,2,3}`为例，把求子集抽象为树形结构

![image-20230104163542142](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20230104163542142.png)

从图中的红色部分，可以看出遍历整棵树的时候，把所有节点都记录下来，就是要求的子集集合

回溯三部曲：

1. 确认递归函数的参数

   ```java
   // 存放符合条件结果的集合
   List<List<Integer>> result;
   // 存放符合条件的结果
   Deque<Integer> path;
   void backtracking(int[] nums, int startIndex)
   ```

2. 确认终止条件

   从上图可以看出，剩余集合为空的时候，就是叶子结点，也就是当`startIndex >= nums.length`时，就终止了，因为没有元素可取了

   ```java
   if(startIndex >= nums.length) {
       return;
   }
   ```

   其实可以不需要加终止条件，因为`startIndex >= nums.length`的时候，本层for循环本来也要结束了

3. 确认单层搜索逻辑

   **求取子集问题，不需要任何的剪枝操作，因为子集就是要遍历整棵树**

   ```java
   for(int i = stratIndex; i < nums.length; i++) {
       path.addLast(nums[i]);
       backtracking(nums, startIndex);
       path.removeLast();
   }
   ```

   

#### 实现

Java代码

```java
class Solution {
    private List<List<Integer>> result;
    private Deque<Integer> path;

    public List<List<Integer>> subsets(int[] nums) {
        result = new ArrayList<>();
        path = new LinkedList<>();
        backtracking(nums, 0);
        return result;
    }

    private void backtracking(int[] nums, int startIndex) {
        result.add(new ArrayList<>(path)); // 收集⼦集，要放在终⽌添加的上面，否则会漏掉⾃⼰
		
        // 可以不加终止条件，因为每次都是从 i+1开始
        if(startIndex >= nums.length) {
            return;
        }

        for(int i = startIndex; i < nums.length; i++) {
            path.addLast(nums[i]);
            backtracking(nums, i + 1);
            path.removeLast();
        }
    }
}
```

### 90、子集II

#### 题目

题目链接：**[90. 子集 II - 力扣（LeetCode）](https://leetcode.cn/problems/subsets-ii/)**

给你一个整数数组 `nums` ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。

解集 **不能** 包含重复的子集。返回的解集中，子集可以按 **任意顺序** 排列。

 

**示例 1：**

```
输入：nums = [1,2,2]
输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]
```

**示例 2：**

```
输入：nums = [0]
输出：[[],[0]]
```

 

**提示：**

- `1 <= nums.length <= 10`
- `-10 <= nums[i] <= 10`

#### 思路

本题和**[78. 子集 - 力扣（LeetCode）](https://leetcode.cn/problems/subsets/)**区别就是集合里有重复元素了，而且求取的子集需要去重**树层去重**

以示例`{1, 2, 2}`为例（**注意去重需要先对集合进行排序**）

![image-20230104231023461](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20230104231023461.png)

#### 实现

java代码

```java
class Solution {
    List<List<Integer>> result;
    Deque<Integer> path;
    
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        result = new ArrayList<>();
        path = new LinkedList<>();
        Arrays.sort(nums);
        backtracking(nums, 0, new boolean[nums.length]);
        return result;
    }

    private void backtracking(int[] nums, int startIndex, boolean[] used) {
        result.add(new ArrayList<>(path));

        for(int i = startIndex; i < nums.length; i++) {
            if(i > 0 && nums[i] == nums[i - 1] && !used[i - 1]) {
                continue;
            }
            path.addLast(nums[i]);
            used[i] = true;
            backtracking(nums, i + 1, used);
            used[i] = false;
            path.removeLast();
        }
    }
}
```



## 其他

### 491、递增子序列

#### 题目

题目链接：**[491. 递增子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/non-decreasing-subsequences/)**

给你一个整数数组 `nums` ，找出并返回所有该数组中不同的递增子序列，递增子序列中 **至少有两个元素** 。你可以按 **任意顺序** 返回答案。

数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。

 

**示例 1：**

```
输入：nums = [4,6,7,7]
输出：[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]
```

**示例 2：**

```
输入：nums = [4,4,3,2,1]
输出：[[4,4]]
```

 

**提示：**

- `1 <= nums.length <= 15`
- `-100 <= nums[i] <= 100`

#### 思路

> 这个递增子序列比较像是取有序的子集，而且本题也要求不能有相同的递增子序列。
>
> => 子集，去重
>
> 本题思路类似于**求子集问题**，在`LeetCode 90`中，是通过排序，再加一个标记数组来达到去重的目的。
>
> 而本题求自增子序列，是不能对原数组进行排序的，排完序的数组都是自增子序列了，所以不能使用之间的去重逻辑。
>
> *本题给出的示例还是一个有序数组[4, 6, 7, 7]，更具有误导性，引导往排序的思路去做*

以`[4, 7, 6, 7]`为例：

![image-20230104233220419](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20230104233220419.png)

回溯三部曲：

1. 确定递归函数的参数

   本题求的是子序列，很明显一个元素不能重复使用，所以需要`startIndex`，调整下一层递归的起始位置

   ```java
   List<List<Integer>> result;
   Deque<Integer> path;
   void backtracking(int[] nums, int startIndex)
   ```

2. 确定终止条件

   本题其实类似求子集问题，也是要遍历树形结构找每一个节点，所以和**求子集问题**一样，可以不加终止条件，`startIndex`每次都会加1，并不会无限递归

   但是本题收集结果有所不同，题目要求递增子序列大小至少为2，所以代码如下：

   ```java
   if(path.size() > 1) {
       result.add(new ArrayList<>(path));
       // 注意这里不需要return，因为要取树上的所有节点
   }
   ```

3. 单层搜索逻辑

   如上图，**同一父结点下的同层上使用过的元素就不能再重复使用了**，判断是否使用过：

   - 使用`map`
   - 使用数组

   

#### 实现

使用`map`

```java
class Solution {
    List<List<Integer>> result;
    Deque<Integer> path;

    public List<List<Integer>> findSubsequences(int[] nums) {
        result = new ArrayList<>();
        path = new LinkedList<>();
        backtracking(nums, 0);
        return result;
    }

    private void backtracking(int[] nums, int startIndex) {
        if(path.size() > 1) {
            result.add(new ArrayList<>(path));
        } 
        Map<Integer, Integer> map = new HashMap<>();
        for(int i = startIndex; i < nums.length; i++) {
            if(!path.isEmpty() && path.getLast() > nums[i]) continue;
            // 当前数层使用过当前数字
            if(map.getOrDefault(nums[i], 0) > 0) {
                continue;
            }
            map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);
            path.addLast(nums[i]);
            backtracking(nums, i + 1);
            path.removeLast();
        }
    }
}
```

使用数组

```java
class Solution {
    List<List<Integer>> result;
    Deque<Integer> path;

    public List<List<Integer>> findSubsequences(int[] nums) {
        result = new ArrayList<>();
        path = new LinkedList<>();
        backtracking(nums, 0);
        return result;
    }

    private void backtracking(int[] nums, int startIndex) {
        if(path.size() > 1) {
            result.add(new ArrayList<>(path));
        } 

        int[] used = new int[201];
        
        for(int i = startIndex; i < nums.length; i++) {
            if(!path.isEmpty() && path.getLast() > nums[i]) continue;
            // 当前数层使用过当前数字, +100保证数组不越界
            if(used[nums[i] + 100] == 1) {
                continue;
            }
            used[nums[i] + 100] = 1;
            path.addLast(nums[i]);
            backtracking(nums, i + 1);
            path.removeLast();
        }
    }
}
```

### 332、重新安排行程

#### 题目

题目链接：**[332. 重新安排行程 - 力扣（LeetCode）](https://leetcode.cn/problems/reconstruct-itinerary/)**

给你一份航线列表 `tickets` ，其中 `tickets[i] = [fromi, toi]` 表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。

所有这些机票都属于一个从 `JFK`（肯尼迪国际机场）出发的先生，所以该行程必须从 `JFK` 开始。如果存在多种有效的行程，请你按字典排序返回最小的行程组合。

- 例如，行程 `["JFK", "LGA"]` 与 `["JFK", "LGB"]` 相比就更小，排序更靠前。

假定所有机票至少存在一种合理的行程。且所有的机票 必须都用一次 且 只能用一次。

 

**示例 1：**

![img](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/itinerary1-graph.jpg)

```
输入：tickets = [["MUC","LHR"],["JFK","MUC"],["SFO","SJC"],["LHR","SFO"]]
输出：["JFK","MUC","LHR","SFO","SJC"]
```

**示例 2：**

![img](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/itinerary2-graph.jpg)

```
输入：tickets = [["JFK","SFO"],["JFK","ATL"],["SFO","ATL"],["ATL","JFK"],["ATL","SFO"]]
输出：["JFK","ATL","JFK","SFO","ATL","SFO"]
解释：另一种有效的行程是 ["JFK","SFO","ATL","JFK","ATL","SFO"] ，但是它字典排序更大更靠后。
```

 

**提示：**

- `1 <= tickets.length <= 300`
- `tickets[i].length == 2`
- `fromi.length == 3`
- `toi.length == 3`
- `fromi` 和 `toi` 由大写英文字母组成
- `fromi != toi`



#### 思路

> 本题直观上来看跟回溯法没有关系，更像是图论中的深度优先搜索
>
> 实际上确实是dfs，但这是dfs中使用到了回溯的例子，在查找路径的时候，如果不回溯，怎么能查到目标路径呢。

**难点**

- 一个行程中，如果航班处理不好容易变成一个圈，成为死循环
- 有多种解法，字母序靠前排在前面，如何记录映射关系
- 使用回溯法（也可以说是dfs）的终止条件是什么
- 搜索的过程中，如何遍历一个机场所对应的所有机场

**理解死循环**

<img src="E:/MyFile/TyporaImgs/image-20230106094652769.png" alt="image-20230106094652769" style="zoom:67%;" />

从上图中可以看出，出发机场和到达机场也会重复的，如果**在解题的过程中，没有对集合元素处理好，就会死循环**

**记录映射关系**

使用如下的数据结构：

```java
Map<String, Map<String, Integer>> targets;
// => Map<出发机场, Map<到达机场, 航班次数>> targets
```

搜索的过程一定要**增删元素**，因为出发机场和到达机场是会重复的，搜索的过程没能及时删除目的机场就会死循环。

在遍历`targets`的过程中，**可以使用“航班次数”这个字段的数字做相应的增减，来标记机场是否使用过了**。如果“航班次数”大于0，说明目的地还可以飞，如果“航班次数”等于0，说明目的地不能飞了，而不用对集合做删除或者增加元素的操作了 => 逻辑删除，只是做了一个标记

**回溯法**

以`[["JFK","KUL"],["JFK","NRT"]，["NRT","JFK"]]`为例

<img src="E:/MyFile/TyporaImgs/image-20230106100407960.png" alt="image-20230106100407960" style="zoom:67%;" />

回溯三部曲：

1. 递归函数参数

   需要`targets`记录航班的映射关系，定义为全局变量（也可以写入参数列表）

   还需要一个全局变量`result`来记录行程信息（也可以写入参数列表）

   参数中还需要`ticketNum`，来表示有多少个航班。

   ```java
   Deque<String> result;
   Map<String, Map<String, Integer>> targets;
   boolean backtracking(int ticketNum);
   ```

   **注意函数的返回值为boolean**

   本题需要返回值是因为我们只需要找到一个行程，就是在树形结构中唯一一条通向叶子结点的路线（如上图），找到了这个叶子结点就直接返回。

   > **如果需要搜索整颗二叉树，那么递归函数就不要返回值，如果要搜索其中一条符合条件的路径，递归函数就需要返回值，因为遇到符合条件的路径了就要及时返回。**

   初始化`targets`和`result`

   ```java
   targets = new HashMap<>();
   result = new LinkedList<>();
   // 记录映射关系
   for(List<String> t : tickets){
       Map<String, Integer> temp;
       if(targets.containsKey(t.get(0))){
           temp = targets.get(t.get(0));
           temp.put(t.get(1), temp.getOrDefault(t.get(1), 0) + 1);
       }else{
           //升序Map
           temp = new TreeMap<>();
           temp.put(t.get(1), 1);
       }
       targets.put(t.get(0), temp);
   }
   // 初识机场
   result.add("JFK");
   ```

2. 递归终止条件

   以题目中所给的示例为例，`[["MUC","LHR"],["JFK","MUC"],["SFO","SJC"],["LHR","SFO"]]`，有4个航班，那么只要找出一种行程，行程里的机场个数是5就可以了

   所以终止条件是：在回溯遍历的过程中，遇到的机场个数如果达到了 航班数量 ＋ 1，那么就说明找到了一个行程，把所有航班串在一起

   ```java
   if(result.size() == ticketNum + 1) {
       return true;
   }
   ```

   > 此处不需要在叶子节点收集结果，因为本题的path(result)记录的路径只有一条，在单层搜索的时候就已经添加元素了

3. 单层搜索的逻辑

   ```java
   String last = result.getLast();
   if(targets.containsKey(last)){//防止出现null
       for(Map.Entry<String, Integer> target : targets.get(last).entrySet()){
           int count = target.getValue();
           // 记录到达机场是否飞过了
           if(count > 0){ 
               result.add(target.getKey());
               target.setValue(count - 1);
               if(backTracking(ticketNum)) return true;
               result.removeLast();
               target.setValue(count);
           }
       }
   }
   return false;
   ```

   利用`int count = target.getValue();`来判断集合里的机场是否使用过，避免了直接去删除元素

#### 实现

使用Map实现

```java
class Solution {
    private Deque<String> result;
    private Map<String, Map<String, Integer>> targets;

    public List<String> findItinerary(List<List<String>> tickets) {
        result = new LinkedList<>();
        targets = new HashMap<>();
        // 初始化
        for(List<String> ticket : tickets) {
            Map<String, Integer> temp;
            if(targets.containsKey(ticket.get(0))) {
                temp = targets.get(ticket.get(0));
                temp.put(ticket.get(1), temp.getOrDefault(ticket.get(1), 0) + 1);
            } else {
                temp = new TreeMap<>();
                temp.put(ticket.get(1), 1);
            }
            targets.put(ticket.get(0), temp);
        }
        result.add("JFK");
        backtraking(tickets.size());
        return new ArrayList<>(result);
    }

    private boolean backtraking(int ticketNum) {
        if(result.size() == ticketNum + 1) {
            return true;
        }
        String last = result.getLast();
        if(targets.containsKey(last)) {
            for(Map.Entry<String, Integer> target : targets.get(last).entrySet()) {
                int count = target.getValue();
                if(count > 0) {
                    result.addLast(target.getKey());
                    target.setValue(count - 1);
                    if(backtraking(ticketNum)) return true;
                    result.removeLast();
                    target.setValue(count);
                }
            }
        }
        return false;
    }
}
```

使用LinkedList实现

```java
class Solution {
    private LinkedList<String> res;
    private LinkedList<String> path = new LinkedList<>();

    public List<String> findItinerary(List<List<String>> tickets) {
        Collections.sort(tickets, (a, b) -> a.get(1).compareTo(b.get(1)));
        path.add("JFK");
        boolean[] used = new boolean[tickets.size()];
        backTracking((ArrayList) tickets, used);
        return res;
    }
    public boolean backTracking(ArrayList<List<String>> tickets, boolean[] used) {
        if (path.size() == tickets.size() + 1) {
            res = new LinkedList(path);
            return true;
        }

        for (int i = 0; i < tickets.size(); i++) {
            if (!used[i] && tickets.get(i).get(0).equals(path.getLast())) {
                path.add(tickets.get(i).get(1));
                used[i] = true;

                if (backTracking(tickets, used)) {
                    return true;
                }

                used[i] = false;
                path.removeLast();
            }
        }
        return false;
    }
}
```

## 排列问题

### 46、全排列

#### 题目

题目链接：**[46. 全排列 - 力扣（LeetCode）](https://leetcode.cn/problems/permutations/)**

定一个不含重复数字的数组 `nums` ，返回其 *所有可能的全排列* 。你可以 **按任意顺序** 返回答案。

 

**示例 1：**

```
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

**示例 2：**

```
输入：nums = [0,1]
输出：[[0,1],[1,0]]
```

**示例 3：**

```
输入：nums = [1]
输出：[[1]]
```

 

**提示：**

- `1 <= nums.length <= 6`
- `-10 <= nums[i] <= 10`
- `nums` 中的所有整数 **互不相同**

####  思路

以集合`{1, 2, 3}`为例

![image-20230105091456503](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20230105091456503.png)

回溯三部曲：

1. 确认递归函数的参数

   首先排列是有序的，也就是说`{1, 2}`和`{2, 1}`是两个不同的集合，这是和**子集**以及**组合**有所不同的地方。可以看出元素1在`{1, 2}`使用过一次，在`{2, 1}`还要使用一次，所以处理排列问题就不能再使用`startIndex`了，但是排列问题需要一个标记数组`used`，标记已经选择的元素

   ```java
   List<List<Integer>> result;
   Deque<Integer> path;
   void backtracking(int[] nums, boolean[] used)
   ```

2. 确定递归终止条件

   从上图可以看出，叶子结点就是要收集结果的地方。

   到达叶子结点的时机：当收集元素的集合`path`的大小和`num`数组一样大的时候，说明找到了一个全排列，也表明到达了叶子结点

   ```java
   if(path.size() == nums.length) {
   	result.add(new ArrayList<>(path));
       return;
   }
   ```

3. 单层搜索逻辑

   此处`for`循环里不需要使用`startIndex`了，因为排列问题，每次都要从头开始搜索，需要多次使用一个元素。而`used`数组，就是记录此时`path`里都使用了哪些元素，一个排列里一个元素只能使用一次。

   ```java
   for(int i = 0; i < nums.length; i++) {
   	// path已经收录的元素，直接跳过
       if(used[i]) continue;
       used[i] = true;
       path.addLast(nums[i]);
       backtracking(nums, used);
       path.removeLast();
       used[i] = false;
   }
   ```

   

#### 实现

```java
class Solution {

    List<List<Integer>> result;
    Deque<Integer> path;

    public List<List<Integer>> permute(int[] nums) {
        result = new ArrayList<>();
        path = new LinkedList<>();
        backtracking(nums, new boolean[nums.length]);
        return result;
    }

    private void backtracking(int[] nums, boolean[] used) {
        if(path.size() == nums.length) {
            result.add(new ArrayList<>(path));
            return;
        }

        for(int i = 0; i < nums.length; i++) {
            if(used[i]) continue;
            path.addLast(nums[i]);
            used[i] = true;
            backtracking(nums, used);
            used[i] = false;
            path.removeLast();
        }
    }
}
```

### 47、全排列II

#### 题目

题目链接：**[47. 全排列 II - 力扣（LeetCode）](https://leetcode.cn/problems/permutations-ii/)**

给定一个可包含重复数字的序列 `nums` ，***按任意顺序*** 返回所有不重复的全排列。

 

**示例 1：**

```
输入：nums = [1,1,2]
输出：
[[1,1,2],
 [1,2,1],
 [2,1,1]]
```

**示例 2：**

```
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

 

**提示：**

- `1 <= nums.length <= 8`
- `-10 <= nums[i] <= 10`

#### 思路

本题和`LeetCode 46`的区别在于**给定一个包含重复数字的序列，要返回所有不重复的全排列** => **去重（对元素进行排序）**

以序列`{1, 1, 2}`为例

![image-20230105094902780](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20230105094902780.png)

图中同一树层的元素要进行去重。一般来说，**组合问题和排列问题是在树形结构的叶子结点上收集结果，而子集问题就是取树上所有节点的结果**

#### 实现

```java
class Solution {

    List<List<Integer>> result;
    Deque<Integer> path;

    public List<List<Integer>> permuteUnique(int[] nums) {
        result = new ArrayList<>();
        path = new LinkedList<>();
        Arrays.sort(nums);
        backtracking(nums, new boolean[nums.length]);
        return result;
    }

    private void backtracking(int[] nums, boolean[] used) {
        if(path.size() == nums.length) {
            result.add(new ArrayList<>(path));
            return;
        }

        for(int i = 0; i < nums.length; i++) {
            if(i > 0 && nums[i - 1] == nums[i] && !used[i - 1]) {
                continue;
            }
            //如果同⼀树⽀nums[i]没使⽤过开始处理
            if(!used[i]) {
                path.addLast(nums[i]);
                used[i] = true;
                backtracking(nums, used);
                used[i] = false;
                path.removeLast();
            }
        }
    }
}
```

#### 扩展

**树枝去重** && **树层去重**

上述代码去重关键代码：

**树层去重**

```java
if(i > 0 && nums[i - 1] == nums[i] && !used[i - 1]) {
    continue;
}
```

**树枝去重**

如果改成`used[i] == true` ，也是正确的

```java
if(i > 0 && nums[i - 1] == nums[i] && used[i - 1]) {
    continue;
}
```

**对于排列问题，二者都可以，但是树层去重效率更高**

以输入`{1, 1, 1}`为例

**树层去重**

![image-20230105101809761](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20230105101809761.png)

**树枝去重**

![image-20230105102655074](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20230105102655074.png)

上图可以看出，**树层去重**对前一位去重非常彻底，效率很高，**树枝去重**对前一位去重虽然最后可以得到答案，但是做了很多无用的搜索。

## 棋盘问题

### 51、N皇后

#### 题目

题目链接：**[51. N 皇后 - 力扣（LeetCode）](https://leetcode.cn/problems/n-queens/)**

按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。

**n 皇后问题** 研究的是如何将 `n` 个皇后放置在 `n×n` 的棋盘上，并且使皇后彼此之间不能相互攻击。

给你一个整数 `n` ，返回所有不同的 **n 皇后问题** 的解决方案。

每一种解法包含一个不同的 **n 皇后问题** 的棋子放置方案，该方案中 `'Q'` 和 `'.'` 分别代表了皇后和空位。

 

**示例 1：**

![img](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/queens.jpg)

```
输入：n = 4
输出：[[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]
解释：如上图所示，4 皇后问题存在两个不同的解法。
```

**示例 2：**

```
输入：n = 1
输出：[["Q"]]
```

 

**提示：**

- `1 <= n <= 9`



#### 思路

本题的约束条件

- 不能同行
- 不能同列
- 不能同斜线

搜索皇后的位置 => 抽象为一棵树

以`n = 3`为例

![image-20230107101152385](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20230107101152385.png)

从图中可以看出二维矩阵中矩阵的搞就是这棵树的高度，矩阵的宽就是树形结构中每个节点的宽度 => 利用皇后的约束条件来回溯搜索这棵树，**只要搜索到了树的叶子结点，说明就找到了皇后们的合理位置**

回溯三部曲：

1. 确认递归函数参数

   定义全局变量`result`来记录最终的结果

   参数：`n`是棋盘的大小，`row`记录当前遍历到棋盘的第几层了，`chessboard`记录每种结果

   ```java
   List<List<String>> result;
   void backtracking(int n, int row, char[][] chessboard)
   ```

2. 递归终止条件

   收集叶子结点

   ```java
   if(row == n) {
   	result.add(Array2List(chessboard));
   }
   ```

3. 单层搜索的逻辑

   递归深度就是row控制棋盘的行，每一层的for循环的col控制棋盘的列，一行一列，确定了放置皇后的位置

   每次都是要从新的一行的起始位置开始搜，所以都是从0开始

   ```java
   for(int col = 0; col < n; col++) {
       if(isValid(row, col, chessboard, n)) {
           // 验证合法
           // 放置皇后
           chessboard[row][col] = 'Q'; 
       	backtracking(n, row + 1, chessboard);
           // 回溯，撤销皇后
           chessboard[row][col] = '.';
       }
   }
   ```

**验证棋盘是否合法**

按照本题的约束条件

- 不能同行
- 不能同列
- 不能同斜线（45°或者135°角）

```java
boolean isValid(int row, int col, int n, char[][] chessboard) {
    // 检查列
    for (int i = 0; i < row; i++) { // 相当于剪枝
        if (chessboard[i][col] == 'Q') {
            return false;
        }
    }

    // 检查45度对角线
    for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {
        if (chessboard[i][j] == 'Q') {
            return false;
        }
    }

    // 检查135度对角线
    for (int i = row - 1, j = col + 1; i >= 0 && j <= n - 1; i--, j++) {
        if (chessboard[i][j] == 'Q') {
            return false;
        }
    }
    return true;
}
```

上述代码没有对行进行检查，因为在单层搜索的过程中，每一层的递归，只会选取for循环（也就是同一行）里的元素，所以不需要去重了

#### 实现

```java
class Solution {

    private List<List<String>> result;

    public List<List<String>> solveNQueens(int n) {
        result = new ArrayList<>();
        char[][] chessboard = new char[n][n];
        for(char[] c : chessboard) {
            Arrays.fill(c, '.');
        }
        
        backtracking(n, 0, chessboard);
        return result;
    }

    private void backtracking(int n, int row, char[][] chessboard) {
        if(n == row) {
            result.add(Array2List(chessboard));
            return;
        }

        for(int col = 0; col < n; col++) {
            if(isValid(row, col, n, chessboard)) {
                chessboard[row][col] = 'Q';
                backtracking(n, row + 1, chessboard);
                chessboard[row][col] = '.';
            }
        }
    }

    private List<String> Array2List(char[][] chessboard) {
        List<String> chessboardList = new ArrayList<>();

        for(char[] c : chessboard) {
            chessboardList.add(String.copyValueOf(c));
        }
        return chessboardList;
    }

    private boolean isValid(int row, int col, int n, char[][] chessboard) {
        for(int i = 0; i < row; i++) {
            if(chessboard[i][col] == 'Q') return false;
        }
        for(int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {
            if(chessboard[i][j] == 'Q') return false;
        }
        for(int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {
            if(chessboard[i][j] == 'Q') return false;
        }
        return true;
    }

}
```

```java
// 方法2：使用boolean数组表示已经占用的直(斜)线
class Solution {
    List<List<String>> res = new ArrayList<>();
    boolean[] usedCol, usedDiag45, usedDiag135;    // boolean数组中的每个元素代表一条直(斜)线
    public List<List<String>> solveNQueens(int n) {
        usedCol = new boolean[n];                  // 列方向的直线条数为 n
        usedDiag45 = new boolean[2 * n - 1];       // 45°方向的斜线条数为 2 * n - 1
        usedDiag135 = new boolean[2 * n - 1];      // 135°方向的斜线条数为 2 * n - 1
        //用于收集结果, 元素的index表示棋盘的row，元素的value代表棋盘的column
        int[] board = new int[n];
        backTracking(board, n, 0);
        return res;
    }
    private void backTracking(int[] board, int n, int row) {
        if (row == n) {
            //收集结果
            List<String> temp = new ArrayList<>();
            for (int i : board) {
                char[] str = new char[n];
                Arrays.fill(str, '.');
                str[i] = 'Q';
                temp.add(new String(str));
            }
            res.add(temp);
            return;
        }

        for (int col = 0; col < n; col++) {
            if (usedCol[col] | usedDiag45[row + col] | usedDiag135[row - col + n - 1]) {
                continue;
            }
            board[row] = col;
            // 标记该列出现过
            usedCol[col] = true;
            // 同一45°斜线上元素的row + col为定值, 且各不相同
            usedDiag45[row + col] = true;
            // 同一135°斜线上元素row - col为定值, 且各不相同
            // row - col 值有正有负, 加 n - 1 是为了对齐零点
            usedDiag135[row - col + n - 1] = true;
            // 递归
            backTracking(board, n, row + 1);
            usedCol[col] = false;
            usedDiag45[row + col] = false;
            usedDiag135[row - col + n - 1] = false;
        }
    }
}
```

### 37、解数独

#### 题目

题目链接：**[37. 解数独 - 力扣（LeetCode）](https://leetcode.cn/problems/sudoku-solver/)**

编写一个程序，通过填充空格来解决数独问题。

数独的解法需 **遵循如下规则**：

1. 数字 `1-9` 在每一行只能出现一次。
2. 数字 `1-9` 在每一列只能出现一次。
3. 数字 `1-9` 在每一个以粗实线分隔的 `3x3` 宫内只能出现一次。（请参考示例图）

数独部分空格内已填入了数字，空白格用 `'.'` 表示。

 

**示例 1：**

![img](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/250px-sudoku-by-l2g-20050714svg.png)

```
输入：board = [["5","3",".",".","7",".",".",".","."],["6",".",".","1","9","5",".",".","."],
[".","9","8",".",".",".",".","6","."],
["8",".",".",".","6",".",".",".","3"],
["4",".",".","8",".","3",".",".","1"],
["7",".",".",".","2",".",".",".","6"],
[".","6",".",".",".",".","2","8","."],
[".",".",".","4","1","9",".",".","5"],
[".",".",".",".","8",".",".","7","9"]]
输出：[["5","3","4","6","7","8","9","1","2"],["6","7","2","1","9","5","3","4","8"],
["1","9","8","3","4","2","5","6","7"],
["8","5","9","7","6","1","4","2","3"],
["4","2","6","8","5","3","7","9","1"],
["7","1","3","9","2","4","8","5","6"],
["9","6","1","5","3","7","2","8","4"],
["2","8","7","4","1","9","6","3","5"],
["3","4","5","2","8","6","1","7","9"]]
解释：输入的数独如上图所示，唯一有效的解决方案如下所示：
```

 <img src="E:/MyFile/TyporaImgs/image-20230107104550879.png" alt="image-20230107104550879" style="zoom:50%;" />

**提示：**

- `board.length == 9`
- `board[i].length == 9`
- `board[i][j]` 是一位数字或者 `'.'`
- 题目数据 **保证** 输入数独仅有一个解

#### 思路

**二维递归**

N皇后问题是因为每⼀⾏每⼀列只放⼀个皇后，只需要⼀层for循环遍历⼀⾏，递归来来遍历列，然后⼀⾏⼀列确定皇后的唯⼀位置。

而本题中**棋盘的每一个位置都要放一个数字，并检查数字是否合法，解数独的树形结构要比N皇后更深更宽**

![image-20230107105615997](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20230107105615997.png)

回溯三部曲：

1. 确认递归函数以及参数

   **递归函数的返回值需要是boolean类型**，因为解数独找到一个符合条件（树的叶子结点）立即返回，相当于从根结点到叶子结点一条唯一路径，所以需要使用`boolean`返回值

   ```java
   void backtracking(char[][] board)
   ```

2. 确认递归终止条件

   本题递归不用终止条件，解数独是要遍历整个树形结构寻找可能的叶子结点就立即返回

   不用终止条件不会死循环 => 递归的下一层的棋盘一定比上一层的棋盘多一个数，等数填满了棋盘自然就终止，所以不需要终止条件

3. 单层搜索逻辑

   从上图可以看出本题需要的是一个二维的递归（也就是两个for煦暖嵌套着递归）

   **一个for循环遍历棋盘的行，一个for循环遍历棋盘的列，一行一列确定下来之后，递归遍历的这个位置放9个数字的可能性**

   ```java
   boolean backtracking(char[][] board){
       //「一个for循环遍历棋盘的行，一个for循环遍历棋盘的列，
       // 一行一列确定下来之后，递归遍历这个位置放9个数字的可能性！」
       for (int i = 0; i < 9; i++){ // 遍历行
           for (int j = 0; j < 9; j++){ // 遍历列
               if (board[i][j] != '.'){ // 跳过原始数字
                   continue;
               }
               for (char k = '1'; k <= '9'; k++){ // (i, j) 这个位置放k是否合适
                   if (isValid(i, j, k, board)){
                       board[i][j] = k;
                       if (backtracking(board)){ // 如果找到合适一组立刻返回
                           return true;
                       }
                       board[i][j] = '.';
                   }
               }
               // 9个数都试完了，都不行，那么就返回false
               return false;
               // 因为如果一行一列确定下来了，这里尝试了9个数都不行，说明这个棋盘找不到解决数独问题的解！
               // 那么会直接返回， 「这也就是为什么没有终止条件也不会永远填不满棋盘而无限递归下去！」
           }
       }
       // 遍历完没有返回false，说明找到了合适棋盘位置了
       return true;
   }
   ```

   注意此处`return false`的位置，因为如果一行一列确定下来了，这里尝试了9个数都不行，说明这个棋盘找不到解决数独问题的解，那么会直接返回，**这是为什么没有终止条件也不会永远填不满棋盘而无限递归下去**

**判断棋盘是否合法**

判断合法的三个维度：

- 同行是否重复
- 同列是否重复
- 九宫格内是否重复

```java
boolean isValid(int row, int col, char val, char[][] board){
    // 同行是否重复
    for (int i = 0; i < 9; i++){
        if (board[row][i] == val){
            return false;
        }
    }
    // 同列是否重复
    for (int j = 0; j < 9; j++){
        if (board[j][col] == val){
            return false;
        }
    }
    // 9宫格里是否重复
    int startRow = (row / 3) * 3;
    int startCol = (col / 3) * 3;
    for (int i = startRow; i < startRow + 3; i++){
        for (int j = startCol; j < startCol + 3; j++){
            if (board[i][j] == val){
                return false;
            }
        }
    }
    return true;
}
```

#### 实现

```java
class Solution {
    public void solveSudoku(char[][] board) {
        backtracking(board);
    }

    private boolean backtracking(char[][] board) {
        for(int i = 0; i < 9; i++) {
            for(int j = 0; j < 9; j++) {
                if(board[i][j] != '.') {
                    continue;
                }
                for(char k = '1'; k <= '9'; k++) {
                    if(isValid(i, j, k, board)) {
                        board[i][j] = k;
                        if(backtracking(board)) {
                            return true;
                        }
                        board[i][j] = '.';
                    }
                }
                return false;
            }
        }
        return true;
    }

    private boolean isValid(int row, int col, char val, char[][] board) {
        // 同行是否重复
        for (int i = 0; i < 9; i++){
            if (board[row][i] == val){
                return false;
            }
        }
        // 同列是否重复
        for (int j = 0; j < 9; j++){
            if (board[j][col] == val){
                return false;
            }
        }
        // 九宫格内是否重复
        int startRow = (row / 3) * 3;
        int startCol = (col / 3) * 3;
        for (int i = startRow; i < startRow + 3; i++){
            for (int j = startCol; j < startCol + 3; j++){
                if (board[i][j] == val){
                    return false;
                }
            }
        }
        return true;
    }
}
```





## 补充：性能分析

### 子集问题

- 时间复杂度：`O(n * 2^n)`，因为每⼀个元素的状态⽆外乎取与不取，所以时间复杂度为`O(2^n)`，构造每⼀组⼦集都需要填进数组，又有需要`O(n)`，最终时间复杂度：`O(n * 2^n)`
- 空间复杂度：`O(n)`，递归深度为n，所以系统栈所⽤空间为`O(n)`，每⼀层递归所⽤的空间都是常数级别，注意代码⾥的result和path都是全局变量，就算是放在参数⾥，传的也是引⽤，并不会新申请内存空间，最终空间复杂度为`O(n)`

### 排列问题

- 时间复杂度：`O(n!)`，这个可以从排列的树形图中很明显发现，每⼀层节点为n，第 ⼆层每⼀个分⽀都延伸了n-1个分⽀，再往下又是n-2个分⽀，所以⼀直到叶⼦节 点⼀共就是 `n * n-1 * n-2 * ..... 1 = n!`。
- 空间复杂度：`O(n)`，和⼦集问题同理。

**组合问题**

- 时间复杂度：`O(n * 2^n)`，组合问题其实就是⼀种⼦集的问题，所以组合问题最坏 的情况，也不会超过⼦集问题的时间复杂度。
- 空间复杂度：`O(n)`，和子集问题同理



