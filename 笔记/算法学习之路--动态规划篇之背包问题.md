<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [算法学习之路 --动态规划篇之背包问题](#%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF---%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AF%87%E4%B9%8B%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98)
  - [一、01背包](#%E4%B8%8001%E8%83%8C%E5%8C%85)
    - [01背包理论基础](#01%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80)
      - [01背包](#01%E8%83%8C%E5%8C%85)
    - [二维dp数组01背包](#%E4%BA%8C%E7%BB%B4dp%E6%95%B0%E7%BB%8401%E8%83%8C%E5%8C%85)
      - [理解过程：](#%E7%90%86%E8%A7%A3%E8%BF%87%E7%A8%8B)
      - [实现](#%E5%AE%9E%E7%8E%B0)
    - [一维dp数组（滚动数组）](#%E4%B8%80%E7%BB%B4dp%E6%95%B0%E7%BB%84%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84)
      - [代码实现](#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0)
    - [LeetCode--01背包面试题目解析](#leetcode--01%E8%83%8C%E5%8C%85%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90)
      - [416、分割等和子集](#416%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86)
        - [题目](#%E9%A2%98%E7%9B%AE)
        - [思路](#%E6%80%9D%E8%B7%AF)
        - [实现](#%E5%AE%9E%E7%8E%B0-1)
      - [1049、最后一块石头的重量II](#1049%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8Fii)
        - [题目](#%E9%A2%98%E7%9B%AE-1)
        - [思路](#%E6%80%9D%E8%B7%AF-1)
        - [实现](#%E5%AE%9E%E7%8E%B0-2)
      - [494、目标和](#494%E7%9B%AE%E6%A0%87%E5%92%8C)
        - [题目](#%E9%A2%98%E7%9B%AE-2)
        - [思路](#%E6%80%9D%E8%B7%AF-2)
        - [实现](#%E5%AE%9E%E7%8E%B0-3)
      - [474、一和零](#474%E4%B8%80%E5%92%8C%E9%9B%B6)
        - [题目](#%E9%A2%98%E7%9B%AE-3)
      - [思路](#%E6%80%9D%E8%B7%AF-3)
        - [实现](#%E5%AE%9E%E7%8E%B0-4)
  - [二、完全背包](#%E4%BA%8C%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85)
    - [完全背包理论基础](#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80)
      - [完全背包](#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85)
      - [过程理解](#%E8%BF%87%E7%A8%8B%E7%90%86%E8%A7%A3)
      - [代码实现](#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1)
    - [LeetCode-完全背包面试题目解析](#leetcode-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90)
      - [518、零钱兑换II](#518%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2ii)
        - [题目](#%E9%A2%98%E7%9B%AE-4)
        - [思路](#%E6%80%9D%E8%B7%AF-4)
        - [实现](#%E5%AE%9E%E7%8E%B0-5)
      - [377、组合总和IV](#377%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8Civ)
        - [题目](#%E9%A2%98%E7%9B%AE-5)
        - [思路](#%E6%80%9D%E8%B7%AF-5)
        - [实现](#%E5%AE%9E%E7%8E%B0-6)
      - [70、爬楼梯](#70%E7%88%AC%E6%A5%BC%E6%A2%AF)
        - [题目](#%E9%A2%98%E7%9B%AE-6)
        - [思路](#%E6%80%9D%E8%B7%AF-6)
        - [实现](#%E5%AE%9E%E7%8E%B0-7)
      - [322、零钱兑换](#322%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2)
        - [题目](#%E9%A2%98%E7%9B%AE-7)
        - [思路](#%E6%80%9D%E8%B7%AF-7)
        - [实现](#%E5%AE%9E%E7%8E%B0-8)
      - [279、完全平方数](#279%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0)
        - [题目](#%E9%A2%98%E7%9B%AE-8)
        - [思路](#%E6%80%9D%E8%B7%AF-8)
        - [实现](#%E5%AE%9E%E7%8E%B0-9)
      - [139、单词拆分](#139%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86)
        - [题目](#%E9%A2%98%E7%9B%AE-9)
        - [思路](#%E6%80%9D%E8%B7%AF-9)
        - [实现](#%E5%AE%9E%E7%8E%B0-10)
  - [三、多重背包](#%E4%B8%89%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85)
    - [多重背包理论基础](#%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80)
      - [多重背包](#%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85)
      - [代码实现](#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2)
  - [四、背包问题总结篇](#%E5%9B%9B%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E7%AF%87)
    - [背包递推公式](#%E8%83%8C%E5%8C%85%E9%80%92%E6%8E%A8%E5%85%AC%E5%BC%8F)
    - [遍历顺序](#%E9%81%8D%E5%8E%86%E9%A1%BA%E5%BA%8F)
      - [01背包](#01%E8%83%8C%E5%8C%85-1)
      - [完全背包](#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85-1)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

<!--more-->

# 算法学习之路 --动态规划篇之背包问题

## 一、01背包

### 01背包理论基础

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221213134144.png)

#### 01背包

```markdown
有N件物品和一个最多能背重量W的背包。第i件物品的重量是weight[i]，得到的价值是value[i]。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大
```

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221213134601.png)

这是标准的背包问题，以⾄于很多刷题的小伙伴看了这个自然就会想到背包，甚至都不知道暴力的解法应该怎么解了。 

这样其实是没有从底向上去思考，⽽是习惯性想到了背包，那么暴力的解法应该是怎么样的 呢？

**每⼀件物品其实只有两个状态，取或者不取**，所以可以使用**回溯法**搜索出所有的情况，那么时间复杂度就是O(2^n)，这⾥的n表⽰物品数量。

所以暴力的解法是指数级别的时间复杂度。进而才需要动态规划的解法来进行优化！



---

例子：背包的最大重量为4

物品为：

|       | 重量 | 价值 |
| ----- | ---- | ---- |
| 物品0 | 1    | 15   |
| 物品1 | 3    | 20   |
| 物品2 | 4    | 30   |

问背包能背的物品最大价值是多少？

---

### 二维dp数组01背包

#### 理解过程：

动归五部曲：

1. 确定dp数组以及下标的得含义
   ![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221213135346.png)
   `dp[i][j]`表示从下标为`[0-i]`的物品里任意取，放进容量为`j`的背包，最大的价值总和

2. 确定递推公式
   根据`dp[i][j]`的含义，有两个方向可以推出`dp[i][j]`：

   - 由`dp[i - 1][j]`推出，即背包容量为`j`，里面不放物品`i`的最大价值，此时`dp[i][j] = dp[i - 1][j]`
   - 由`dp[i - 1][j - weight[i]]`推出，`dp[i - 1][j - weight[i]]`为背包容量为`j - weight[i]`的时候不放物品`i`的最大价值，那么`dp[i - 1][j - weight[i]] + value[i]（物品 i 的价值）`，就是背包放物品`i`得到的最大价值

   => 递推公式：`dp[i][j] = Math.max(dp[i - 1][j],dp[i - 1][j - weight[i]] + value[i])`

3. dp数组初始化
   **关于初始化，⼀定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱。**

   - 首先从`dp[i][j]`的定义出发，如果背包容量`j`为0的话，即`dp[i][0]`，⽆论是选取哪些物品，背包价值总和⼀定为0
     ![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221213140354.png)

   - 其他情况
     状态转移方程：`dp[i][j] = Math.max(dp[i - 1][j],dp[i - 1][j - weight[i]] + value[i])`，可以看出 i 是由 i - 1 推导出来，那么 i 为 0 的时候就一定要初始化
     `dp[0][j]`，即 i 为0，存放编号0的物品的时候，各个容量的背包所能存放的最大价值
     那么很显然当`j < weight[0]`的时候，`dp[0][j] = 0`，因为背包容量比编号0的物品重量还小
     当`j >= weight[0]`的时候，`dp[0]j] = value[0]`，因为背包容量足够放编号0的物品

     ```java
     // 初始化代码
     for (int j = 0 ; j < weight[0]; j++) {
          // 当然这⼀步，如果把dp数组预先初始化为0了，这⼀步就可以省略
      	dp[0][j] = 0;
     }
     // 正序遍历
     for (int j = weight[0]; j <= bagWeight; j++) {
      	dp[0][j] = value[0];
     }
     ```

     ![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221213140950.png)
     `dp[0][j] `和 `dp[i][0] `都已经初始化了，那么其他下标应该初始化多少呢？ 
     其实从递推公式：` dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])` ；可以看出`dp[i][j] `是由左上方数值推导出来的，那么 其他下标初始为什么数值都可以，因为都会被覆盖。
     初始-1，初始-2，初始100，都可以！ 
     但只不过⼀开始就统⼀把dp数组统⼀初始为0，更方便⼀些
     ![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221213141208.png)
     最后初始化代码：

     ```java
     int[][] dp = new int[weight.length][bagweight + 1]
     for (int j = weight[0]; j <= bagWeight; j++) {
      	dp[0][j] = value[0];
     }
     ```

4. 确定遍历顺序
   ![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221213141455.png)
   从图中可以看出，有两个遍历的维度：物品与背包重量
   => 先遍历物品或者先遍历背包重量都可以，但是**先遍历物品更好理解**

   - 先遍历物品，然后遍历背包重量

     ```java
     // weight数组的大小就是物品个数
     for(int i = 1; i < weight.length; i++) { // 遍历物品
          for(int j = 0; j <= bagWeight; j++) { // 遍历背包容量
              if (j < weight[i]) dp[i][j] = dp[i - 1][j]; // 这个是为了展现dp数组⾥元素的变化
              else dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
          }
     }
     ```

   - 先遍历背包重量，再遍历物品

     ```java
     // weight数组的大小就是物品个数
     for(int j = 0; j <= bagWeight; j++) { // 遍历背包容量
          for(int i = 1; i < weight.length; i++) { // 遍历物品
              if (j < weight[i]) dp[i][j] = dp[i - 1][j];
              else dp[i][j] =Math.max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
          }
     }
     ```

   > 二者都可以的原因：
   >
   > 要理解递推的本质和递推的方向
   > ` dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])` 
   >
   > 从递推公式中可以看出`dp[i][j]`是靠`dp[i - 1][j]`和`dp[i - 1][j - weight[i]]`推导出来的
   > `dp[i - 1][j]`和`dp[i - 1][j - weight[i]]`都在`dp[i][j]`的左上角方向（包括正左和正上两个方向）
   >
   > - 先遍历物品再遍历背包重量的过程如图所示
   >   ![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221213142328.png)
   > - 先遍历背包，再遍历物品的过程如图
   >   ![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221213142431.png)
   >
   > => 虽然两个for循环遍历的次序不同，但是`dp[i][j]`所需要的数据就是左上角，不影响`dp[i][j]`公式的推导，但是先遍历物品再遍历背包这个顺序更好理解

5. 举例推导dp数组

   ![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221213142705.png)

#### 实现

Java测试代码

```java
public class TwoWeiBaoProblem {
    /**
     * 物品重量
     */
    private static final int[] weight;

    /**
     * 价值
     */
    private static final int[] value;

    /**
     * 背包重量
     */
    private static final int bagWeight;

    static {
        weight = new int[]{1,3,4};
        value = new int[]{15,20,30};
        bagWeight = 4;
    }

    public static int twoWeiBaoProblem() {
        int[][] dp = new int[weight.length][bagWeight + 1];

        // 初始化
        for(int j = bagWeight;j >= weight[0];j--) {
            dp[0][j] = dp[0][j - weight[0]] + value[0];
        }

        // weight数组的大小就是物品个数
        // 先遍历物品再遍历背包容量
        for(int i = 1;i < weight.length;i++) {
            for(int j = 0;j <= bagWeight;j++) {
                if(j < weight[i]) dp[i][j] = dp[i - 1][j];
                else dp[i][j] = Math.max(dp[i - 1][j],dp[i - 1][j - weight[i]] + value[i]);
            }
        }
        System.out.println(Arrays.deepToString(dp));
        return dp[weight.length - 1][bagWeight];
    }

    public static void main(String[] args) {
        System.out.println(twoWeiBaoProblem());
    }
}
```

dp数据

[
    [0, 15, 15, 15, 15],
    [0, 15, 15, 20, 35], 
    [0, 15, 15, 20, **35**]
]

上述遍历的过程也可以这么写：

```java
// 遍历过程
for(int i = 1; i < weight.length; i++) { // 遍历物品
     for(int j = 0; j <= bagWeight; j++) { // 遍历背包容量
         if (j - weight[i] >= 0) {
             dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
         }
     }
}
```

这么写打印出来的dp数据：

[
    [0, 15, 15, 15, 15],
    [0, 0, 0, 20, 35],
    [0, 0, 0, 0, **35**]
]

### 一维dp数组（滚动数组）

####过程理解

对于背包问题，其实状态问题都是可以压缩的

在使用二维数组时，递推公式：`dp[i][j] = Math.max(dp[i - 1][j],dp[i - 1][j - weight[i]] + value[i]);`，
可以发现如果把`dp[i - 1]`那一层拷贝到`dp[i]`上，递推公式是：`dp[i][j] = Math.max(dp[i][j],dp[i][j - weight[i]] + value[i]);`
与其把`dp[i - 1]`这一层拷贝到`dp[i]`上，不如只用一个一维数组，只用`dp[j]`（一维数组，也可以理解成是一个滚动数组）

=> 滚动数组需要满足：上一层可以重复利用，直接拷贝到当前层

> 回顾：
>
> `dp[i][j]`中 `i` => 物品，`j` => 背包容量
>
> `dp[i][j]` => 表示从下标为`[0 - i]`的物品内任意取，放进容量为`j`的背包，最大的价值总和

动规五部曲：

1. 确定dp数组的定义

   在一维dp数组中，`dp[j]` => 容量为`j`的背包，所背的最大物品价值总和

2. 一维dp数组的递推公式

   `dp[j]`可以通过`dp[j - weight[j]]`推导出来，`dp[j - weight[j]]`表示容量为`j - weight[i]`的背包所背的最大价值，`dp[j - weight[j]] + value[i]`表示容量为`j - 物品 i 的重量的背包加上物品 i 的价值`（也就是容量为 j 的背包，放入物品 i 了之后的价值即`dp[j]`

   此时`dp[j]`有两个选择，一个是取自己的`dp[j]`，一个是取`dp[j - weight[i]] + value[i]`，二者取最大即可

   => 递推公式：`dp[j] = Math.max(dp[j],dp[j - weight[i]] + value[i])`

   可以看出，相较于二维dp数组的写法，就是把`dp[i][j]`中 `i` 的维度去掉了

3. 一维dp数组的初始化

   **关于初始化，⼀定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱**

   `dp[j]`表示容量为`j`的背包，所背的最大物品价值总和

   => `dp[0] = 0`，因为背包容量为0所背的物品的最大价值就是0

   那么dp数组除了下标0的位置，初始为0，其他下标应该初始化多少呢？ 

   观察递归公式：`dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i])`; 

   dp数组在推导的时候⼀定是取价值最大的数，

   - 如果题⽬给的价值都是正整数那么非0下标都初始化为0就可以了
   - 如果题⽬给的价值有负数，那么非0下标就要初始化为负无穷 

   这样才能让dp数组在递归公式的过程中取的最⼤的价值，而不是被初始值覆盖了。 这里假设物品价值都是⼤于0的，所以dp数组初始化的时候，都初始为0就可以了

4. 一维dp数组遍历顺序

   ```java
   for(int i = 0; i < weight.length; i++) { // 遍历物品
        for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
        	dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
        }
   }
   
   ```

   **这里遍历顺序与二维dp的写法顺序是不一样的**

   二维dp遍历的时候，背包容量是从小到大的，而一维dp数组遍历的时候，背包是从大到小

   原因：

   **倒序遍历是为了保证物品 i 只被放入一次**

   > 二维数组初始化`dp[0][j]`时的代码
   >
   > ```java
   > // 倒叙遍历
   > for (int j = bagWeight; j >= weight[0]; j--) {
   >  dp[0][j] = dp[0][j - weight[0]] + value[0]; // 初始化i为0时候的情况
   > }
   > ```
   >
   > `dp[0][j]`表示容量为j的背包存放物品0时候的最大价值，物品0的价值就是15，因为题目中说了**每个物品只有一个！**所以`dp[0][j]`如果不是初始值的话，就应该都是物品0的价值，也就是15。
   >
   > 但如果一旦正序遍历了，那么物品0就会被重复加入多次!
   >
   > ```java
   > // 正序遍历
   > for (int j = weight[0]; j <= bagWeight; j++) {
   >  dp[0][j] = dp[0][j - weight[0]] + value[0];
   > }
   > ```
   >
   > 例如`dp[0][1]` 是15，到了`dp[0][2] = dp[0][2 - 1] + 15;` 也就是`dp[0][2] = 30` 了，那么就是物品0被重复放入了
   >
   > => 一定要倒序遍历，保证编号为0的物品只被放入一次

   举一个例子：物品0的重量`weight[0] = 1`，价值`value[0] = 15`

   如果正序遍历
   `dp[1] = dp[1 - weight[0]] + value[0] = 15` 

   `dp[2] = dp[2 - weight[0]] + value[0] = 30`
   此时`dp[2] = 30`，意味着物品0被放入两次，所以不能正序遍历

   如果倒序遍历 （dp数组都已经初始化为0）
   `dp[2] = dp[2 - weight[0]] + value[0] = 15`
   `dp[1] = dp[1 - weight[0]] + value[0] = 15` 

   所以从后往前遍历，每次取得的状态都不会和之前的状态重合，这样每种物品就只取一次了

   > 为什么二维数组遍历时不需要倒序？
   >
   > 因为对于⼆维dp，`dp[i][j]`都是通过上⼀层即`dp[i - 1][j]`计算⽽来，本层的`dp[i][j]`并不会被覆盖
   >
   > 再来看两个嵌套for循环的顺序，代码中是先遍历物品嵌套遍历背包容量，那可不可以先遍历背包容量再遍历物品呢？ 不可以！
   > 因为⼀维dp的写法，背包容量⼀定是要倒序遍历，如果遍历背包容量放在上⼀层，那么每个dp[j]就只会放⼊⼀个物品，即：背包⾥只放⼊了⼀个物品。
   >
   >
   > => **代码中DeBug**

5. 举例推导dp数组
   ![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221214084241.png)

####  代码实现

```java
public class OneWeiBaoProblem {
    /**
     * 物品重量
     */
    private static final int[] weight;

    /**
     * 价值
     */
    private static final int[] value;

    /**
     * 背包重量
     */
    private static final int bagWeight;

    static {
        weight = new int[]{1,3,4};
        value = new int[]{15,20,30};
        bagWeight = 4;
    }

    public void oneWeiBaoProblem() {
        int[] dp = new int[bagWeight + 1];

        // 遍历物品
        for (int i = 0; i < weight.length; i++) {
            // 遍历背包容量
            for(int j = bagWeight;j >= weight[i];j--) {
                dp[j] = Math.max(dp[j],dp[j - weight[i]] + value[i]);
            }
            System.out.printf("物品%d : %s\n",i, Arrays.toString(dp));
        }

        System.out.println(dp[bagWeight]);
    }

    public static void main(String[] args) {
        new OneWeiBaoProblem().oneWeiBaoProblem();
    }
}
```



### LeetCode--01背包面试题目解析

#### 416、分割等和子集

##### 题目

题目链接：https://leetcode-cn.com/problems/partition-equal-subset-sum/

给你一个 **只包含正整数** 的 **非空** 数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等

示例 1：

输入：nums = [1,5,11,5]
输出：true
解释：数组可以分割成 [1, 5, 5] 和 [11] 。

示例 2：

输入：nums = [1,2,3,5]
输出：false
解释：数组不能分割成两个元素和相等的子集。

**提示：**

- `1 <= nums.length <= 200`
- `1 <= nums[i] <= 100`

##### 思路

这道题是要找是否可以将这个数组分割成两个子集，使得两个子集的元素和相等 => 只要找到集合里能够出现 `sum / 2`的子集总和，就算是可以分割成两个相同元素和子集了

> #### 01背包问题 
>
> 背包问题，有N件物品和⼀个最多能被重量为W 的背包。第i件物品的重量是 weight[i]，得到的价值是value[i] 。每件物品只能用⼀次，求解将哪些物品装⼊背包⾥物品价值总和最⼤
>
> 背包问题有多种背包⽅式，常见的有：01背包、完全背包、多重背包、分组背包和混合背 包等等。 
>
> 要注意题⽬描述中商品是不是可以重复放⼊。 
>
> 即⼀个商品如果可以重复多次放⼊是完全背包，⽽只能放⼊⼀次是01背包，写法还是不⼀ 样的

**明确本题我们要使用的是01背包，因为元素我们只用一次**

回归主题：首先，本题要求集合里能否出现总和为`sum / 2`的子集

=> **只有确定了如下四点，才能把01背包问题套到本题上来**

- 背包的体积为`sum / 2`
- 背包要放入的商品（集合里的元素）重量为元素的数值，价值也为元素的数值
- 背包如果正好装满，说明找到了总和为`sum / 2`的子集
- 背包中每一个元素都是不可重复放入的

动规五部曲分析：

1. 确定dp数组以及下标的含义
   01背包中，`dp[i]` 表示： 容量为`i`的背包，所背的物品价值可以最⼤为`dp[i]` => 套到本题，`dp[i]`表示背包总容量是`i`，最⼤可以凑成`i`的子集总和为`dp[i]`

2. 确定递推公式
   01背包的递推公式：`dp[j]  = Math.max(dp[j],dp[j - weight[i]] + value[i])`，本题相当于背包里放入数值，那么物品`i`的重量为`nums[i]`，其价值也是`nums[i]` => 递推公式：`dp[j] = Math.max(dp[j],dp[j - nums[i]] + nums[i])`

3. dp数组初始化
   在01背包，⼀维dp的初始化：从dp[j]的定义来看，首先dp[0]⼀定是0。如果题目给的价值都是正整数那么非0下标都初始化为0就可以了，如果题目给的价值有负数，那么非0下标就要初始化为负无穷。 这样才能**让dp数组在递归公式的过程中取的最大的价值，而不是被初始值覆盖了**
   本题题目中只包含正整数的非空数组，所以非0下标的元素初始化为0即可

   ```java
   // 题⽬中说：每个数组中的元素不会超过 100，数组的大小不会超过 200
   // 总和不会⼤于20000，背包最大只需要其中⼀半，所以10001大小就可以了
   int[] dp = new int[10001];
   ```

4. 确定遍历顺序
   在**一维dp数组（滚动数组）**中已经说明：如果使用一维dp数组，物品遍历的for循环放在外层，遍历背包的for循环放在内层，且内存for循环为倒序遍历

   ```java
   for(int i = 0; i < nums.length; i++) {
       for(int j = target; j >= nums[i]; j--) { // 每⼀个元素⼀定是不可重复放⼊，所以从⼤到⼩遍历
           dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]);
       }
   }
   ```

5. 举例推导dp数组
   `dp[i] <= i`（始终成立）
   若`dp[i] == i`说明**集合中的子集和正好可以凑成总和i**
   以示例1，输入`[1,5,11,5]`为例
   ![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221215142502.png)
   最后`dp[11] == 11` => 说明可以将这个数组分割成两个子集，使得两个子集的元素和相等

##### 实现

Java代码：

```java
// 时间复杂度：O(n ^ 2)
// 空间复杂度：O(n)
class Solution {
    public boolean canPartition(int[] nums) {
        int sum = 0; // 记录数组总和
        int[] dp = new int[10001];
        for(int i = 0; i < nums.length; i++) {
            sum += nums[i];
        }
        // 如果sum不能均分，直接返回false
        if(sum % 2 == 1) return false;
        int target = sum / 2;

        for(int i = 0; i < nums.length; i++) {
            for(int j = target; j >= nums[i]; j--) {
                dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]);
            }
        }
        // 集合中的元素正好可以凑成总和target
        return dp[target] == target;
    }
}
```



#### 1049、最后一块石头的重量II

##### 题目

题目链接：https://leetcode.cn/problems/last-stone-weight-ii/

有一堆石头，用整数数组 stones 表示。其中 `stones[i] `表示第` i `块石头的重量。

每一回合，从中选出**任意两块石头**，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x <= y。那么粉碎的可能结果如下：

- 如果 x == y，那么两块石头都会被完全粉碎；
- 如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x

最后，**最多只会剩下一块**石头。返回此石头 **最小的可能重量** 。如果没有石头剩下，就返回 0。

示例 1：

输入：stones = [2,7,4,1,8,1]
输出：1
解释：
组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，
组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，
组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，
组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。

示例 2：

输入：stones = [31,26,33,21,40]
输出：5


提示：

- `1 <= stones.length <= 30`
- `1 <= stones[i] <= 100`

##### 思路

本题其实就是尽量让石头分成重量相同的两堆，相撞之后剩下的石头重量最小，这样就化解成01背包问题

本题物品的重量为`store[i]`，物品价值也是`store[i]`

动归五部曲：

1. 确定dp数组以及下标的含义
   `dp[j]`表示容量（这里容量其实就是重量）为`j`的背包，最多可以背`dp[j]`这么重的石头

2. 确定递推公式
   `dp[j] = Math.max(dp[j], dp[j - store[i]] + store[i])`

3. dp数组初始化
   `dp[j]`表示容量，那么最大容量就是所有石头的重量和，根据题目提示得知最大重量和为30 \* 1000 => 我们只需要把dp数组开到15000的大小就可以了

   > 当然也可以把⽯头遍历⼀遍，计算出⽯头总重量然后除以2，得到dp数组的⼤⼩。

   因为重量不会是负数，所以`dp[j]`初始化为0即可

   ```java
   int [] dp = new int[15001];
   ```

4. 确定遍历顺序
   在**一维dp数组（滚动数组）**中已经说明：如果使用一维dp数组，物品遍历的for循环放在外层，遍历背包的for循环放在内层，且内存for循环为倒序遍历

   ```java
   for (int i = 0; i < stones.length; i++) { // 遍历物品
        for (int j = target; j >= stones[i]; j--) { // 遍历背包
        	dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i]);
        }
   }
   ```

5. 举例推导dp数组
   输⼊：[2,4,1,1]，此时target = (2 + 4 + 1 + 1)/2 = 4 ，dp数组状态图如下：
   ![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221215150927.png)
   最后，`dp[target]`里是容量为target的背包所能背的最大重量 => 分成的两堆石头，一堆石头的总重量为`dp[target]`，另一堆石头就是`sum - dp[target]`

   > 在计算`target`的时候，`target = sum / 2`是向下取整，所以`sum - dp[target] >= dp[target]`

   => 相撞之后剩下的最小的石头重量就是`(sum - dp[target]) - dp[target] = sum - 2 * dp[target]`

##### 实现

Java代码

```java
// 时间复杂度：O(m * n) , m是⽯头总重量（准确的说是总重量的⼀半），n为⽯头块数
// 空间复杂度：O(m)
class Solution {
    public int lastStoneWeightII(int[] stones) {
        int sum = 0;
        for(int i = 0; i < stones.length; i++) sum += stones[i];
        int target = sum / 2;
        int[] dp = new int[target + 1];
        for(int i = 0; i < stones.length; i++) {
            for(int j = target; j >= stones[i]; j--) {
                dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i]);
            }
        }
        return sum - 2 * dp[target];
    }
}
```



#### 494、目标和

##### 题目

题目链接：https://leetcode-cn.com/problems/target-sum/

给你一个整数数组 `nums` 和一个整数 `target`

向数组中的每个整数前添加 `'+'` 或 `'-'` ，然后串联起所有整数，可以构造一个 **表达式** 

- 例如，`nums = [2, 1]` ，可以在 `2` 之前添加 `'+'` ，在 `1` 之前添加 `'-'` ，然后串联起来得到表达式 `"+2-1"` 。

返回可以通过上述方法构造的、运算结果等于 `target` 的不同 **表达式** 的数目

示例 1：

输入：nums = [1,1,1,1,1], target = 3
输出：5
解释：一共有 5 种方法让最终目标和为 3 。
-1 + 1 + 1 + 1 + 1 = 3
+1 - 1 + 1 + 1 + 1 = 3
+1 + 1 - 1 + 1 + 1 = 3
+1 + 1 + 1 - 1 + 1 = 3
+1 + 1 + 1 + 1 - 1 = 3

示例 2：

输入：nums = [1], target = 1
输出：1

**提示：**

- `1 <= nums.length <= 20`
- `0 <= nums[i] <= 1000`
- `0 <= sum(nums[i]) <= 1000`
- `-1000 <= target <= 1000`



##### 思路

本题要使表达式结果为`target`，既然为`target`，那么一定有`left组合 - right组合 = target`，而`left + right = sum`，sum是固定的 => `left - (sum - left) = target` => `left = (target + sum) / 2`，`target`和`sum`都是固定的，就可以求出`left` => 此时问题就是在集合`nums`中找出和为`left`的组合

如何转化为01背包问题？

假设做加法运算的元素总和为`x`，那么做减法运算的元素总和就是`sum - x` => 我们要求的是`x - (sum - x) = target` => `x = (target + sum) / 2`
此时问题转化为**装满容量为x的背包，有几种方法**

> ` (target + sum) / 2`计算过程向下取整有影响
>
> ```java
> if((target +sum) % 2 == 1) return 0; // 此时没有方案（也就是 target + sum为奇数时）
> ```
>
> **看到这种表达式，本能的反应应该是两个int相加数值可能溢出的问题，当然本题并没有溢出**

再回归到01背包问题，为什么是01背包呢？
 因为每个物品（题⽬中的1）只用⼀次！ 
这次和之前遇到的背包问题不⼀样，之前都是求容量为`j`的背包，最多能装多少。
本题则是装满有几种⽅法，其实这就是⼀个组合问题了。

动归五部曲：

1. 确定dp数组以及下标的含义
   `dp[j]`表示填满`j`这么体积的包有`dp[j]`种方法

   > 其实也可以使⽤⼆维dp数组来求解本题，`dp[i][j]`：使⽤ 下标为`[0, i]`的`nums[i]`能够凑满`j（包括j）`这么⼤容量的包，有`dp[i][j]`种⽅法。

2. 确定递推公式
   有哪些路径可以推导出`dp[j]`？

   不考虑`nums[i]`的情况下，填满容量为`j - nums[i]`的背包，有`dp[j - nums[i]]`种方法，那么只要得到`nums[i]`，凑成`dp[j]`就有`dp[j - nums[j]]`种方法

   > 举⼀个例⼦,`nums[i] = 2`，`dp[3]`，填满背包容量为3的话，有dp[3]种⽅法。 那么只需要得得到⼀个2（nums[i]），有`dp[3]`⽅法可以凑齐容量为3的背包，相应的就有`dp[3]`⽅法可以凑齐容量为5的背包

   那么需要把这些方法累加起来就可以了，`dp[j] += dp[j - nums[i]]` 
   => 递推公式：`dp[j] += dp[j - nums[i]]`

   > 求组合类问题的公式都是类似这种
   >
   > ```java
   > dp[j] += dp[j - nums[i]];
   > ```

3. dp数组初始化
   从递推公式可以看出，在初始化的时候`dp[0]`一定要初始化为1，因为`dp[0]`是在公式中一切递推公式的起源，如果`dp[0] = 0`，递推结果都是0
   `dp[0] = 1`，理论上解释：装满容量为0的背包，有1种方法，就是装0件物品
   其他下标对应的数值应该初始化为0，从递归公式也可以看出，`dp[j]`要保证是0的初始值，才能正确的由`dp[j - nums[i]]`推导出来

4. 确定遍历顺序
   在**一维dp数组（滚动数组）**中已经说明：如果使用一维dp数组，物品遍历的for循环放在外层，遍历背包的for循环放在内层，且内存for循环为倒序遍历

   ```java
   for(int i = 0; i < nums.length; i++) {
       for(int j = bagSize; j >= nums[i]; j--) {
           dp[j] += dp[j - nums[i]];
       }
   }
   ```

5. 举例推导dp数组
   输入：nums:[1,1,1,1,1],target:3
   `bagSize = (sum + target) / 2 = 4`
   dp数组变化状态：
   ![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221215155237.png)

##### 实现

Java代码

```java
// 时间复杂度O(n * m)，n为正数个数，m为背包容量
// 空间复杂度：O(m) m为背包容量
class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        int sum = 0;
        for(int i = 0; i < nums.length; i++) sum += nums[i];
        // 以下三种情况没有方案
        if((target > sum) || (sum + target < 0)  || ((sum + target) % 2 == 1)) return 0;
        int bagSize = (sum + target) / 2;
        int[] dp = new int[bagSize + 1];
        // 初始化dp[0] = 1
        dp[0] = 1;
        for(int i = 0; i < nums.length; i++) {
            for(int j = bagSize;j >= nums[i]; j--) {
                dp[j] += dp[j - nums[i]];   
            }
        }
        return dp[bagSize];
    }
}
```



#### 474、一和零

##### 题目

题⽬链接：https://leetcode-cn.com/problems/ones-and-zeroes/

给你一个二进制字符串数组 `strs` 和两个整数 `m` 和 `n` 。

请你找出并返回 `strs` 的最大子集的长度，该子集中 **最多** 有 `m` 个 `0` 和 `n` 个 `1` 。

如果 `x` 的所有元素也是 `y` 的元素，集合 `x` 是集合 `y` 的 **子集** 。

示例 1：

输入：strs = ["10", "0001", "111001", "1", "0"], m = 5, n = 3
输出：4
解释：最多有 5 个 0 和 3 个 1 的最大子集是 {"10","0001","1","0"} ，因此答案是 4 
其他满足题意但较小的子集包括 {"0001","1"} 和 {"10","1","0"} 。{"111001"} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。

示例 2：

输入：strs = ["10", "0", "1"], m = 1, n = 1
输出：2
解释：最大的子集是 {"0", "1"} ，所以答案是 2 

**提示：**

- `1 <= strs.length <= 600`
- `1 <= strs[i].length <= 100`
- `strs[i]` 仅由 `'0'` 和 `'1'` 组成
- `1 <= m, n <= 100`



#### 思路

> 本题会被认为是多重背包，但其实不是
>
> ![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221213134144.png)
> 多重背包是每个物品，数量不同的情况
>
> 本题中strs数组里的元素就是物品，每个物品都是一个，而m和n相当于是一个背包，两个维度的背包
>
> 理解成多重背包主要是把m和n混淆为物品了，感觉这是不同数量的物品，所以以为是多重背包，但本题是01背包问题，只不过这个背包有两个维度，一个是m，一个是n，而不同长度的字符串就是不同大小的待装物品

动归五部曲：

1. 确定dp数组以及下标的含义
   `dp[i][j]`表示最多有 `i` 个 `0`和 `j`个`1`的`strs`的最大子集的大小为`dp[i][j]`

2. 确定递推公式
   `dp[i][j]`可以由前一个`strs`里的字符串推导出来，`strs`里的字符串有`zeroNum`个`0`，`oneNum`个`1`，`dp[i][j]  =  dp[i - zeroNum][j - oneNum] + 1`
   然后我们在遍历的时候取`dp[i][j]`的最大值
   => 递推公式：`dp[i][j] = Math.max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1)`

   > 此时可以回想⼀下01背包的递推公式：`dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);` 
   >
   > 对⽐⼀下就会发现，字符串的`zeroNum`和`oneNum`相当于物品的重量（`weight[i]`），字符串本⾝的个数相当于物品的价值（`value[i]`）。
   >
   > 这就是⼀个典型的01背包！ 只不过物品的重量有了两个维度⽽已

3. dp数组的初始化
   因为物品价值不会是负数，所以dp数组初始化为0，保证递推的时候`dp[i][j]`不会被初始值覆盖

   ```java
   int[][] dp = new int[m + 1][n + 1];
   ```

   

4. 确定遍历顺序
   在**一维dp数组（滚动数组）**中已经说明：如果使用一维dp数组，物品遍历的for循环放在外层，遍历背包的for循环放在内层，且内存for循环为倒序遍历
   本题也是如此，物品就是strs里面的字符串，背包容量就是题目给出的m和n

   ```java
   for (String str : strs) { // 遍历物品
        int oneNum = 0, zeroNum = 0;
        for(int k = 0; k < str.length(); k++) {
            char c = str.charAt(k);
            if('0' == c) zeroNum++;
            else oneNum++;
        }
        for (int i = m; i >= zeroNum; i--) { // 遍历背包容量且从后向前遍历！
            for (int j = n; j >= oneNum; j--) {
                dp[i][j] = Math.max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);
            }
        }
   }
   ```

   > 遍历背包容量的两个循环顺序无影响，都是物品重量的一个维度，先遍历哪个都可以

5. 举例推导dp数组
   以输⼊：["10","0001","111001","1","0"]，m = 3，n = 3为例
   最后dp数组的状态
   ![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221215162147.png)

##### 实现

Java代码

```java
class Solution {
    public int findMaxForm(String[] strs, int m, int n) {
        int[][] dp = new int[m + 1][n + 1];
        for(String str: strs) {
            int zeroNum = 0;
            int oneNum = 0;
            for(int k = 0; k < str.length(); k++) {
                char c = str.charAt(k);
                if('0' == c) zeroNum++;
                else oneNum++;
            }
            for(int i = m; i >= zeroNum; i--) {
                for(int j = n; j >= oneNum; j--) {
                    dp[i][j] = Math.max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);
                }
            }
        }
        return dp[m][n];
    }
}
```



## 二、完全背包

### 完全背包理论基础

#### 完全背包

有N件物品和一个最多能背重量W的背包。第i件物品的重量是weight[i]，得到的价值是value[i]。**每件物品都有无限个（也就是可以放入背包多次）**，求解将哪些物品装入背包里物品价值总和最大

**完全背包和01背包问题唯一不同的地方就是，每件物品有无限件**

---

例子：背包的最大重量为4

物品为：

|       | 重量 | 价值 |
| ----- | ---- | ---- |
| 物品0 | 1    | 15   |
| 物品1 | 3    | 20   |
| 物品2 | 4    | 30   |

每件商品都有无限个！

问背包能背的物品最大价值是多少？

---

#### 过程理解

> 01背包和完全背包唯⼀不同就是体现在遍历顺序上，下文直接针对遍历顺序进行分析

回顾下01背包遍历的核心代码

```java
for(int i = 0; i < weight.length; i++) { // 遍历物品
     for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
     	dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);
     }
}
```

01背包内嵌的循环是从大到小遍历的，是为了保证每个物品仅被添加一次

而完全背包的物品是可以添加多次的，所以要从小到大的遍历

```java
for(int i = 0; i < weight.length; i++) { // 遍历物品
     for(int j = weight[i]; j < bagWeight; j--) { // 遍历背包容量
     	dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);
     }
}
```

dp状态图如下：
![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221216090456.png)

> 问题：**为什么遍历物品在外层循环，遍历背包容量在内层循环？**
>
> 在上面01背包中，二维dp数组的两个for循环遍历的先后顺序是可以颠倒的，一维dp数组的两个for循环遍历先后顺序一定是先遍历物品，在遍历背包容量
>
> **在完全背包中，对于一维dp数组来说，其实两个for循环嵌套顺序同样无所谓**，因为`dp[j] `是根据 下标`j`之前所对应的`dp[j]`计算出来的。 只要保证下标`j`之前的`dp[j]`都是经过计算的就可以了
>
> 遍历物品在外层循环，遍历背包容量在内层循环，状态如图：
> ![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221216091053.png)
>
> 遍历背包容量在外层循环，遍历物品在内层循环，状态如图：
> ![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221216091513.png)
>
> 先遍历背包容量再遍历物品，代码如下：
>
> ```java
> // 先遍历背包，再遍历物品
> for(int j = 0; j <= bagWeight; j++) { // 遍历背包容量
>      for(int i = 0; i < weight.length; i++) { // 遍历物品
>          if (j - weight[i] >= 0) dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);
>      }
> }
> ```

#### 代码实现

Java代码：

```java
public class OneWeiBagProbem {
    /**
     * 物品重量
     */
    private static final int[] weight;

    /**
     * 价值
     */
    private static final int[] value;

    /**
     * 背包重量
     */
    private static final int bagWeight;

    static {
        weight = new int[]{1,3,4};
        value = new int[]{15,20,30};
        bagWeight = 4;
    }

    private void oneWeiCompleteBagProblem() {
        int[] dp = new int[bagWeight + 1];

        // 先遍历物品，再遍历背包容量
//        for(int i = 0; i < weight.length; i++) {
//            for(int j = weight[i]; j <= bagWeight; j++) {
//                dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);
//            }
//        }
        
        // 先遍历背包容量，再遍历物品
        for (int j = 0; j <= bagWeight; j++) {
            for(int i = 0; i < weight.length; i++) {
                if(j - weight[i] >= 0) {
                    dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);
                }
            }
        }

        System.out.println(Arrays.toString(dp));
        System.out.println(dp[bagWeight]);
    }

    @Test
    public void doTest() {
        oneWeiCompleteBagProblem();
    }
}

/**
打印输出结果：
	[0, 15, 30, 45, 60]
	60
*/
```

### LeetCode-完全背包面试题目解析

#### 518、零钱兑换II

##### 题目

题目链接：https://leetcode-cn.com/problems/coin-change-2/

给你一个整数数组 `coins` 表示不同面额的硬币，另给一个整数 `amount` 表示总金额。

给你一个整数数组 `coins` 表示不同面额的硬币，另给一个整数 `amount` 表示总金额。

假设每一种面额的硬币有无限个。 

题目数据保证结果符合 32 位带符号整数。

示例 1：

输入：amount = 5, coins = [1, 2, 5]
输出：4
解释：有四种方式可以凑成总金额：
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1

示例 2：

输入：amount = 3, coins = [2]
输出：0
解释：只用面额 2 的硬币不能凑成总金额 3 。

示例 3：

输入：amount = 10, coins = [10] 
输出：1



**提示：**

- `1 <= coins.length <= 300`
- `1 <= coins[i] <= 5000`
- `coins` 中的所有值 **互不相同**
- `0 <= amount <= 5000`

##### 思路

> 这是一套典型的背包问题，一看到钱币数目不限，就知道这是一个完全背包
>
> 但是本题和纯完全背包不一样，纯完全背包是能否凑成总金额，而本题是要求凑成总金额的个数

注意题目中描述的是凑成总金额的硬币**组合数**，组合数不强调元素之间的顺序，而排列强调这一点

动归五部曲：

1. 确定dp数组和下标的含义
   `dp[j]`：表示凑成总金额为`j`的货币组合数是`dp[j]`

2. 确定递推公式
   `dp[j]`（考虑`coins[i]`的组合总和）就是所有的`dp[j - coins[i]]`（不考虑`coins[i]`）相加
   =>递推公式： `dp[j] += dp[j - coins[i]]`（这个式子上文**494、目标和**一题中解释过）

3. dp数组初始化
   首先`dp[0]`一定要是1，这是递推的基础，从`dp[i]`的含义上来讲就是凑成总金额为0的货币组合数为1
   下标非0的`dp[j]`初始化为0，这样累计加`dp[j - coins[i]]`的时候才不会影响真正的`dp[j]`

4. 确定遍历顺序

   > 本题中遍历顺序有先遍历物品（钱币），再遍历背包容量（金钱总额）还是先遍历背包容量（金钱总额），再遍历物品（钱币）呢？
   >
   > 上文讲的理论基础中说完全背包的两个for循环的先后顺序随意
   >
   > **但是本题不行**
   >
   > 因为纯完全背包求的是能否凑成总和，跟凑成总和的元素有没有顺序没有关系（即：有关系也行，没有关系也行）
   >
   > 而本题要求凑成总和的组合数，**元素之间要求没有顺序**
   >
   > => 所以纯完全背包是能凑出总和即可，不关系过程；本题要求凑出来的方案个数，且方案个数是个组合数，所以两个for循环是有要求的

   **先遍历物品（钱币），再遍历背包容量（金钱总额）**

   ```java
   for (int i = 0; i < coins.length; i++) { // 遍历物品
        for (int j = coins[i]; j <= amount; j++) { // 遍历背包容量
        	dp[j] += dp[j - coins[i]];
        }
   }
   ```

   假设：`coins[0] = 1,coins[1] = 5`，那么就是先把1加入运算，然后再把5加入运算，得到的方法数量只有{1,5}这种情况，而不会出现{5,1}这种情况 => 这种遍历顺序中的`dp[j]`里计算的是组合数

   

   **先遍历背包容量（金钱总额），再遍历物品（钱币）**

   ```java
    for (int j = coins[i]; j <= amount; j++) { // 遍历背包容量	
   	for (int i = 0; i < coins.length; i++) { // 遍历物品
        	dp[j] += dp[j - coins[i]];
        }
   }
   ```

   背包里面的每一个值都是经过了1和5的计算，包含了{1,5}和{5,1}两种情况 => 这种遍历顺序中的`dp[j]`里计算的是排列数

5. 举例推导dp数组
   输入：amount = 5,coins = [1,2,5]
   ![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221216102450.png)
   最后红色框`dp[amount]`为最终结果

##### 实现

Java代码

```java
class Solution {
    public int change(int amount, int[] coins) {
        int[] dp = new int[amount + 1];
        dp[0] = 1;
        for(int i = 0; i < coins.length; i++) {
            for(int j = coins[i]; j <= amount; j++) {
                dp[j] += dp[j - coins[i]];
            }
        }
        return dp[amount];
    }
}
```

#### 377、组合总和IV

##### 题目

题⽬链接：https://leetcode-cn.com/problems/combination-sum-iv/

给你一个由 **不同** 整数组成的数组 `nums` ，和一个目标整数 `target` 。请你从 `nums` 中找出并返回总和为 `target` 的元素组合的个数

题目数据保证答案符合 32 位整数范围。

 示例 1：

输入：nums = [1,2,3], target = 4
输出：7
解释：
所有可能的组合为：
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)
**请注意，顺序不同的序列被视作不同的组合。**

示例 2：

输入：nums = [9], target = 3
输出：0

提示：

- `1 <= nums.length <= 200`
- `1 <= nums[i] <= 1000`
- `nums` 中的所有元素 **互不相同**
- `1 <= target <= 1000`

##### 思路

> 本题描述说是求组合，但又说顺序不同的序列被视作不同的组合，其实就是求**排列**，强调元素之间顺序

动归五部曲：

1. 确定dp数组以及下标的含义
   `dp[j]`：表示凑成目标正整数`j`的排列个数为`dp[j]`

2. 确定递推公式
   `dp[i]`（考虑`nums[j]`）可以由 `dp[i - nums[j]]`（不考虑`nums[j]`） 推导出来。 因为只要得到`nums[j]`，排列个数`dp[i - nums[j]]`，就是`dp[i]`的⼀部分 
   => 递推公式：`dp[j] += dp[j - nums[i]]`

3. dp数组初始化
   因为递推公式`dp[i] += dp[i - nums[j]]`的缘故，`dp[0]`要初始化为1，这样递推其他`dp[i]`的时候 才会有数值基础

   > ⾄于dp[0] = 1 有没有意义呢？ 
   > 其实没有意义，这里不强⾏解释它的意义了，因为题⽬中也说了：给定⽬标值是正整数！ 所以dp[0] = 1是没有意义的，仅仅是为了推导递推公式。

   非零下标的`dp[j]`初始化为0，这样才不会影响`dp[j]`累加所有的`dp[j - nums[i]]`

4. 确定遍历顺序
   个数可以不限使⽤，说明这是⼀个完全背包。 得到的集合是排列，说明需要考虑元素之间的顺序。 本题要求的是排列，那么这个for循环嵌套的顺序有要求
   在**518、零钱兑换II**中提到，**如果是求组合数就是外层for遍历物品，内层for遍历背包容量；如果是去排列数就是外层for遍历背包容量，内层for遍历物品**
   => 以本题遍历顺序最终遍历顺序：**target（背包）放在外循环，将nums（物品）放在内循环，内循环从前到后遍历**

5. 举例推导dp数组
   输入：nums = [1,2,3],target = 4
   ![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221216104215.png)

##### 实现

Java代码：

```java
class Solution {
    public int combinationSum4(int[] nums, int target) {
        int[] dp = new int[target + 1];
        dp[0] = 1;
        for(int j = 0; j <= target; j++) { // 遍历背包容量
            for(int i = 0; i < nums.length; i++) { // 遍历物品
                if(j - nums[i] >= 0) {
                    dp[j] += dp[j - nums[i]];
                }
            }
        }
        return dp[target];
    }
}
```



#### 70、爬楼梯

##### 题目

题目链接：https://leetcode-cn.com/problems/climbing-stairs/

假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。

每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢

示例 1：

输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶。
			1 阶 + 1 阶
			2 阶

示例 2：

输入：n = 3
输出：3
解释：有三种方法可以爬到楼顶。
			1 阶 + 1 阶 + 1 阶
			1 阶 + 2 阶
			2 阶 + 1 阶

**提示：**

- `1 <= n <= 45`

##### 思路

> 这道题在**动态规划篇之基础篇**中已经讲过
>
> 这里稍加改动下题目：
> **改为：⼀步⼀个台阶，两个台阶，三个台阶，.......，直到 m个台阶。问有多少种不同的⽅ 法可以爬到楼顶呢**
>
> 1阶，2阶，.... m阶就是物品，楼顶就是背包。 每⼀阶可以重复使⽤，例如跳了1阶，还可以继续跳1阶。 问跳到楼顶有⼏种⽅法其实就是问装满背包有⼏种⽅法  => 完全背包问题

动归五部曲：

1. 确定dp数组以及下标的含义
   `dp[i]`:表示爬到第`i`阶台阶有`dp[i]`中方法

2. 确定递推公式

   > 求装满背包有⼏种⽅法，递推公式⼀般都是dp[i] += dp[i - nums[j]];

   本题`dp[i]`的来源有`dp[i - 1]、dp[i - 2]等`，即`dp[i - j]`

   => 递推公式：`dp[i] += dp[i - j]`

3. dp数组初始化
   `dp[0] = 1`，其他非零下标的`dp[j] = 0`

4. 确定遍历顺序
   这是背包里求**排列**的问题，即：1、2 步 和 2、1 步都是上三个台阶，但是这两种方法不⼀ 样
   => 外层for遍历背包，内层for遍历物品，每⼀步可以⾛多次，这是完全背包，内循环需要从前向后遍历

5. 举例推导dp数组
   和**377、组合总和IV**几乎一样

   输入：nums = [1,2,3],target = 4
   ![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221216104215.png)

##### 实现

Java代码

```java
/**
代码中的m表示最多可以爬m阶台阶，本题只需要把m改成2就可以AC(accept)本题
*/
class Solution {
    public int climbStairs(int n) {
        int[] dp = new int[n + 1];
        dp[0] =1;
        for(int i = 1; i <= n; i++) {
            for(int j = 1; j <= m; j++) {
                if(i - j >= 0) dp[i] += dp[i - j];
            }
        }
        return dp[n];
    }
}
```



#### 322、零钱兑换

##### 题目

题⽬链接：https://leetcode-cn.com/problems/coin-change/

给你一个整数数组 `coins` ，表示不同面额的硬币；以及一个整数 `amount` ，表示总金额。

给你一个整数数组 `coins` ，表示不同面额的硬币；以及一个整数 `amount` ，表示总金额。

你可以认为每种硬币的数量是无限的。

示例 1：

输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 

示例 2：

输入：coins = [2], amount = 3
输出：-1

示例 3：

输入：coins = [1], amount = 0
输出：0

**提示：**

- `1 <= coins.length <= 12`
- `1 <= coins[i] <= 231 - 1`
- `0 <= amount <= 104`

##### 思路

> 题目中说每种硬币的数量时无限的  => 典型的完全背包问题

动归五部曲：

1. 确定dp数组以及下标的含义
   `dp[j]`：凑足总金额为`j`所需要的钱币最少个数是`dp[j]`

2. 确定递推公式
   得到`dp[j]`（考虑`coins[i]`），只有⼀个来源，`dp[j - coins[i]]`（没有考虑`coins[i]`）
   凑⾜总额为`j - coins[i]`的最少个数为`dp[j - coins[i]]`，那么只需要加上⼀个钱币`coins[i]`即`dp[j - coins[i]] + 1`就是`dp[j]`（考虑`coins[i]`） 所以`dp[j]` 要取所有` dp[j - coins[i]] + 1 `中最⼩的 
   => 递推公式：`dp[j] = Math.min(dp[j - coins[i]] + 1, dp[j]);`

3. dp数组初始化
   首先凑足总金额为0所需钱币的个数为0，那么`dp[0] = 0`
   对于其他下标对应的数值，考虑到递推公式的特性，`dp[j]`必须初始化为⼀个最⼤的数，否则就会在`Math.min(dp[j - coins[i]] + 1, dp[j])`⽐较的过程中被初始值覆盖 => 下标非零的元素初始化为最大值

   ```java
   int[] dp = new int[amount + 1];
   Arrays.fill(dp,Integer.MAX_VALUE);
   dp[0] = 0;
   ```

4. 确定遍历顺序
   本题求钱币最⼩个数，那么钱币有顺序和没有顺序都可以，都不影响钱币的最⼩个数。所以本题并不强调集合是组合还是排列
   => 所以本题的两个for循环的关系是：外层for循环遍历物品，内层for遍历背包或者外层for遍 历背包，内层for循环遍历物品**都是可以**的
   这里采用`coins`放在外循环，`target`放在内循环

5. 举例推导dp数组
   以输⼊：coins = [1, 2, 5], amount = 5为例
   ![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221216121619.png)

##### 实现

Java代码：

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        int[] dp = new int[amount + 1];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[0] = 0;
        for(int i = 0; i < coins.length; i++) { // 遍历物品
            for(int j = coins[i]; j <= amount; j++) { // 遍历背包容量
                if(dp[j - coins[i]] != Integer.MAX_VALUE) { // 如果dp[j - coins[i]] 是初始值则跳过
                    dp[j] = Math.min(dp[j], dp[j - coins[i]] + 1);
                }
            }
        }
        return dp[amount] == Integer.MAX_VALUE ? -1 : dp[amount];
    }
}
```

对于遍历⽅式遍历背包放在外循环，遍历物品放在内循环也是可以的

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        int[] dp = new int[amount + 1];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[0] = 0;
        for(int j = 1; j <= amount; j++) { // 遍历背包容量
            for(int i = 0; i < coins.length; i++) { // 遍历物品
                if(j - coins[i] >= 0 && dp[j - coins[i]] != Integer.MAX_VALUE) {
                    dp[j] = Math.min(dp[j], dp[j - coins[i]] + 1);
                }
            }
        }
        return dp[amount] == Integer.MAX_VALUE ? -1 : dp[amount];
    }
}
```

#### 279、完全平方数

##### 题目

题目链接：https://leetcode-cn.com/problems/perfect-squares/

给你一个整数 `n` ，返回 *和为 `n` 的完全平方数的最少数量* 。

**完全平方数** 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，`1`、`4`、`9` 和 `16` 都是完全平方数，而 `3` 和 `11` 不是

**示例 1：**

```
输入：n = 12
输出：3 
解释：12 = 4 + 4 + 4
```

**示例 2：**

```
输入：n = 13
输出：2
解释：13 = 4 + 9
```

**提示：**

- `1 <= n <= 104`

##### 思路

题目意思理解：**完全平方数就是物品（可以无限使用）。凑成正整数N就是背包，问凑满这个背包最少需要多少物品**

动归五部曲：

1. 确定dp数组以及下标的含义
   `dp[i]`：和为`i`的完全平方数的最少数量为`dp[i]`

2. 确定递推公式
   `dp[i]`可以由`dp[i - j * j]`推出，=> `dp[i] = dp[i - j * j] + 1`，此时我们要选择最小的`dp[i]` 
   => 递推公式：`dp[i] = Math.min(dp[i - j * j] + 1, dp[i])`

3. dp数组的初始化
   dp[0]表示和为0的完全平⽅数的最⼩数量，那么`dp[0] = 0`。

   > 0 * 0 也算是⼀种，为啥`dp[0] `就是 0呢？ 
   > 看题目描述，找到若⼲个完全平⽅数（⽐如 1, 4, 9, 16, ...），题目描述中没说要从0开 始，**dp[0]=0完全是为了递推公式**。 

   非0下标的`dp[i]`应该是多少呢？
   从递推公式`dp[i] = Math.min(dp[i - j * j] + 1, dp[i])`中可以看出每次dp[j]都要选最⼩的，所以非0下 标的`dp[i]`⼀定要初始为最大值，这样dp[j]在递推的时候才不会被初始值覆盖

   ```java
   int[] dp = new int[n + 1];
   Arrays.fill(dp, Integer.MAX_VALUE);
   dp[0] = 0;
   ```

4. 确定遍历顺序
   和**322、零钱兑换**一样，本题也是求最小数
   所以本题外层for遍历背包，⾥层for遍历物品，还是外层for遍历物品，内层for遍历背包， 都可以

   ```java
   for (int i = 0; i <= n; i++) { // 遍历背包
        for (int j = 1; j * j <= i; j++) { // 遍历物品
        	dp[i] = min(dp[i - j * j] + 1, dp[i]);
        }
   }
   ```

5. 举例推导dp数组
   ![image-20221217192726054](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20221217192726054.png)

##### 实现

Java代码：

```java
class Solution {
    public int numSquares(int n) {
        int[] dp = new int[n + 1];
        Arrays.fill(dp,Integer.MAX_VALUE);
        dp[0] = 0;
        for(int i = 1; i <= n; i++) { // 遍历背包
            for(int j = 1; j * j <= i; j++) { // 遍历物品
                dp[i] = Math.min(dp[i - j * j] + 1, dp[i]);
            }
        }
        return dp[n];
    }
}
```

先遍历物品，再遍历背包实现

```java
class Solution {
    public int numSquares(int n) {
        int[] dp = new int[n + 1];
        Arrays.fill(dp,Integer.MAX_VALUE);
        dp[0] = 0;
        for(int j = 1; j * j <= n; j++) { // 遍历物品
            for(int i = 1; i <= n; i++) { // 遍历背包
                if(i - j * j >= 0) {
                    dp[i] = Math.min(dp[i - j * j] + 1, dp[i]);
                }
                
            }
        }
        return dp[n];
    }
}
```

#### 139、单词拆分

##### 题目

题目链接：https://leetcode-cn.com/problems/word-break/ 

给你一个字符串 `s` 和一个字符串列表 `wordDict` 作为字典。请你判断是否可以利用字典中出现的单词拼接出 `s` 。

**注意：**不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。

**示例 1**：

```
输入: s = "leetcode", wordDict = ["leet", "code"]
输出: true
解释: 返回 true 因为 "leetcode" 可以由 "leet" 和 "code" 拼接成。
```

**示例 2：**

```
输入: s = "applepenapple", wordDict = ["apple", "pen"]
输出: true
解释: 返回 true 因为 "applepenapple" 可以由 "apple" "pen" "apple" 拼接成。
     注意，你可以重复使用字典中的单词。
```

**示例 3：**

```
输入: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
输出: false
```

**提示：**

- `1 <= s.length <= 300`
- `1 <= wordDict.length <= 1000`
- `1 <= wordDict[i].length <= 20`
- `s` 和 `wordDict[i]` 仅有小写英文字母组成
- `wordDict` 中的所有字符串 **互不相同**

##### 思路

题目解释：**单词就是物品，字符串s就是背包，单词能否组成字符串s，就是问物品能不能把背包装满，拆分时可以重复使用字典中的单词**

动归五部曲：

1. 确定dp数组以及下标的含义
   `dp[i]`：字符串长度为`i`的话，`dp[i]`为`true`，表⽰可以拆分为一个或多个在字典中出现的单词

2. 确定递推公式
   如果确定`dp[j] = true`，且`[j, i]`这个区间的子串出现在字典里，那么`dp[i] = true`，前提是`j < i`
   => 递推公式

   ```java
   if([j, i]这个区间的子串出现在字典里 && dp[j] = true){
       dp[i] = true
   }
   ```

3. dp数组初始化
   从递归公式中可以看出，`dp[i]` 的状态依靠` dp[j]`是否为`true`，那么`dp[0]`就是递归的根基， `dp[0]`⼀定要为`true`，否则递归下去后⾯都都是`false`了

   > dp[0]的意义完全是为了递推公式
   > dp[0]表⽰如果字符串为空的话，说明出现在字典⾥。 但题目中说了“给定⼀个非空字符串 s” 所以测试数据中不会出现`i`为0的情况

   下标非零的`dp[i`]初始化为`false`，只要没有被覆盖说明都是不可拆分为一个或者多个在字典中出现的单词

4. 确定遍历顺序
   题目中说是拆分为一个或者多个出现在字典中的单词 => 完全背包
   讨论；两层for循环的前后顺序

   > 如果求组合数就是外层for循环遍历物品，内层for遍历背包。 
   >
   > 如果求排列数就是外层for遍历背包，内层for循环遍历物品。
   >
   > 本题最终要求的是**是否都出现过**，所以对出现单词集合⾥的元素是组合还是排列，并不关心
   >
   > 那么本题使⽤求排列的方式，还是求组合的方式都可以。 即：外层for循环遍历物品，内层for遍历背包 或者 外层for遍历背包，内层for循环遍历物品都是可以的
   >
   > 但本题还有**特殊性**，因为是要**求⼦串**，最好是遍历背包放在外循环，将遍历物品放在内循环。 如果要是外层for循环遍历物品，内层for遍历背包，就需要把所有的⼦串都预先放在⼀个容器里（数组、列表都可以）
   >
   > => 遍历顺序：遍历背包（字符串s）在外层循环，遍历物品（字典）在内层循环，内循环从前往后

5. 举例推导dp数组
   ![image-20221217195417082](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20221217195417082.png)

##### 实现

```java
// 时间复杂度：O(n^3)，因为substr返回子串的副本是O(n)的复杂度（这⾥的n是substring的长度）
// 空间复杂度：O(n)
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        int sLen = s.length();
        Set<String> wordDictSet = new HashSet<>(wordDict);
        boolean[] dp = new boolean[sLen + 1];
        dp[0] = true;
        for(int i = 1; i <= sLen; i++) { // 遍历背包
            for(int j = 0; j < i; j++) {// 遍历物品
                String word = s.substring(j, i);
                if(dp[j] && wordDictSet.contains(word)){
                    dp[i] = true;
                    break;
                }
            }
        }
        return dp[sLen];
    }
}
```

## 三、多重背包

*掌握程度：知 道它是⼀种01背包，并能在01背包的基础上写出对应代码*

### 多重背包理论基础

#### 多重背包

有N种物品和⼀个容量为V的背包。第i种物品最多有M<sub>i</sub>件可⽤，每件耗费的空间是C<sub>i</sub>，价 值是W<sub>i</sub>。求解将哪些物品装⼊背包可使这些物品的耗费的空间总和不超过背包容量，且价值总和最大。

---

多重背包和01背包非常像 => 将多重背包中的每件物品最多有M<sub>i</sub>件展开，其实就是个01背包问题



**例如：**

背包的最大重量为10

物品为：

|       | 重量 | 价值 | 数量 |
| ----- | ---- | ---- | ---- |
| 物品0 | 1    | 15   | 2    |
| 物品1 | 3    | 20   | 3    |
| 物品2 | 4    | 30   | 2    |

问背包能背的物品最大价值是多少？

**和如下情况有区别吗？**

物品为：

|       | 重量 | 价值 | 数量 |
| ----- | ---- | ---- | ---- |
| 物品0 | 1    | 15   | 1    |
| 物品0 | 1    | 15   | 1    |
| 物品1 | 3    | 20   | 1    |
| 物品1 | 3    | 20   | 1    |
| 物品1 | 3    | 20   | 1    |
| 物品2 | 4    | 30   | 1    |
| 物品2 | 4    | 30   | 1    |

问背包能背的物品最大价值是多少？

=> **毫无区别，这就转换成了一个01背包问题了，且每个物品只用一次**

---

#### 代码实现

**实现方式一：展开成01背包**

```java
public class MultiBagProblem {
    /**
     * 物品重量
     */
    private final List<Integer> weight;

    /**
     * 价值
     */
    private final List<Integer> value;

    /**
     * 背包重量
     */
    private final int bagWeight;

    /**
     * 物品数量
     */
    private final List<Integer> nums;

    {
        weight = new ArrayList<>(Arrays.asList(1, 3, 4));
        value = new ArrayList<>(Arrays.asList(15, 20, 30));
        nums = new ArrayList<>(Arrays.asList(2, 3, 2));
        bagWeight = 10;
    }

    // 时间复杂度：O(m * n * k) m：物品种类个数，n背包容量，k单类物品数量
    public void multiBagProblem() {
        // 展开物品数量
        for (int i = 0; i < nums.size(); i++) {
            int num = nums.get(i);
            while (num > 1) {
                weight.add(weight.get(i));
                value.add(value.get(i));
                num--;
            }
        }
        // 转换成01背包问题
        int[] dp = new int[bagWeight + 1];
        // 遍历物品
        for (int i = 0;i < weight.size(); i++) {
            int w = weight.get(i);
            for (int j = bagWeight; j >= w; j--) { // 遍历背包
                dp[j] = Math.max(dp[j - w] + value.get(i), dp[j]);
            }
        }
        System.out.println(Arrays.toString(dp));
        System.out.println("结果" + dp[bagWeight]);
    }

    @Test
    public void testMultiBagProblem() {
        multiBagProblem();
    }
}
/**
[0, 15, 30, 30, 35, 50, 60, 60, 70, 80, 90]
结果90
*/
```

**实现方式二：把每种商品遍历的个数放在01背包⾥⾯在遍历⼀遍**

```java
public class MultiBagProblem2 {
    /**
     * 物品重量
     */
    private static final int[] weight;

    /**
     * 价值
     */
    private static final int[] value;

    /**
     * 背包重量
     */
    private static final int bagWeight;

    /**
     * 物品数量
     */
    private static final int[] nums;


    static {
        weight = new int[]{1, 3, 4};
        value = new int[]{15, 20, 30};
        nums = new int[]{2, 3, 2};
        bagWeight = 10;
    }

    public void multiBagProblem() {
        int[] dp = new int[bagWeight + 1];

        // 遍历物品
        for (int i = 0; i < weight.length; i++) {
            // 遍历背包
            for (int j = bagWeight; j >= weight[i]; j--) {
                // 遍历个数
                for (int k = 1; k <= nums[i] && j - k * weight[i] >= 0; k++) {
                    dp[j] = Math.max(dp[j], dp[j - k * weight[i]] + k * value[i]);
                }
            }
        }
        System.out.println(Arrays.toString(dp));
        System.out.println("结果" + dp[bagWeight]);
    }

    @Test
    public void testMultiBagProblem() {
        multiBagProblem();
    }
}
/**
[0, 15, 30, 30, 35, 50, 60, 60, 70, 80, 90]
结果90
*/
```

## 四、背包问题总结篇

几种常见的背包：

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221213134144.png)

理解背包问题所用到的**动归五部曲**：

1. 确定dp数组(dp table)以及下标的含义
2. 确定递推公式
3. dp数组的初始化
4. 确定遍历顺序
5. 举例推导dp数组

这五个步骤都很关键，但确定递推公式和确定遍历顺序都具有规律性和代表性

### 背包递推公式

1）问能否装满背包（或者最多装多少）：`dp[j] = Math,max(dp[j], dp[j - nums[i]] + nums[i])`，对应的题目如下：

- **[416. 分割等和子集 - 力扣（LeetCode）](https://leetcode.cn/problems/partition-equal-subset-sum/)**
- **[1049. 最后一块石头的重量 II - 力扣（LeetCode）](https://leetcode.cn/problems/last-stone-weight-ii/)**

2）问装满背包有几种方法：`dp[j] += dp[j - nums[i]]`，对应的题目如下：

- **[494. 目标和 - 力扣（LeetCode）](https://leetcode.cn/problems/target-sum/)**
- **[518. 零钱兑换 II - 力扣（LeetCode）](https://leetcode.cn/problems/coin-change-ii/)**
- **[377. 组合总和 Ⅳ - 力扣（LeetCode）](https://leetcode.cn/problems/combination-sum-iv/)**
- **70.爬楼梯进阶版（完全背包）**

3）问背包装满最大价值：`dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i])`，对应的题目如下：

- **[474. 一和零 - 力扣（LeetCode）](https://leetcode.cn/problems/ones-and-zeroes/)**

4）问装满背包所有物品的最小个数：`dp[j] = Math.min(dp[j - conins[i]] + 1, dp[j])`，对应的题目如下：

- **[322. 零钱兑换 - 力扣（LeetCode）](https://leetcode.cn/problems/coin-change/)**
- **[279. 完全平方数 - 力扣（LeetCode）](https://leetcode.cn/problems/perfect-squares/)**

### 遍历顺序

#### 01背包

- 二维dp数组01背包先遍历物品还是先遍历背包都是可以的，且第二层for循环是从小到大遍历
- 一维dp数组01背包只能先遍历物品在遍历背包容量，且第二层for循环是从大到小遍历

#### 完全背包

- 纯完全背包的一维dp数组实现， 先遍历物品还是先遍历背包都是可以的的，且第二层for循环是从小到大遍历
- 如果是求组合数就是外层for循环遍历物品，内层for循环遍历背包
- 如果是求排列数就是外层for循环遍历背包，内层for循环遍历物品
- 如果求最⼩数，那么两层for循环的先后顺序就无所谓了

